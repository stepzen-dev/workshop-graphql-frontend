import { GraphQLClient } from 'graphql-request';
import * as Dom from 'graphql-request/dist/types.dom';
import gql from 'graphql-tag';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** `Date` scalar type represents a date. Date is serialized as an RFC 3339 section 5.6 full-date quoted string */
  Date: any;
  /** `DateTime` scalar type represents a date and time. DateTime is serialized as an RFC 3339 quoted string */
  DateTime: any;
  /** A (potentially binary) string encoded using base64. */
  Github_Base64String: any;
  /** A Git object ID. */
  Github_GitObjectID: any;
  /** A fully qualified reference name (e.g. `refs/heads/master`). */
  Github_GitRefname: any;
  /** Git SSH string */
  Github_GitSSHRemote: any;
  /** An ISO-8601 encoded date string. Unlike the DateTime type, GitTimestamp is not converted in UTC. */
  Github_GitTimestamp: any;
  /** A string containing HTML code. */
  Github_HTML: any;
  /** An ISO-8601 encoded UTC date string with millisecond precision. */
  Github_PreciseDateTime: any;
  /** An RFC 3986, RFC 3987, and RFC 6570 (level 4) compliant URI string. */
  Github_URI: any;
  /** A valid x509 certificate string */
  Github_X509Certificate: any;
  /** `JSON` scalar type represents an arbitrary JSON value. */
  JSON: any;
  /** `Secret` is used as an argument type representing a secret such as an API key or token.Any value is always serialized as `********` in any GraphQL response to avoid any leakage of secrets.Values are Strings. */
  Secret: any;
};

/** Flare tag of the article */
export type Devto_ArticleFlareTag = {
  __typename?: 'Devto_ArticleFlareTag';
  bg_color_hex?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  text_color_hex?: Maybe<Scalars['String']>;
};

export type Devto_ArticleIndex = {
  __typename?: 'Devto_ArticleIndex';
  canonical_url: Scalars['String'];
  comments_count: Scalars['Int'];
  cover_image: Scalars['String'];
  created_at: Scalars['String'];
  crossposted_at: Scalars['String'];
  description: Scalars['String'];
  edited_at: Scalars['String'];
  flare_tag?: Maybe<Devto_ArticleFlareTag>;
  id: Scalars['Int'];
  last_comment_at: Scalars['String'];
  organization?: Maybe<Devto_SharedOrganization>;
  path: Scalars['String'];
  positive_reactions_count: Scalars['Int'];
  public_reactions_count: Scalars['Int'];
  published_at: Scalars['String'];
  published_timestamp: Scalars['String'];
  readable_publish_date: Scalars['String'];
  reading_time_minutes: Scalars['Int'];
  slug: Scalars['String'];
  social_image: Scalars['String'];
  tag_list?: Maybe<Scalars['JSON']>;
  tags: Scalars['String'];
  title: Scalars['String'];
  type_of: Scalars['String'];
  url: Scalars['String'];
  user: Devto_SharedUser;
};

export type Devto_ArticleShow = {
  __typename?: 'Devto_ArticleShow';
  body_html: Scalars['String'];
  body_markdown: Scalars['String'];
  canonical_url: Scalars['String'];
  comments_count: Scalars['Int'];
  cover_image: Scalars['String'];
  created_at: Scalars['String'];
  crossposted_at: Scalars['String'];
  description: Scalars['String'];
  edited_at: Scalars['String'];
  flare_tag?: Maybe<Devto_ArticleFlareTag>;
  id: Scalars['Int'];
  last_comment_at: Scalars['String'];
  organization?: Maybe<Devto_SharedOrganization>;
  path: Scalars['String'];
  positive_reactions_count: Scalars['Int'];
  public_reactions_count: Scalars['Int'];
  published_at: Scalars['String'];
  published_timestamp: Scalars['String'];
  readable_publish_date: Scalars['String'];
  reading_time_minutes: Scalars['Int'];
  slug: Scalars['String'];
  social_image: Scalars['String'];
  tag_list: Scalars['String'];
  tags?: Maybe<Scalars['JSON']>;
  title: Scalars['String'];
  type_of: Scalars['String'];
  url: Scalars['String'];
  user: Devto_SharedUser;
};

export type Devto_DevToComment = {
  __typename?: 'Devto_DevToComment';
  body_html: Scalars['String'];
  children?: Maybe<Array<Devto_DevToComment>>;
  created_at: Scalars['String'];
  id_code: Scalars['String'];
  type_of: Scalars['String'];
  user: Devto_SharedUser;
};

/** Organization */
export type Devto_DevToOrganization = {
  __typename?: 'Devto_DevToOrganization';
  github_username?: Maybe<Scalars['String']>;
  joined_at?: Maybe<Scalars['String']>;
  location?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  profile_image?: Maybe<Scalars['String']>;
  story?: Maybe<Scalars['String']>;
  summary?: Maybe<Scalars['String']>;
  tag_line?: Maybe<Scalars['String']>;
  tech_stack?: Maybe<Scalars['String']>;
  twitter_username?: Maybe<Scalars['String']>;
  type_of?: Maybe<Scalars['String']>;
  url?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
};

export type Devto_DevToUser = {
  __typename?: 'Devto_DevToUser';
  /** Get public Github profile information using the Devto github_username value. */
  github_details?: Maybe<Github_User>;
  github_username: Scalars['String'];
  id: Scalars['Int'];
  joined_at: Scalars['String'];
  location: Scalars['String'];
  name: Scalars['String'];
  profile_image: Scalars['String'];
  summary: Scalars['String'];
  twitter_username: Scalars['String'];
  type_of: Scalars['String'];
  username: Scalars['String'];
  website_url: Scalars['String'];
};


export type Devto_DevToUserGithub_DetailsArgs = {
  github_token: Scalars['Secret'];
};

export type Devto_GetArticlesWithVideoUser = {
  __typename?: 'Devto_GetArticlesWithVideoUser';
  name?: Maybe<Scalars['String']>;
};

export type Devto_GetPodcastEpisodesPodcast = {
  __typename?: 'Devto_GetPodcastEpisodesPodcast';
  image_url?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
};

export type Devto_Listing = {
  __typename?: 'Devto_Listing';
  body_markdown: Scalars['String'];
  category: Scalars['String'];
  id: Scalars['Int'];
  organization?: Maybe<Devto_SharedOrganization>;
  processed_html: Scalars['String'];
  published: Scalars['Boolean'];
  slug: Scalars['String'];
  tag_list: Scalars['String'];
  tags?: Maybe<Scalars['JSON']>;
  title: Scalars['String'];
  type_of: Scalars['String'];
  user: Devto_SharedUser;
};

/** Profile image */
export type Devto_ProfileImage = {
  __typename?: 'Devto_ProfileImage';
  image_of?: Maybe<Scalars['String']>;
  profile_image?: Maybe<Scalars['String']>;
  profile_image_90?: Maybe<Scalars['String']>;
  type_of?: Maybe<Scalars['String']>;
};

/** The organization the resource belongs to */
export type Devto_SharedOrganization = {
  __typename?: 'Devto_SharedOrganization';
  name?: Maybe<Scalars['String']>;
  profile_image?: Maybe<Scalars['String']>;
  profile_image_90?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
};

/** The resource creator */
export type Devto_SharedUser = {
  __typename?: 'Devto_SharedUser';
  github_username?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  profile_image?: Maybe<Scalars['String']>;
  profile_image_90?: Maybe<Scalars['String']>;
  twitter_username?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
  website_url?: Maybe<Scalars['String']>;
};

/** Webhook */
export type Devto_WebhookShow = {
  __typename?: 'Devto_WebhookShow';
  created_at?: Maybe<Scalars['String']>;
  events?: Maybe<Scalars['JSON']>;
  id?: Maybe<Scalars['Int']>;
  source?: Maybe<Scalars['String']>;
  target_url?: Maybe<Scalars['String']>;
  type_of?: Maybe<Scalars['String']>;
  user?: Maybe<Devto_SharedUser>;
};

export type Devto_GetArticlesResponse = {
  __typename?: 'Devto_getArticlesResponse';
  canonical_url: Scalars['String'];
  comments_count: Scalars['Int'];
  cover_image: Scalars['String'];
  created_at: Scalars['String'];
  crossposted_at: Scalars['String'];
  description: Scalars['String'];
  edited_at: Scalars['String'];
  flare_tag?: Maybe<Devto_ArticleFlareTag>;
  id: Scalars['Int'];
  last_comment_at: Scalars['String'];
  organization?: Maybe<Devto_SharedOrganization>;
  path: Scalars['String'];
  positive_reactions_count: Scalars['Int'];
  public_reactions_count: Scalars['Int'];
  published_at: Scalars['String'];
  published_timestamp: Scalars['String'];
  readable_publish_date: Scalars['String'];
  reading_time_minutes: Scalars['Int'];
  slug: Scalars['String'];
  social_image: Scalars['String'];
  tag_list?: Maybe<Scalars['JSON']>;
  tags: Scalars['String'];
  title: Scalars['String'];
  type_of: Scalars['String'];
  url: Scalars['String'];
  user: Devto_DevToUser;
};

export type Devto_GetArticlesWithVideoResponse = {
  __typename?: 'Devto_getArticlesWithVideoResponse';
  cloudinary_video_url: Scalars['String'];
  id: Scalars['Int'];
  path: Scalars['String'];
  title: Scalars['String'];
  type_of: Scalars['String'];
  user: Devto_GetArticlesWithVideoUser;
  user_id: Scalars['Int'];
  video_duration_in_minutes: Scalars['String'];
  video_source_url: Scalars['String'];
};

export type Devto_GetCommentsByArticleIdResponse = {
  __typename?: 'Devto_getCommentsByArticleIdResponse';
  body_html: Scalars['String'];
  children?: Maybe<Array<Devto_DevToComment>>;
  created_at: Scalars['String'];
  id_code: Scalars['String'];
  type_of: Scalars['String'];
  user: Devto_SharedUser;
};

export type Devto_GetFollowedTagsResponse = {
  __typename?: 'Devto_getFollowedTagsResponse';
  id: Scalars['Int'];
  name: Scalars['String'];
  points: Scalars['Float'];
};

export type Devto_GetFollowersResponse = {
  __typename?: 'Devto_getFollowersResponse';
  created_at: Scalars['String'];
  id: Scalars['Int'];
  name: Scalars['String'];
  path: Scalars['String'];
  profile_image: Scalars['String'];
  type_of: Scalars['String'];
  username: Scalars['String'];
};

export type Devto_GetLatestArticlesResponse = {
  __typename?: 'Devto_getLatestArticlesResponse';
  canonical_url: Scalars['String'];
  comments_count: Scalars['Int'];
  cover_image: Scalars['String'];
  created_at: Scalars['String'];
  crossposted_at: Scalars['String'];
  description: Scalars['String'];
  edited_at: Scalars['String'];
  flare_tag?: Maybe<Devto_ArticleFlareTag>;
  id: Scalars['Int'];
  last_comment_at: Scalars['String'];
  organization?: Maybe<Devto_SharedOrganization>;
  path: Scalars['String'];
  positive_reactions_count: Scalars['Int'];
  public_reactions_count: Scalars['Int'];
  published_at: Scalars['String'];
  published_timestamp: Scalars['String'];
  readable_publish_date: Scalars['String'];
  reading_time_minutes: Scalars['Int'];
  slug: Scalars['String'];
  social_image: Scalars['String'];
  tag_list?: Maybe<Scalars['JSON']>;
  tags: Scalars['String'];
  title: Scalars['String'];
  type_of: Scalars['String'];
  url: Scalars['String'];
  user: Devto_SharedUser;
};

export type Devto_GetListingsByCategoryResponse = {
  __typename?: 'Devto_getListingsByCategoryResponse';
  body_markdown: Scalars['String'];
  category: Scalars['String'];
  id: Scalars['Int'];
  organization?: Maybe<Devto_SharedOrganization>;
  processed_html: Scalars['String'];
  published: Scalars['Boolean'];
  slug: Scalars['String'];
  tag_list: Scalars['String'];
  tags?: Maybe<Scalars['JSON']>;
  title: Scalars['String'];
  type_of: Scalars['String'];
  user: Devto_SharedUser;
};

export type Devto_GetListingsResponse = {
  __typename?: 'Devto_getListingsResponse';
  body_markdown: Scalars['String'];
  category: Scalars['String'];
  id: Scalars['Int'];
  organization?: Maybe<Devto_SharedOrganization>;
  processed_html: Scalars['String'];
  published: Scalars['Boolean'];
  slug: Scalars['String'];
  tag_list: Scalars['String'];
  tags?: Maybe<Scalars['JSON']>;
  title: Scalars['String'];
  type_of: Scalars['String'];
  user: Devto_SharedUser;
};

export type Devto_GetOrgArticlesResponse = {
  __typename?: 'Devto_getOrgArticlesResponse';
  canonical_url: Scalars['String'];
  comments_count: Scalars['Int'];
  cover_image: Scalars['String'];
  created_at: Scalars['String'];
  crossposted_at: Scalars['String'];
  description: Scalars['String'];
  edited_at: Scalars['String'];
  flare_tag?: Maybe<Devto_ArticleFlareTag>;
  id: Scalars['Int'];
  last_comment_at: Scalars['String'];
  organization?: Maybe<Devto_SharedOrganization>;
  path: Scalars['String'];
  positive_reactions_count: Scalars['Int'];
  public_reactions_count: Scalars['Int'];
  published_at: Scalars['String'];
  published_timestamp: Scalars['String'];
  readable_publish_date: Scalars['String'];
  reading_time_minutes: Scalars['Int'];
  slug: Scalars['String'];
  social_image: Scalars['String'];
  tag_list?: Maybe<Scalars['JSON']>;
  tags: Scalars['String'];
  title: Scalars['String'];
  type_of: Scalars['String'];
  url: Scalars['String'];
  user: Devto_SharedUser;
};

export type Devto_GetOrgListingsResponse = {
  __typename?: 'Devto_getOrgListingsResponse';
  body_markdown: Scalars['String'];
  category: Scalars['String'];
  id: Scalars['Int'];
  organization?: Maybe<Devto_SharedOrganization>;
  processed_html: Scalars['String'];
  published: Scalars['Boolean'];
  slug: Scalars['String'];
  tag_list: Scalars['String'];
  tags?: Maybe<Scalars['JSON']>;
  title: Scalars['String'];
  type_of: Scalars['String'];
  user: Devto_SharedUser;
};

export type Devto_GetOrgUsersResponse = {
  __typename?: 'Devto_getOrgUsersResponse';
  github_username: Scalars['String'];
  id: Scalars['Int'];
  joined_at: Scalars['String'];
  location: Scalars['String'];
  name: Scalars['String'];
  profile_image: Scalars['String'];
  summary: Scalars['String'];
  twitter_username: Scalars['String'];
  type_of: Scalars['String'];
  username: Scalars['String'];
  website_url: Scalars['String'];
};

export type Devto_GetPodcastEpisodesResponse = {
  __typename?: 'Devto_getPodcastEpisodesResponse';
  id: Scalars['Int'];
  image_url: Scalars['String'];
  path: Scalars['String'];
  podcast: Devto_GetPodcastEpisodesPodcast;
  title: Scalars['String'];
  type_of: Scalars['String'];
};

export type Devto_GetReadinglistResponse = {
  __typename?: 'Devto_getReadinglistResponse';
  article: Devto_ArticleIndex;
  created_at: Scalars['String'];
  id: Scalars['Int'];
  status: Scalars['String'];
  type_of: Scalars['String'];
};

export type Devto_GetTagsResponse = {
  __typename?: 'Devto_getTagsResponse';
  bg_color_hex: Scalars['String'];
  id: Scalars['Int'];
  name: Scalars['String'];
  text_color_hex: Scalars['String'];
};

export type Devto_GetUserAllArticlesResponse = {
  __typename?: 'Devto_getUserAllArticlesResponse';
  body_markdown: Scalars['String'];
  canonical_url: Scalars['String'];
  comments_count: Scalars['Int'];
  cover_image: Scalars['String'];
  description: Scalars['String'];
  flare_tag?: Maybe<Devto_ArticleFlareTag>;
  id: Scalars['Int'];
  organization?: Maybe<Devto_SharedOrganization>;
  page_views_count: Scalars['Int'];
  path: Scalars['String'];
  positive_reactions_count: Scalars['Int'];
  public_reactions_count: Scalars['Int'];
  published: Scalars['Boolean'];
  published_at: Scalars['String'];
  published_timestamp: Scalars['String'];
  reading_time_minutes: Scalars['Int'];
  slug: Scalars['String'];
  tag_list?: Maybe<Scalars['JSON']>;
  title: Scalars['String'];
  type_of: Scalars['String'];
  url: Scalars['String'];
  user: Devto_SharedUser;
};

export type Devto_GetUserArticlesResponse = {
  __typename?: 'Devto_getUserArticlesResponse';
  body_markdown: Scalars['String'];
  canonical_url: Scalars['String'];
  comments_count: Scalars['Int'];
  cover_image: Scalars['String'];
  description: Scalars['String'];
  flare_tag?: Maybe<Devto_ArticleFlareTag>;
  id: Scalars['Int'];
  organization?: Maybe<Devto_SharedOrganization>;
  page_views_count: Scalars['Int'];
  path: Scalars['String'];
  positive_reactions_count: Scalars['Int'];
  public_reactions_count: Scalars['Int'];
  published: Scalars['Boolean'];
  published_at: Scalars['String'];
  published_timestamp: Scalars['String'];
  reading_time_minutes: Scalars['Int'];
  slug: Scalars['String'];
  tag_list?: Maybe<Scalars['JSON']>;
  title: Scalars['String'];
  type_of: Scalars['String'];
  url: Scalars['String'];
  user: Devto_SharedUser;
};

export type Devto_GetUserPublishedArticlesResponse = {
  __typename?: 'Devto_getUserPublishedArticlesResponse';
  body_markdown: Scalars['String'];
  canonical_url: Scalars['String'];
  comments_count: Scalars['Int'];
  cover_image: Scalars['String'];
  description: Scalars['String'];
  flare_tag?: Maybe<Devto_ArticleFlareTag>;
  id: Scalars['Int'];
  organization?: Maybe<Devto_SharedOrganization>;
  page_views_count: Scalars['Int'];
  path: Scalars['String'];
  positive_reactions_count: Scalars['Int'];
  public_reactions_count: Scalars['Int'];
  published: Scalars['Boolean'];
  published_at: Scalars['String'];
  published_timestamp: Scalars['String'];
  reading_time_minutes: Scalars['Int'];
  slug: Scalars['String'];
  tag_list?: Maybe<Scalars['JSON']>;
  title: Scalars['String'];
  type_of: Scalars['String'];
  url: Scalars['String'];
  user: Devto_SharedUser;
};

export type Devto_GetUserUnpublishedArticlesResponse = {
  __typename?: 'Devto_getUserUnpublishedArticlesResponse';
  body_markdown: Scalars['String'];
  canonical_url: Scalars['String'];
  comments_count: Scalars['Int'];
  cover_image: Scalars['String'];
  description: Scalars['String'];
  flare_tag?: Maybe<Devto_ArticleFlareTag>;
  id: Scalars['Int'];
  organization?: Maybe<Devto_SharedOrganization>;
  page_views_count: Scalars['Int'];
  path: Scalars['String'];
  positive_reactions_count: Scalars['Int'];
  public_reactions_count: Scalars['Int'];
  published: Scalars['Boolean'];
  published_at: Scalars['String'];
  published_timestamp: Scalars['String'];
  reading_time_minutes: Scalars['Int'];
  slug: Scalars['String'];
  tag_list?: Maybe<Scalars['JSON']>;
  title: Scalars['String'];
  type_of: Scalars['String'];
  url: Scalars['String'];
  user: Devto_SharedUser;
};

export type Devto_GetWebhooksResponse = {
  __typename?: 'Devto_getWebhooksResponse';
  created_at?: Maybe<Scalars['String']>;
  events?: Maybe<Scalars['JSON']>;
  id?: Maybe<Scalars['Int']>;
  source?: Maybe<Scalars['String']>;
  target_url?: Maybe<Scalars['String']>;
  type_of?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of AcceptEnterpriseAdministratorInvitation */
export type Github_AcceptEnterpriseAdministratorInvitationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The id of the invitation being accepted */
  invitationId: Scalars['ID'];
};

/** Autogenerated return type of AcceptEnterpriseAdministratorInvitation */
export type Github_AcceptEnterpriseAdministratorInvitationPayload = {
  __typename?: 'Github_AcceptEnterpriseAdministratorInvitationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The invitation that was accepted. */
  invitation?: Maybe<Github_EnterpriseAdministratorInvitation>;
  /** A message confirming the result of accepting an administrator invitation. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of AcceptTopicSuggestion */
export type Github_AcceptTopicSuggestionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The name of the suggested topic. */
  name: Scalars['String'];
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of AcceptTopicSuggestion */
export type Github_AcceptTopicSuggestionPayload = {
  __typename?: 'Github_AcceptTopicSuggestionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The accepted topic. */
  topic?: Maybe<Github_Topic>;
};

/** Represents an object which can take actions on GitHub. Typically a User or Bot. */
export type Github_Actor = {
  /** A URL pointing to the actor's public avatar. */
  avatarUrl: Scalars['Github_URI'];
  /** The username of the actor. */
  login: Scalars['String'];
  /** The HTTP path for this actor. */
  resourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this actor. */
  url: Scalars['Github_URI'];
};


/** Represents an object which can take actions on GitHub. Typically a User or Bot. */
export type Github_ActorAvatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']>;
};

/** Location information for an actor */
export type Github_ActorLocation = {
  __typename?: 'Github_ActorLocation';
  /** City */
  city?: Maybe<Scalars['String']>;
  /** Country name */
  country?: Maybe<Scalars['String']>;
  /** Country code */
  countryCode?: Maybe<Scalars['String']>;
  /** Region name */
  region?: Maybe<Scalars['String']>;
  /** Region or state code */
  regionCode?: Maybe<Scalars['String']>;
};

/** Github_Actor mock concrete type. */
export type Github_Actor__Mock = Github_Actor & {
  __typename?: 'Github_Actor__Mock';
  /** A URL pointing to the actor's public avatar. */
  avatarUrl: Scalars['Github_URI'];
  /** The username of the actor. */
  login: Scalars['String'];
  /** The HTTP path for this actor. */
  resourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this actor. */
  url: Scalars['Github_URI'];
};


/** Github_Actor mock concrete type. */
export type Github_Actor__MockAvatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated input type of AddAssigneesToAssignable */
export type Github_AddAssigneesToAssignableInput = {
  /** The id of the assignable object to add assignees to. */
  assignableId: Scalars['ID'];
  /** The id of users to add as assignees. */
  assigneeIds: Array<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of AddAssigneesToAssignable */
export type Github_AddAssigneesToAssignablePayload = {
  __typename?: 'Github_AddAssigneesToAssignablePayload';
  /** The item that was assigned. */
  assignable?: Maybe<Github_Assignable>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of AddComment */
export type Github_AddCommentInput = {
  /** The contents of the comment. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID'];
};

/** Autogenerated return type of AddComment */
export type Github_AddCommentPayload = {
  __typename?: 'Github_AddCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The edge from the subject's comment connection. */
  commentEdge?: Maybe<Github_IssueCommentEdge>;
  /** The subject */
  subject?: Maybe<Github_Node>;
  /** The edge from the subject's timeline connection. */
  timelineEdge?: Maybe<Github_IssueTimelineItemEdge>;
};

/** Autogenerated input type of AddDiscussionComment */
export type Github_AddDiscussionCommentInput = {
  /** The contents of the comment. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the discussion to comment on. */
  discussionId: Scalars['ID'];
  /** The Node ID of the discussion comment within this discussion to reply to. */
  replyToId?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated return type of AddDiscussionComment */
export type Github_AddDiscussionCommentPayload = {
  __typename?: 'Github_AddDiscussionCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The newly created discussion comment. */
  comment?: Maybe<Github_DiscussionComment>;
};

/** Autogenerated input type of AddEnterpriseSupportEntitlement */
export type Github_AddEnterpriseSupportEntitlementInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the Enterprise which the admin belongs to. */
  enterpriseId: Scalars['ID'];
  /** The login of a member who will receive the support entitlement. */
  login: Scalars['String'];
};

/** Autogenerated return type of AddEnterpriseSupportEntitlement */
export type Github_AddEnterpriseSupportEntitlementPayload = {
  __typename?: 'Github_AddEnterpriseSupportEntitlementPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A message confirming the result of adding the support entitlement. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of AddLabelsToLabelable */
export type Github_AddLabelsToLabelableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ids of the labels to add. */
  labelIds: Array<Scalars['ID']>;
  /** The id of the labelable object to add labels to. */
  labelableId: Scalars['ID'];
};

/** Autogenerated return type of AddLabelsToLabelable */
export type Github_AddLabelsToLabelablePayload = {
  __typename?: 'Github_AddLabelsToLabelablePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The item that was labeled. */
  labelable?: Maybe<Github_Labelable>;
};

/** Autogenerated input type of AddProjectCard */
export type Github_AddProjectCardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The content of the card. Must be a member of the ProjectCardItem union */
  contentId?: InputMaybe<Scalars['ID']>;
  /** The note on the card. */
  note?: InputMaybe<Scalars['String']>;
  /** The Node ID of the ProjectColumn. */
  projectColumnId: Scalars['ID'];
};

/** Autogenerated return type of AddProjectCard */
export type Github_AddProjectCardPayload = {
  __typename?: 'Github_AddProjectCardPayload';
  /** The edge from the ProjectColumn's card connection. */
  cardEdge?: Maybe<Github_ProjectCardEdge>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ProjectColumn */
  projectColumn?: Maybe<Github_ProjectColumn>;
};

/** Autogenerated input type of AddProjectColumn */
export type Github_AddProjectColumnInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The name of the column. */
  name: Scalars['String'];
  /** The Node ID of the project. */
  projectId: Scalars['ID'];
};

/** Autogenerated return type of AddProjectColumn */
export type Github_AddProjectColumnPayload = {
  __typename?: 'Github_AddProjectColumnPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The edge from the project's column connection. */
  columnEdge?: Maybe<Github_ProjectColumnEdge>;
  /** The project */
  project?: Maybe<Github_Project>;
};

/** Autogenerated input type of AddProjectNextItem */
export type Github_AddProjectNextItemInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The content id of the item (Issue or PullRequest). */
  contentId: Scalars['ID'];
  /** The ID of the Project to add the item to. */
  projectId: Scalars['ID'];
};

/** Autogenerated return type of AddProjectNextItem */
export type Github_AddProjectNextItemPayload = {
  __typename?: 'Github_AddProjectNextItemPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The item added to the project. */
  projectNextItem?: Maybe<Github_ProjectNextItem>;
};

/** Autogenerated input type of AddPullRequestReviewComment */
export type Github_AddPullRequestReviewCommentInput = {
  /** The text of the comment. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The SHA of the commit to comment on. */
  commitOID?: InputMaybe<Scalars['Github_GitObjectID']>;
  /** The comment id to reply to. */
  inReplyTo?: InputMaybe<Scalars['ID']>;
  /** The relative path of the file to comment on. */
  path?: InputMaybe<Scalars['String']>;
  /** The line index in the diff to comment on. */
  position?: InputMaybe<Scalars['Int']>;
  /** The node ID of the pull request reviewing */
  pullRequestId?: InputMaybe<Scalars['ID']>;
  /** The Node ID of the review to modify. */
  pullRequestReviewId?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated return type of AddPullRequestReviewComment */
export type Github_AddPullRequestReviewCommentPayload = {
  __typename?: 'Github_AddPullRequestReviewCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The newly created comment. */
  comment?: Maybe<Github_PullRequestReviewComment>;
  /** The edge from the review's comment connection. */
  commentEdge?: Maybe<Github_PullRequestReviewCommentEdge>;
};

/** Autogenerated input type of AddPullRequestReview */
export type Github_AddPullRequestReviewInput = {
  /** The contents of the review body comment. */
  body?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The review line comments. */
  comments?: InputMaybe<Array<InputMaybe<Github_DraftPullRequestReviewComment>>>;
  /** The commit OID the review pertains to. */
  commitOID?: InputMaybe<Scalars['Github_GitObjectID']>;
  /** The event to perform on the pull request review. */
  event?: InputMaybe<Github_PullRequestReviewEvent>;
  /** The Node ID of the pull request to modify. */
  pullRequestId: Scalars['ID'];
  /** The review line comment threads. */
  threads?: InputMaybe<Array<InputMaybe<Github_DraftPullRequestReviewThread>>>;
};

/** Autogenerated return type of AddPullRequestReview */
export type Github_AddPullRequestReviewPayload = {
  __typename?: 'Github_AddPullRequestReviewPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The newly created pull request review. */
  pullRequestReview?: Maybe<Github_PullRequestReview>;
  /** The edge from the pull request's review connection. */
  reviewEdge?: Maybe<Github_PullRequestReviewEdge>;
};

/** Autogenerated input type of AddPullRequestReviewThread */
export type Github_AddPullRequestReviewThreadInput = {
  /** Body of the thread's first comment. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The line of the blob to which the thread refers. The end of the line range for multi-line comments. */
  line: Scalars['Int'];
  /** Path to the file being commented on. */
  path: Scalars['String'];
  /** The node ID of the pull request reviewing */
  pullRequestId?: InputMaybe<Scalars['ID']>;
  /** The Node ID of the review to modify. */
  pullRequestReviewId?: InputMaybe<Scalars['ID']>;
  /** The side of the diff on which the line resides. For multi-line comments, this is the side for the end of the line range. */
  side?: InputMaybe<Github_DiffSide>;
  /** The first line of the range to which the comment refers. */
  startLine?: InputMaybe<Scalars['Int']>;
  /** The side of the diff on which the start line resides. */
  startSide?: InputMaybe<Github_DiffSide>;
};

/** Autogenerated return type of AddPullRequestReviewThread */
export type Github_AddPullRequestReviewThreadPayload = {
  __typename?: 'Github_AddPullRequestReviewThreadPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The newly created thread. */
  thread?: Maybe<Github_PullRequestReviewThread>;
};

/** Autogenerated input type of AddReaction */
export type Github_AddReactionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The name of the emoji to react with. */
  content: Github_ReactionContent;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID'];
};

/** Autogenerated return type of AddReaction */
export type Github_AddReactionPayload = {
  __typename?: 'Github_AddReactionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The reaction object. */
  reaction?: Maybe<Github_Reaction>;
  /** The reactable subject. */
  subject?: Maybe<Github_Reactable>;
};

/** Autogenerated input type of AddStar */
export type Github_AddStarInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Starrable ID to star. */
  starrableId: Scalars['ID'];
};

/** Autogenerated return type of AddStar */
export type Github_AddStarPayload = {
  __typename?: 'Github_AddStarPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The starrable. */
  starrable?: Maybe<Github_Starrable>;
};

/** Autogenerated input type of AddUpvote */
export type Github_AddUpvoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the discussion or comment to upvote. */
  subjectId: Scalars['ID'];
};

/** Autogenerated return type of AddUpvote */
export type Github_AddUpvotePayload = {
  __typename?: 'Github_AddUpvotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The votable subject. */
  subject?: Maybe<Github_Votable>;
};

/** Autogenerated input type of AddVerifiableDomain */
export type Github_AddVerifiableDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The URL of the domain */
  domain: Scalars['Github_URI'];
  /** The ID of the owner to add the domain to */
  ownerId: Scalars['ID'];
};

/** Autogenerated return type of AddVerifiableDomain */
export type Github_AddVerifiableDomainPayload = {
  __typename?: 'Github_AddVerifiableDomainPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The verifiable domain that was added. */
  domain?: Maybe<Github_VerifiableDomain>;
};

/** Represents a 'added_to_project' event on a given issue or pull request. */
export type Github_AddedToProjectEvent = Github_Node & {
  __typename?: 'Github_AddedToProjectEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** Project referenced by event. */
  project?: Maybe<Github_Project>;
  /** Project card referenced by this project event. */
  projectCard?: Maybe<Github_ProjectCard>;
  /** Column name referenced by this project event. */
  projectColumnName: Scalars['String'];
};

/** A GitHub App. */
export type Github_App = Github_Node & {
  __typename?: 'Github_App';
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The description of the app. */
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The IP addresses of the app. */
  ipAllowListEntries: Github_IpAllowListEntryConnection;
  /** The hex color code, without the leading '#', for the logo background. */
  logoBackgroundColor: Scalars['String'];
  /** A URL pointing to the app's logo. */
  logoUrl: Scalars['Github_URI'];
  /** The name of the app. */
  name: Scalars['String'];
  /** A slug based on the name of the app for use in URLs. */
  slug: Scalars['String'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The URL to the app's homepage. */
  url: Scalars['Github_URI'];
};


/** A GitHub App. */
export type Github_AppIpAllowListEntriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_IpAllowListEntryOrder>;
};


/** A GitHub App. */
export type Github_AppLogoUrlArgs = {
  size?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated input type of ApproveDeployments */
export type Github_ApproveDeploymentsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Optional comment for approving deployments */
  comment?: InputMaybe<Scalars['String']>;
  /** The ids of environments to reject deployments */
  environmentIds: Array<Scalars['ID']>;
  /** The node ID of the workflow run containing the pending deployments. */
  workflowRunId: Scalars['ID'];
};

/** Autogenerated return type of ApproveDeployments */
export type Github_ApproveDeploymentsPayload = {
  __typename?: 'Github_ApproveDeploymentsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The affected deployments. */
  deployments?: Maybe<Array<Github_Deployment>>;
};

/** Autogenerated input type of ApproveVerifiableDomain */
export type Github_ApproveVerifiableDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the verifiable domain to approve. */
  id: Scalars['ID'];
};

/** Autogenerated return type of ApproveVerifiableDomain */
export type Github_ApproveVerifiableDomainPayload = {
  __typename?: 'Github_ApproveVerifiableDomainPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The verifiable domain that was approved. */
  domain?: Maybe<Github_VerifiableDomain>;
};

/** Autogenerated input type of ArchiveRepository */
export type Github_ArchiveRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the repository to mark as archived. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of ArchiveRepository */
export type Github_ArchiveRepositoryPayload = {
  __typename?: 'Github_ArchiveRepositoryPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The repository that was marked as archived. */
  repository?: Maybe<Github_Repository>;
};

/** An object that can have users assigned to it. */
export type Github_Assignable = {
  /** A list of Users assigned to this object. */
  assignees: Github_UserConnection;
};


/** An object that can have users assigned to it. */
export type Github_AssignableAssigneesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Github_Assignable mock concrete type. */
export type Github_Assignable__Mock = Github_Assignable & {
  __typename?: 'Github_Assignable__Mock';
  /** A list of Users assigned to this object. */
  assignees: Github_UserConnection;
};


/** Github_Assignable mock concrete type. */
export type Github_Assignable__MockAssigneesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Represents an 'assigned' event on any assignable object. */
export type Github_AssignedEvent = Github_Node & {
  __typename?: 'Github_AssignedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the assignable associated with the event. */
  assignable: Github_Assignable;
  /** Identifies the user or mannequin that was assigned. */
  assignee?: Maybe<Github_Assignee>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /**
   * Identifies the user who was assigned.
   * @deprecated Assignees can now be mannequins. Use the `assignee` field instead. Removal on 2020-01-01 UTC.
   */
  user?: Maybe<Github_User>;
};

/** Types that can be assigned to issues. */
export type Github_Assignee = Github_Bot | Github_Mannequin | Github_Organization | Github_User;

/** An entry in the audit log. */
export type Github_AuditEntry = {
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Types that can initiate an audit log event. */
export type Github_AuditEntryActor = Github_Bot | Github_Organization | Github_User;

/** Github_AuditEntry mock concrete type. */
export type Github_AuditEntry__Mock = Github_AuditEntry & {
  __typename?: 'Github_AuditEntry__Mock';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Ordering options for Audit Log connections. */
export type Github_AuditLogOrder = {
  /** The ordering direction. */
  direction?: InputMaybe<Github_OrderDirection>;
  /** The field to order Audit Logs by. */
  field?: InputMaybe<Github_AuditLogOrderField>;
};

/** Properties by which Audit Log connections can be ordered. */
export enum Github_AuditLogOrderField {
  /** Order audit log entries by timestamp */
  CreatedAt = 'CREATED_AT'
}

/** Represents a 'auto_merge_disabled' event on a given pull request. */
export type Github_AutoMergeDisabledEvent = Github_Node & {
  __typename?: 'Github_AutoMergeDisabledEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The user who disabled auto-merge for this Pull Request */
  disabler?: Maybe<Github_User>;
  id: Scalars['ID'];
  /** PullRequest referenced by event */
  pullRequest?: Maybe<Github_PullRequest>;
  /** The reason auto-merge was disabled */
  reason?: Maybe<Scalars['String']>;
  /** The reason_code relating to why auto-merge was disabled */
  reasonCode?: Maybe<Scalars['String']>;
};

/** Represents a 'auto_merge_enabled' event on a given pull request. */
export type Github_AutoMergeEnabledEvent = Github_Node & {
  __typename?: 'Github_AutoMergeEnabledEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The user who enabled auto-merge for this Pull Request */
  enabler?: Maybe<Github_User>;
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest?: Maybe<Github_PullRequest>;
};

/** Represents an auto-merge request for a pull request */
export type Github_AutoMergeRequest = {
  __typename?: 'Github_AutoMergeRequest';
  /** The email address of the author of this auto-merge request. */
  authorEmail?: Maybe<Scalars['String']>;
  /** The commit message of the auto-merge request. */
  commitBody?: Maybe<Scalars['String']>;
  /** The commit title of the auto-merge request. */
  commitHeadline?: Maybe<Scalars['String']>;
  /** When was this auto-merge request was enabled. */
  enabledAt?: Maybe<Scalars['DateTime']>;
  /** The actor who created the auto-merge request. */
  enabledBy?: Maybe<Github_Actor>;
  /** The merge method of the auto-merge request. */
  mergeMethod: Github_PullRequestMergeMethod;
  /** The pull request that this auto-merge request is set against. */
  pullRequest: Github_PullRequest;
};

/** Represents a 'auto_rebase_enabled' event on a given pull request. */
export type Github_AutoRebaseEnabledEvent = Github_Node & {
  __typename?: 'Github_AutoRebaseEnabledEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The user who enabled auto-merge (rebase) for this Pull Request */
  enabler?: Maybe<Github_User>;
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest?: Maybe<Github_PullRequest>;
};

/** Represents a 'auto_squash_enabled' event on a given pull request. */
export type Github_AutoSquashEnabledEvent = Github_Node & {
  __typename?: 'Github_AutoSquashEnabledEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The user who enabled auto-merge (squash) for this Pull Request */
  enabler?: Maybe<Github_User>;
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest?: Maybe<Github_PullRequest>;
};

/** Represents a 'automatic_base_change_failed' event on a given pull request. */
export type Github_AutomaticBaseChangeFailedEvent = Github_Node & {
  __typename?: 'Github_AutomaticBaseChangeFailedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** The new base for this PR */
  newBase: Scalars['String'];
  /** The old base for this PR */
  oldBase: Scalars['String'];
  /** PullRequest referenced by event. */
  pullRequest: Github_PullRequest;
};

/** Represents a 'automatic_base_change_succeeded' event on a given pull request. */
export type Github_AutomaticBaseChangeSucceededEvent = Github_Node & {
  __typename?: 'Github_AutomaticBaseChangeSucceededEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** The new base for this PR */
  newBase: Scalars['String'];
  /** The old base for this PR */
  oldBase: Scalars['String'];
  /** PullRequest referenced by event. */
  pullRequest: Github_PullRequest;
};

/** Represents a 'base_ref_changed' event on a given issue or pull request. */
export type Github_BaseRefChangedEvent = Github_Node & {
  __typename?: 'Github_BaseRefChangedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the name of the base ref for the pull request after it was changed. */
  currentRefName: Scalars['String'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** Identifies the name of the base ref for the pull request before it was changed. */
  previousRefName: Scalars['String'];
  /** PullRequest referenced by event. */
  pullRequest: Github_PullRequest;
};

/** Represents a 'base_ref_deleted' event on a given pull request. */
export type Github_BaseRefDeletedEvent = Github_Node & {
  __typename?: 'Github_BaseRefDeletedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the name of the Ref associated with the `base_ref_deleted` event. */
  baseRefName?: Maybe<Scalars['String']>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest?: Maybe<Github_PullRequest>;
};

/** Represents a 'base_ref_force_pushed' event on a given pull request. */
export type Github_BaseRefForcePushedEvent = Github_Node & {
  __typename?: 'Github_BaseRefForcePushedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the after commit SHA for the 'base_ref_force_pushed' event. */
  afterCommit?: Maybe<Github_Commit>;
  /** Identifies the before commit SHA for the 'base_ref_force_pushed' event. */
  beforeCommit?: Maybe<Github_Commit>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest: Github_PullRequest;
  /** Identifies the fully qualified ref name for the 'base_ref_force_pushed' event. */
  ref?: Maybe<Github_Ref>;
};

/** Represents a Git blame. */
export type Github_Blame = {
  __typename?: 'Github_Blame';
  /** The list of ranges from a Git blame. */
  ranges: Array<Github_BlameRange>;
};

/** Represents a range of information from a Git blame. */
export type Github_BlameRange = {
  __typename?: 'Github_BlameRange';
  /**
   * Identifies the recency of the change, from 1 (new) to 10 (old). This is
   * calculated as a 2-quantile and determines the length of distance between the
   * median age of all the changes in the file and the recency of the current
   * range's change.
   */
  age: Scalars['Int'];
  /** Identifies the line author */
  commit: Github_Commit;
  /** The ending line for the range */
  endingLine: Scalars['Int'];
  /** The starting line for the range */
  startingLine: Scalars['Int'];
};

/** Represents a Git blob. */
export type Github_Blob = Github_GitObject & Github_Node & {
  __typename?: 'Github_Blob';
  /** An abbreviated version of the Git object ID */
  abbreviatedOid: Scalars['String'];
  /** Byte size of Blob object */
  byteSize: Scalars['Int'];
  /** The HTTP path for this Git object */
  commitResourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this Git object */
  commitUrl: Scalars['Github_URI'];
  id: Scalars['ID'];
  /** Indicates whether the Blob is binary or text. Returns null if unable to determine the encoding. */
  isBinary?: Maybe<Scalars['Boolean']>;
  /** Indicates whether the contents is truncated */
  isTruncated: Scalars['Boolean'];
  /** The Git object ID */
  oid: Scalars['Github_GitObjectID'];
  /** The Repository the Git object belongs to */
  repository: Github_Repository;
  /** UTF8 text data or null if the Blob is binary */
  text?: Maybe<Scalars['String']>;
};

/** A special type of user which takes actions on behalf of GitHub Apps. */
export type Github_Bot = Github_Actor & Github_Node & Github_UniformResourceLocatable & {
  __typename?: 'Github_Bot';
  /** A URL pointing to the GitHub App's public avatar. */
  avatarUrl: Scalars['Github_URI'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** The username of the actor. */
  login: Scalars['String'];
  /** The HTTP path for this bot */
  resourcePath: Scalars['Github_URI'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this bot */
  url: Scalars['Github_URI'];
};


/** A special type of user which takes actions on behalf of GitHub Apps. */
export type Github_BotAvatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']>;
};

/** Types which can be actors for `BranchActorAllowance` objects. */
export type Github_BranchActorAllowanceActor = Github_Team | Github_User;

/** A branch protection rule. */
export type Github_BranchProtectionRule = Github_Node & {
  __typename?: 'Github_BranchProtectionRule';
  /** Can this branch be deleted. */
  allowsDeletions: Scalars['Boolean'];
  /** Are force pushes allowed on this branch. */
  allowsForcePushes: Scalars['Boolean'];
  /** A list of conflicts matching branches protection rule and other branch protection rules */
  branchProtectionRuleConflicts: Github_BranchProtectionRuleConflictConnection;
  /** A list of actors able to force push for this branch protection rule. */
  bypassForcePushAllowances: Github_BypassForcePushAllowanceConnection;
  /** A list of actors able to bypass PRs for this branch protection rule. */
  bypassPullRequestAllowances: Github_BypassPullRequestAllowanceConnection;
  /** The actor who created this branch protection rule. */
  creator?: Maybe<Github_Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** Will new commits pushed to matching branches dismiss pull request review approvals. */
  dismissesStaleReviews: Scalars['Boolean'];
  id: Scalars['ID'];
  /** Can admins overwrite branch protection. */
  isAdminEnforced: Scalars['Boolean'];
  /** Repository refs that are protected by this rule */
  matchingRefs: Github_RefConnection;
  /** Identifies the protection rule pattern. */
  pattern: Scalars['String'];
  /** A list push allowances for this branch protection rule. */
  pushAllowances: Github_PushAllowanceConnection;
  /** The repository associated with this branch protection rule. */
  repository?: Maybe<Github_Repository>;
  /** Number of approving reviews required to update matching branches. */
  requiredApprovingReviewCount?: Maybe<Scalars['Int']>;
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  requiredStatusCheckContexts?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** List of required status checks that must pass for commits to be accepted to matching branches. */
  requiredStatusChecks?: Maybe<Array<Github_RequiredStatusCheckDescription>>;
  /** Are approving reviews required to update matching branches. */
  requiresApprovingReviews: Scalars['Boolean'];
  /** Are reviews from code owners required to update matching branches. */
  requiresCodeOwnerReviews: Scalars['Boolean'];
  /** Are commits required to be signed. */
  requiresCommitSignatures: Scalars['Boolean'];
  /** Are conversations required to be resolved before merging. */
  requiresConversationResolution: Scalars['Boolean'];
  /** Are merge commits prohibited from being pushed to this branch. */
  requiresLinearHistory: Scalars['Boolean'];
  /** Are status checks required to update matching branches. */
  requiresStatusChecks: Scalars['Boolean'];
  /** Are branches required to be up to date before merging. */
  requiresStrictStatusChecks: Scalars['Boolean'];
  /** Is pushing to matching branches restricted. */
  restrictsPushes: Scalars['Boolean'];
  /** Is dismissal of pull request reviews restricted. */
  restrictsReviewDismissals: Scalars['Boolean'];
  /** A list review dismissal allowances for this branch protection rule. */
  reviewDismissalAllowances: Github_ReviewDismissalAllowanceConnection;
};


/** A branch protection rule. */
export type Github_BranchProtectionRuleBranchProtectionRuleConflictsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A branch protection rule. */
export type Github_BranchProtectionRuleBypassForcePushAllowancesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A branch protection rule. */
export type Github_BranchProtectionRuleBypassPullRequestAllowancesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A branch protection rule. */
export type Github_BranchProtectionRuleMatchingRefsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  query?: InputMaybe<Scalars['String']>;
};


/** A branch protection rule. */
export type Github_BranchProtectionRulePushAllowancesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A branch protection rule. */
export type Github_BranchProtectionRuleReviewDismissalAllowancesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** A conflict between two branch protection rules. */
export type Github_BranchProtectionRuleConflict = {
  __typename?: 'Github_BranchProtectionRuleConflict';
  /** Identifies the branch protection rule. */
  branchProtectionRule?: Maybe<Github_BranchProtectionRule>;
  /** Identifies the conflicting branch protection rule. */
  conflictingBranchProtectionRule?: Maybe<Github_BranchProtectionRule>;
  /** Identifies the branch ref that has conflicting rules */
  ref?: Maybe<Github_Ref>;
};

/** The connection type for BranchProtectionRuleConflict. */
export type Github_BranchProtectionRuleConflictConnection = {
  __typename?: 'Github_BranchProtectionRuleConflictConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_BranchProtectionRuleConflictEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_BranchProtectionRuleConflict>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_BranchProtectionRuleConflictEdge = {
  __typename?: 'Github_BranchProtectionRuleConflictEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_BranchProtectionRuleConflict>;
};

/** The connection type for BranchProtectionRule. */
export type Github_BranchProtectionRuleConnection = {
  __typename?: 'Github_BranchProtectionRuleConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_BranchProtectionRuleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_BranchProtectionRule>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_BranchProtectionRuleEdge = {
  __typename?: 'Github_BranchProtectionRuleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_BranchProtectionRule>;
};

/** A team or user who has the ability to bypass a force push requirement on a protected branch. */
export type Github_BypassForcePushAllowance = Github_Node & {
  __typename?: 'Github_BypassForcePushAllowance';
  /** The actor that can dismiss. */
  actor?: Maybe<Github_BranchActorAllowanceActor>;
  /** Identifies the branch protection rule associated with the allowed user or team. */
  branchProtectionRule?: Maybe<Github_BranchProtectionRule>;
  id: Scalars['ID'];
};

/** The connection type for BypassForcePushAllowance. */
export type Github_BypassForcePushAllowanceConnection = {
  __typename?: 'Github_BypassForcePushAllowanceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_BypassForcePushAllowanceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_BypassForcePushAllowance>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_BypassForcePushAllowanceEdge = {
  __typename?: 'Github_BypassForcePushAllowanceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_BypassForcePushAllowance>;
};

/** A team or user who has the ability to bypass a pull request requirement on a protected branch. */
export type Github_BypassPullRequestAllowance = Github_Node & {
  __typename?: 'Github_BypassPullRequestAllowance';
  /** The actor that can dismiss. */
  actor?: Maybe<Github_BranchActorAllowanceActor>;
  /** Identifies the branch protection rule associated with the allowed user or team. */
  branchProtectionRule?: Maybe<Github_BranchProtectionRule>;
  id: Scalars['ID'];
};

/** The connection type for BypassPullRequestAllowance. */
export type Github_BypassPullRequestAllowanceConnection = {
  __typename?: 'Github_BypassPullRequestAllowanceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_BypassPullRequestAllowanceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_BypassPullRequestAllowance>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_BypassPullRequestAllowanceEdge = {
  __typename?: 'Github_BypassPullRequestAllowanceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_BypassPullRequestAllowance>;
};

/** The Common Vulnerability Scoring System */
export type Github_Cvss = {
  __typename?: 'Github_CVSS';
  /** The CVSS score associated with this advisory */
  score: Scalars['Float'];
  /** The CVSS vector string associated with this advisory */
  vectorString?: Maybe<Scalars['String']>;
};

/** A common weakness enumeration */
export type Github_Cwe = Github_Node & {
  __typename?: 'Github_CWE';
  /** The id of the CWE */
  cweId: Scalars['String'];
  /** A detailed description of this CWE */
  description: Scalars['String'];
  id: Scalars['ID'];
  /** The name of this CWE */
  name: Scalars['String'];
};

/** The connection type for CWE. */
export type Github_CweConnection = {
  __typename?: 'Github_CWEConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_CweEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Cwe>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_CweEdge = {
  __typename?: 'Github_CWEEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Cwe>;
};

/** Autogenerated input type of CancelEnterpriseAdminInvitation */
export type Github_CancelEnterpriseAdminInvitationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the pending enterprise administrator invitation. */
  invitationId: Scalars['ID'];
};

/** Autogenerated return type of CancelEnterpriseAdminInvitation */
export type Github_CancelEnterpriseAdminInvitationPayload = {
  __typename?: 'Github_CancelEnterpriseAdminInvitationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The invitation that was canceled. */
  invitation?: Maybe<Github_EnterpriseAdministratorInvitation>;
  /** A message confirming the result of canceling an administrator invitation. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of CancelSponsorship */
export type Github_CancelSponsorshipInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /**
   * The ID of the user or organization who is acting as the sponsor, paying for
   * the sponsorship. Required if sponsorLogin is not given.
   */
  sponsorId?: InputMaybe<Scalars['ID']>;
  /**
   * The username of the user or organization who is acting as the sponsor, paying
   * for the sponsorship. Required if sponsorId is not given.
   */
  sponsorLogin?: InputMaybe<Scalars['String']>;
  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */
  sponsorableId?: InputMaybe<Scalars['ID']>;
  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */
  sponsorableLogin?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of CancelSponsorship */
export type Github_CancelSponsorshipPayload = {
  __typename?: 'Github_CancelSponsorshipPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The tier that was being used at the time of cancellation. */
  sponsorsTier?: Maybe<Github_SponsorsTier>;
};

/** Autogenerated input type of ChangeUserStatus */
export type Github_ChangeUserStatusInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The emoji to represent your status. Can either be a native Unicode emoji or an emoji name with colons, e.g., :grinning:. */
  emoji?: InputMaybe<Scalars['String']>;
  /** If set, the user status will not be shown after this date. */
  expiresAt?: InputMaybe<Scalars['DateTime']>;
  /** Whether this status should indicate you are not fully available on GitHub, e.g., you are away. */
  limitedAvailability?: InputMaybe<Scalars['Boolean']>;
  /** A short description of your current status. */
  message?: InputMaybe<Scalars['String']>;
  /**
   * The ID of the organization whose members will be allowed to see the status. If
   * omitted, the status will be publicly visible.
   */
  organizationId?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated return type of ChangeUserStatus */
export type Github_ChangeUserStatusPayload = {
  __typename?: 'Github_ChangeUserStatusPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Your updated status. */
  status?: Maybe<Github_UserStatus>;
};

/** A single check annotation. */
export type Github_CheckAnnotation = {
  __typename?: 'Github_CheckAnnotation';
  /** The annotation's severity level. */
  annotationLevel?: Maybe<Github_CheckAnnotationLevel>;
  /** The path to the file that this annotation was made on. */
  blobUrl: Scalars['Github_URI'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The position of this annotation. */
  location: Github_CheckAnnotationSpan;
  /** The annotation's message. */
  message: Scalars['String'];
  /** The path that this annotation was made on. */
  path: Scalars['String'];
  /** Additional information about the annotation. */
  rawDetails?: Maybe<Scalars['String']>;
  /** The annotation's title */
  title?: Maybe<Scalars['String']>;
};

/** The connection type for CheckAnnotation. */
export type Github_CheckAnnotationConnection = {
  __typename?: 'Github_CheckAnnotationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_CheckAnnotationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_CheckAnnotation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Information from a check run analysis to specific lines of code. */
export type Github_CheckAnnotationData = {
  /** Represents an annotation's information level */
  annotationLevel: Github_CheckAnnotationLevel;
  /** The location of the annotation */
  location: Github_CheckAnnotationRange;
  /** A short description of the feedback for these lines of code. */
  message: Scalars['String'];
  /** The path of the file to add an annotation to. */
  path: Scalars['String'];
  /** Details about this annotation. */
  rawDetails?: InputMaybe<Scalars['String']>;
  /** The title that represents the annotation. */
  title?: InputMaybe<Scalars['String']>;
};

/** An edge in a connection. */
export type Github_CheckAnnotationEdge = {
  __typename?: 'Github_CheckAnnotationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_CheckAnnotation>;
};

/** Represents an annotation's information level. */
export enum Github_CheckAnnotationLevel {
  /** An annotation indicating an inescapable error. */
  Failure = 'FAILURE',
  /** An annotation indicating some information. */
  Notice = 'NOTICE',
  /** An annotation indicating an ignorable error. */
  Warning = 'WARNING'
}

/** A character position in a check annotation. */
export type Github_CheckAnnotationPosition = {
  __typename?: 'Github_CheckAnnotationPosition';
  /** Column number (1 indexed). */
  column?: Maybe<Scalars['Int']>;
  /** Line number (1 indexed). */
  line: Scalars['Int'];
};

/** Information from a check run analysis to specific lines of code. */
export type Github_CheckAnnotationRange = {
  /** The ending column of the range. */
  endColumn?: InputMaybe<Scalars['Int']>;
  /** The ending line of the range. */
  endLine: Scalars['Int'];
  /** The starting column of the range. */
  startColumn?: InputMaybe<Scalars['Int']>;
  /** The starting line of the range. */
  startLine: Scalars['Int'];
};

/** An inclusive pair of positions for a check annotation. */
export type Github_CheckAnnotationSpan = {
  __typename?: 'Github_CheckAnnotationSpan';
  /** End position (inclusive). */
  end: Github_CheckAnnotationPosition;
  /** Start position (inclusive). */
  start: Github_CheckAnnotationPosition;
};

/** The possible states for a check suite or run conclusion. */
export enum Github_CheckConclusionState {
  /** The check suite or run requires action. */
  ActionRequired = 'ACTION_REQUIRED',
  /** The check suite or run has been cancelled. */
  Cancelled = 'CANCELLED',
  /** The check suite or run has failed. */
  Failure = 'FAILURE',
  /** The check suite or run was neutral. */
  Neutral = 'NEUTRAL',
  /** The check suite or run was skipped. */
  Skipped = 'SKIPPED',
  /** The check suite or run was marked stale by GitHub. Only GitHub can use this conclusion. */
  Stale = 'STALE',
  /** The check suite or run has failed at startup. */
  StartupFailure = 'STARTUP_FAILURE',
  /** The check suite or run has succeeded. */
  Success = 'SUCCESS',
  /** The check suite or run has timed out. */
  TimedOut = 'TIMED_OUT'
}

/** A check run. */
export type Github_CheckRun = Github_Node & Github_RequirableByPullRequest & Github_UniformResourceLocatable & {
  __typename?: 'Github_CheckRun';
  /** The check run's annotations */
  annotations?: Maybe<Github_CheckAnnotationConnection>;
  /** The check suite that this run is a part of. */
  checkSuite: Github_CheckSuite;
  /** Identifies the date and time when the check run was completed. */
  completedAt?: Maybe<Scalars['DateTime']>;
  /** The conclusion of the check run. */
  conclusion?: Maybe<Github_CheckConclusionState>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The corresponding deployment for this job, if any */
  deployment?: Maybe<Github_Deployment>;
  /** The URL from which to find full details of the check run on the integrator's site. */
  detailsUrl?: Maybe<Scalars['Github_URI']>;
  /** A reference for the check run on the integrator's system. */
  externalId?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** Whether this is required to pass before merging for a specific pull request. */
  isRequired: Scalars['Boolean'];
  /** The name of the check for this check run. */
  name: Scalars['String'];
  /** Information about a pending deployment, if any, in this check run */
  pendingDeploymentRequest?: Maybe<Github_DeploymentRequest>;
  /** The permalink to the check run summary. */
  permalink: Scalars['Github_URI'];
  /** The repository associated with this check run. */
  repository: Github_Repository;
  /** The HTTP path for this check run. */
  resourcePath: Scalars['Github_URI'];
  /** Identifies the date and time when the check run was started. */
  startedAt?: Maybe<Scalars['DateTime']>;
  /** The current status of the check run. */
  status: Github_CheckStatusState;
  /** The check run's steps */
  steps?: Maybe<Github_CheckStepConnection>;
  /** A string representing the check run's summary */
  summary?: Maybe<Scalars['String']>;
  /** A string representing the check run's text */
  text?: Maybe<Scalars['String']>;
  /** A string representing the check run */
  title?: Maybe<Scalars['String']>;
  /** The HTTP URL for this check run. */
  url: Scalars['Github_URI'];
};


/** A check run. */
export type Github_CheckRunAnnotationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A check run. */
export type Github_CheckRunIsRequiredArgs = {
  pullRequestId?: InputMaybe<Scalars['ID']>;
  pullRequestNumber?: InputMaybe<Scalars['Int']>;
};


/** A check run. */
export type Github_CheckRunStepsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  number?: InputMaybe<Scalars['Int']>;
};

/** Possible further actions the integrator can perform. */
export type Github_CheckRunAction = {
  /** A short explanation of what this action would do. */
  description: Scalars['String'];
  /** A reference for the action on the integrator's system. */
  identifier: Scalars['String'];
  /** The text to be displayed on a button in the web UI. */
  label: Scalars['String'];
};

/** The connection type for CheckRun. */
export type Github_CheckRunConnection = {
  __typename?: 'Github_CheckRunConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_CheckRunEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_CheckRun>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_CheckRunEdge = {
  __typename?: 'Github_CheckRunEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_CheckRun>;
};

/** The filters that are available when fetching check runs. */
export type Github_CheckRunFilter = {
  /** Filters the check runs created by this application ID. */
  appId?: InputMaybe<Scalars['Int']>;
  /** Filters the check runs by this name. */
  checkName?: InputMaybe<Scalars['String']>;
  /** Filters the check runs by this type. */
  checkType?: InputMaybe<Github_CheckRunType>;
  /** Filters the check runs by this status. */
  status?: InputMaybe<Github_CheckStatusState>;
};

/** Descriptive details about the check run. */
export type Github_CheckRunOutput = {
  /** The annotations that are made as part of the check run. */
  annotations?: InputMaybe<Array<Github_CheckAnnotationData>>;
  /** Images attached to the check run output displayed in the GitHub pull request UI. */
  images?: InputMaybe<Array<Github_CheckRunOutputImage>>;
  /** The summary of the check run (supports Commonmark). */
  summary: Scalars['String'];
  /** The details of the check run (supports Commonmark). */
  text?: InputMaybe<Scalars['String']>;
  /** A title to provide for this check run. */
  title: Scalars['String'];
};

/** Images attached to the check run output displayed in the GitHub pull request UI. */
export type Github_CheckRunOutputImage = {
  /** The alternative text for the image. */
  alt: Scalars['String'];
  /** A short image description. */
  caption?: InputMaybe<Scalars['String']>;
  /** The full URL of the image. */
  imageUrl: Scalars['Github_URI'];
};

/** The possible types of check runs. */
export enum Github_CheckRunType {
  /** Every check run available. */
  All = 'ALL',
  /** The latest check run. */
  Latest = 'LATEST'
}

/** The possible states for a check suite or run status. */
export enum Github_CheckStatusState {
  /** The check suite or run has been completed. */
  Completed = 'COMPLETED',
  /** The check suite or run is in progress. */
  InProgress = 'IN_PROGRESS',
  /** The check suite or run is in pending state. */
  Pending = 'PENDING',
  /** The check suite or run has been queued. */
  Queued = 'QUEUED',
  /** The check suite or run has been requested. */
  Requested = 'REQUESTED',
  /** The check suite or run is in waiting state. */
  Waiting = 'WAITING'
}

/** A single check step. */
export type Github_CheckStep = {
  __typename?: 'Github_CheckStep';
  /** Identifies the date and time when the check step was completed. */
  completedAt?: Maybe<Scalars['DateTime']>;
  /** The conclusion of the check step. */
  conclusion?: Maybe<Github_CheckConclusionState>;
  /** A reference for the check step on the integrator's system. */
  externalId?: Maybe<Scalars['String']>;
  /** The step's name. */
  name: Scalars['String'];
  /** The index of the step in the list of steps of the parent check run. */
  number: Scalars['Int'];
  /** Number of seconds to completion. */
  secondsToCompletion?: Maybe<Scalars['Int']>;
  /** Identifies the date and time when the check step was started. */
  startedAt?: Maybe<Scalars['DateTime']>;
  /** The current status of the check step. */
  status: Github_CheckStatusState;
};

/** The connection type for CheckStep. */
export type Github_CheckStepConnection = {
  __typename?: 'Github_CheckStepConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_CheckStepEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_CheckStep>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_CheckStepEdge = {
  __typename?: 'Github_CheckStepEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_CheckStep>;
};

/** A check suite. */
export type Github_CheckSuite = Github_Node & {
  __typename?: 'Github_CheckSuite';
  /** The GitHub App which created this check suite. */
  app?: Maybe<Github_App>;
  /** The name of the branch for this check suite. */
  branch?: Maybe<Github_Ref>;
  /** The check runs associated with a check suite. */
  checkRuns?: Maybe<Github_CheckRunConnection>;
  /** The commit for this check suite */
  commit: Github_Commit;
  /** The conclusion of this check suite. */
  conclusion?: Maybe<Github_CheckConclusionState>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The user who triggered the check suite. */
  creator?: Maybe<Github_User>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** A list of open pull requests matching the check suite. */
  matchingPullRequests?: Maybe<Github_PullRequestConnection>;
  /** The push that triggered this check suite. */
  push?: Maybe<Github_Push>;
  /** The repository associated with this check suite. */
  repository: Github_Repository;
  /** The HTTP path for this check suite */
  resourcePath: Scalars['Github_URI'];
  /** The status of this check suite. */
  status: Github_CheckStatusState;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this check suite */
  url: Scalars['Github_URI'];
  /** The workflow run associated with this check suite. */
  workflowRun?: Maybe<Github_WorkflowRun>;
};


/** A check suite. */
export type Github_CheckSuiteCheckRunsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filterBy?: InputMaybe<Github_CheckRunFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A check suite. */
export type Github_CheckSuiteMatchingPullRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  baseRefName?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  headRefName?: InputMaybe<Scalars['String']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_IssueOrder>;
  states?: InputMaybe<Array<Github_PullRequestState>>;
};

/** The auto-trigger preferences that are available for check suites. */
export type Github_CheckSuiteAutoTriggerPreference = {
  /** The node ID of the application that owns the check suite. */
  appId: Scalars['ID'];
  /** Set to `true` to enable automatic creation of CheckSuite events upon pushes to the repository. */
  setting: Scalars['Boolean'];
};

/** The connection type for CheckSuite. */
export type Github_CheckSuiteConnection = {
  __typename?: 'Github_CheckSuiteConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_CheckSuiteEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_CheckSuite>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_CheckSuiteEdge = {
  __typename?: 'Github_CheckSuiteEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_CheckSuite>;
};

/** The filters that are available when fetching check suites. */
export type Github_CheckSuiteFilter = {
  /** Filters the check suites created by this application ID. */
  appId?: InputMaybe<Scalars['Int']>;
  /** Filters the check suites by this name. */
  checkName?: InputMaybe<Scalars['String']>;
};

/** Autogenerated input type of ClearLabelsFromLabelable */
export type Github_ClearLabelsFromLabelableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The id of the labelable object to clear the labels from. */
  labelableId: Scalars['ID'];
};

/** Autogenerated return type of ClearLabelsFromLabelable */
export type Github_ClearLabelsFromLabelablePayload = {
  __typename?: 'Github_ClearLabelsFromLabelablePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The item that was unlabeled. */
  labelable?: Maybe<Github_Labelable>;
};

/** Autogenerated input type of CloneProject */
export type Github_CloneProjectInput = {
  /** The description of the project. */
  body?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Whether or not to clone the source project's workflows. */
  includeWorkflows: Scalars['Boolean'];
  /** The name of the project. */
  name: Scalars['String'];
  /** The visibility of the project, defaults to false (private). */
  public?: InputMaybe<Scalars['Boolean']>;
  /** The source project to clone. */
  sourceId: Scalars['ID'];
  /** The owner ID to create the project under. */
  targetOwnerId: Scalars['ID'];
};

/** Autogenerated return type of CloneProject */
export type Github_CloneProjectPayload = {
  __typename?: 'Github_CloneProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The id of the JobStatus for populating cloned fields. */
  jobStatusId?: Maybe<Scalars['String']>;
  /** The new cloned project. */
  project?: Maybe<Github_Project>;
};

/** Autogenerated input type of CloneTemplateRepository */
export type Github_CloneTemplateRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** A short description of the new repository. */
  description?: InputMaybe<Scalars['String']>;
  /**
   * Whether to copy all branches from the template to the new repository. Defaults
   * to copying only the default branch of the template.
   */
  includeAllBranches?: InputMaybe<Scalars['Boolean']>;
  /** The name of the new repository. */
  name: Scalars['String'];
  /** The ID of the owner for the new repository. */
  ownerId: Scalars['ID'];
  /** The Node ID of the template repository. */
  repositoryId: Scalars['ID'];
  /** Indicates the repository's visibility level. */
  visibility: Github_RepositoryVisibility;
};

/** Autogenerated return type of CloneTemplateRepository */
export type Github_CloneTemplateRepositoryPayload = {
  __typename?: 'Github_CloneTemplateRepositoryPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new repository. */
  repository?: Maybe<Github_Repository>;
};

/** An object that can be closed */
export type Github_Closable = {
  /** `true` if the object is closed (definition of closed may depend on type) */
  closed: Scalars['Boolean'];
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']>;
};

/** Github_Closable mock concrete type. */
export type Github_Closable__Mock = Github_Closable & {
  __typename?: 'Github_Closable__Mock';
  /** `true` if the object is closed (definition of closed may depend on type) */
  closed: Scalars['Boolean'];
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']>;
};

/** Autogenerated input type of CloseIssue */
export type Github_CloseIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the issue to be closed. */
  issueId: Scalars['ID'];
};

/** Autogenerated return type of CloseIssue */
export type Github_CloseIssuePayload = {
  __typename?: 'Github_CloseIssuePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The issue that was closed. */
  issue?: Maybe<Github_Issue>;
};

/** Autogenerated input type of ClosePullRequest */
export type Github_ClosePullRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the pull request to be closed. */
  pullRequestId: Scalars['ID'];
};

/** Autogenerated return type of ClosePullRequest */
export type Github_ClosePullRequestPayload = {
  __typename?: 'Github_ClosePullRequestPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The pull request that was closed. */
  pullRequest?: Maybe<Github_PullRequest>;
};

/** Represents a 'closed' event on any `Closable`. */
export type Github_ClosedEvent = Github_Node & Github_UniformResourceLocatable & {
  __typename?: 'Github_ClosedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Object that was closed. */
  closable: Github_Closable;
  /** Object which triggered the creation of this event. */
  closer?: Maybe<Github_Closer>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** The HTTP path for this closed event. */
  resourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this closed event. */
  url: Scalars['Github_URI'];
};

/** The object which triggered a `ClosedEvent`. */
export type Github_Closer = Github_Commit | Github_PullRequest;

/** The Code of Conduct for a repository */
export type Github_CodeOfConduct = Github_Node & {
  __typename?: 'Github_CodeOfConduct';
  /** The body of the Code of Conduct */
  body?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The key for the Code of Conduct */
  key: Scalars['String'];
  /** The formal name of the Code of Conduct */
  name: Scalars['String'];
  /** The HTTP path for this Code of Conduct */
  resourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for this Code of Conduct */
  url?: Maybe<Scalars['Github_URI']>;
};

/** Collaborators affiliation level with a subject. */
export enum Github_CollaboratorAffiliation {
  /** All collaborators the authenticated user can see. */
  All = 'ALL',
  /** All collaborators with permissions to an organization-owned subject, regardless of organization membership status. */
  Direct = 'DIRECT',
  /** All outside collaborators of an organization-owned subject. */
  Outside = 'OUTSIDE'
}

/** Represents a comment. */
export type Github_Comment = {
  /** The actor who authored the comment. */
  author?: Maybe<Github_Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: Github_CommentAuthorAssociation;
  /** The body as Markdown. */
  body: Scalars['String'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['Github_HTML'];
  /** The body rendered to text. */
  bodyText: Scalars['String'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'];
  /** The actor who edited the comment. */
  editor?: Maybe<Github_Actor>;
  id: Scalars['ID'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<Github_UserContentEditConnection>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'];
};


/** Represents a comment. */
export type Github_CommentUserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** A comment author association with repository. */
export enum Github_CommentAuthorAssociation {
  /** Author has been invited to collaborate on the repository. */
  Collaborator = 'COLLABORATOR',
  /** Author has previously committed to the repository. */
  Contributor = 'CONTRIBUTOR',
  /** Author has not previously committed to GitHub. */
  FirstTimer = 'FIRST_TIMER',
  /** Author has not previously committed to the repository. */
  FirstTimeContributor = 'FIRST_TIME_CONTRIBUTOR',
  /** Author is a placeholder for an unclaimed user. */
  Mannequin = 'MANNEQUIN',
  /** Author is a member of the organization that owns the repository. */
  Member = 'MEMBER',
  /** Author has no association with the repository. */
  None = 'NONE',
  /** Author is the owner of the repository. */
  Owner = 'OWNER'
}

/** The possible errors that will prevent a user from updating a comment. */
export enum Github_CommentCannotUpdateReason {
  /** Unable to create comment because repository is archived. */
  Archived = 'ARCHIVED',
  /** You cannot update this comment */
  Denied = 'DENIED',
  /** You must be the author or have write access to this repository to update this comment. */
  InsufficientAccess = 'INSUFFICIENT_ACCESS',
  /** Unable to create comment because issue is locked. */
  Locked = 'LOCKED',
  /** You must be logged in to update this comment. */
  LoginRequired = 'LOGIN_REQUIRED',
  /** Repository is under maintenance. */
  Maintenance = 'MAINTENANCE',
  /** At least one email address must be verified to update this comment. */
  VerifiedEmailRequired = 'VERIFIED_EMAIL_REQUIRED'
}

/** Represents a 'comment_deleted' event on a given issue or pull request. */
export type Github_CommentDeletedEvent = Github_Node & {
  __typename?: 'Github_CommentDeletedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The user who authored the deleted comment. */
  deletedCommentAuthor?: Maybe<Github_Actor>;
  id: Scalars['ID'];
};

/** Github_Comment mock concrete type. */
export type Github_Comment__Mock = Github_Comment & {
  __typename?: 'Github_Comment__Mock';
  /** The actor who authored the comment. */
  author?: Maybe<Github_Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: Github_CommentAuthorAssociation;
  /** The body as Markdown. */
  body: Scalars['String'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['Github_HTML'];
  /** The body rendered to text. */
  bodyText: Scalars['String'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'];
  /** The actor who edited the comment. */
  editor?: Maybe<Github_Actor>;
  id: Scalars['ID'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<Github_UserContentEditConnection>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'];
};


/** Github_Comment mock concrete type. */
export type Github_Comment__MockUserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Represents a Git commit. */
export type Github_Commit = Github_GitObject & Github_Node & Github_Subscribable & Github_UniformResourceLocatable & {
  __typename?: 'Github_Commit';
  /** An abbreviated version of the Git object ID */
  abbreviatedOid: Scalars['String'];
  /** The number of additions in this commit. */
  additions: Scalars['Int'];
  /**
   * The merged Pull Request that introduced the commit to the repository. If the
   * commit is not present in the default branch, additionally returns open Pull
   * Requests associated with the commit
   */
  associatedPullRequests?: Maybe<Github_PullRequestConnection>;
  /** Authorship details of the commit. */
  author?: Maybe<Github_GitActor>;
  /** Check if the committer and the author match. */
  authoredByCommitter: Scalars['Boolean'];
  /** The datetime when this commit was authored. */
  authoredDate: Scalars['DateTime'];
  /**
   * The list of authors for this commit based on the git author and the Co-authored-by
   * message trailer. The git author will always be first.
   */
  authors: Github_GitActorConnection;
  /** Fetches `git blame` information. */
  blame: Github_Blame;
  /** The number of changed files in this commit. */
  changedFiles: Scalars['Int'];
  /** The check suites associated with a commit. */
  checkSuites?: Maybe<Github_CheckSuiteConnection>;
  /** Comments made on the commit. */
  comments: Github_CommitCommentConnection;
  /** The HTTP path for this Git object */
  commitResourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this Git object */
  commitUrl: Scalars['Github_URI'];
  /** The datetime when this commit was committed. */
  committedDate: Scalars['DateTime'];
  /** Check if committed via GitHub web UI. */
  committedViaWeb: Scalars['Boolean'];
  /** Committer details of the commit. */
  committer?: Maybe<Github_GitActor>;
  /** The number of deletions in this commit. */
  deletions: Scalars['Int'];
  /** The deployments associated with a commit. */
  deployments?: Maybe<Github_DeploymentConnection>;
  /** The tree entry representing the file located at the given path. */
  file?: Maybe<Github_TreeEntry>;
  /** The linear commit history starting from (and including) this commit, in the same order as `git log`. */
  history: Github_CommitHistoryConnection;
  id: Scalars['ID'];
  /** The Git commit message */
  message: Scalars['String'];
  /** The Git commit message body */
  messageBody: Scalars['String'];
  /** The commit message body rendered to HTML. */
  messageBodyHTML: Scalars['Github_HTML'];
  /** The Git commit message headline */
  messageHeadline: Scalars['String'];
  /** The commit message headline rendered to HTML. */
  messageHeadlineHTML: Scalars['Github_HTML'];
  /** The Git object ID */
  oid: Scalars['Github_GitObjectID'];
  /** The organization this commit was made on behalf of. */
  onBehalfOf?: Maybe<Github_Organization>;
  /** The parents of a commit. */
  parents: Github_CommitConnection;
  /** The datetime when this commit was pushed. */
  pushedDate?: Maybe<Scalars['DateTime']>;
  /** The Repository this commit belongs to */
  repository: Github_Repository;
  /** The HTTP path for this commit */
  resourcePath: Scalars['Github_URI'];
  /** Commit signing information, if present. */
  signature?: Maybe<Github_GitSignature>;
  /** Status information for this commit */
  status?: Maybe<Github_Status>;
  /** Check and Status rollup information for this commit. */
  statusCheckRollup?: Maybe<Github_StatusCheckRollup>;
  /** Returns a list of all submodules in this repository as of this Commit parsed from the .gitmodules file. */
  submodules: Github_SubmoduleConnection;
  /**
   * Returns a URL to download a tarball archive for a repository.
   * Note: For private repositories, these links are temporary and expire after five minutes.
   */
  tarballUrl: Scalars['Github_URI'];
  /** Commit's root Tree */
  tree: Github_Tree;
  /** The HTTP path for the tree of this commit */
  treeResourcePath: Scalars['Github_URI'];
  /** The HTTP URL for the tree of this commit */
  treeUrl: Scalars['Github_URI'];
  /** The HTTP URL for this commit */
  url: Scalars['Github_URI'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<Github_SubscriptionState>;
  /**
   * Returns a URL to download a zipball archive for a repository.
   * Note: For private repositories, these links are temporary and expire after five minutes.
   */
  zipballUrl: Scalars['Github_URI'];
};


/** Represents a Git commit. */
export type Github_CommitAssociatedPullRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_PullRequestOrder>;
};


/** Represents a Git commit. */
export type Github_CommitAuthorsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a Git commit. */
export type Github_CommitBlameArgs = {
  path: Scalars['String'];
};


/** Represents a Git commit. */
export type Github_CommitCheckSuitesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filterBy?: InputMaybe<Github_CheckSuiteFilter>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a Git commit. */
export type Github_CommitCommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a Git commit. */
export type Github_CommitDeploymentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  environments?: InputMaybe<Array<Scalars['String']>>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_DeploymentOrder>;
};


/** Represents a Git commit. */
export type Github_CommitFileArgs = {
  path: Scalars['String'];
};


/** Represents a Git commit. */
export type Github_CommitHistoryArgs = {
  after?: InputMaybe<Scalars['String']>;
  author?: InputMaybe<Github_CommitAuthor>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  path?: InputMaybe<Scalars['String']>;
  since?: InputMaybe<Scalars['Github_GitTimestamp']>;
  until?: InputMaybe<Scalars['Github_GitTimestamp']>;
};


/** Represents a Git commit. */
export type Github_CommitParentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a Git commit. */
export type Github_CommitSubmodulesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Specifies an author for filtering Git commits. */
export type Github_CommitAuthor = {
  /** Email addresses to filter by. Commits authored by any of the specified email addresses will be returned. */
  emails?: InputMaybe<Array<Scalars['String']>>;
  /**
   * ID of a User to filter by. If non-null, only commits authored by this user
   * will be returned. This field takes precedence over emails.
   */
  id?: InputMaybe<Scalars['ID']>;
};

/** Represents a comment on a given Commit. */
export type Github_CommitComment = Github_Comment & Github_Deletable & Github_Minimizable & Github_Node & Github_Reactable & Github_RepositoryNode & Github_Updatable & Github_UpdatableComment & {
  __typename?: 'Github_CommitComment';
  /** The actor who authored the comment. */
  author?: Maybe<Github_Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: Github_CommentAuthorAssociation;
  /** Identifies the comment body. */
  body: Scalars['String'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['Github_HTML'];
  /** The body rendered to text. */
  bodyText: Scalars['String'];
  /** Identifies the commit associated with the comment, if the commit exists. */
  commit?: Maybe<Github_Commit>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The actor who edited the comment. */
  editor?: Maybe<Github_Actor>;
  id: Scalars['ID'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'];
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars['Boolean'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>;
  /** Returns why the comment was minimized. */
  minimizedReason?: Maybe<Scalars['String']>;
  /** Identifies the file path associated with the comment. */
  path?: Maybe<Scalars['String']>;
  /** Identifies the line position associated with the comment. */
  position?: Maybe<Scalars['Int']>;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<Github_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: Github_ReactionConnection;
  /** The repository associated with this node. */
  repository: Github_Repository;
  /** The HTTP path permalink for this commit comment. */
  resourcePath: Scalars['Github_URI'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL permalink for this commit comment. */
  url: Scalars['Github_URI'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<Github_UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'];
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars['Boolean'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<Github_CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'];
};


/** Represents a comment on a given Commit. */
export type Github_CommitCommentReactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Github_ReactionContent>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ReactionOrder>;
};


/** Represents a comment on a given Commit. */
export type Github_CommitCommentUserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for CommitComment. */
export type Github_CommitCommentConnection = {
  __typename?: 'Github_CommitCommentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_CommitCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_CommitComment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_CommitCommentEdge = {
  __typename?: 'Github_CommitCommentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_CommitComment>;
};

/** A thread of comments on a commit. */
export type Github_CommitCommentThread = Github_Node & Github_RepositoryNode & {
  __typename?: 'Github_CommitCommentThread';
  /** The comments that exist in this thread. */
  comments: Github_CommitCommentConnection;
  /** The commit the comments were made on. */
  commit?: Maybe<Github_Commit>;
  id: Scalars['ID'];
  /** The file the comments were made on. */
  path?: Maybe<Scalars['String']>;
  /** The position in the diff for the commit that the comment was made on. */
  position?: Maybe<Scalars['Int']>;
  /** The repository associated with this node. */
  repository: Github_Repository;
};


/** A thread of comments on a commit. */
export type Github_CommitCommentThreadCommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for Commit. */
export type Github_CommitConnection = {
  __typename?: 'Github_CommitConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_CommitEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Commit>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Ordering options for commit contribution connections. */
export type Github_CommitContributionOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field by which to order commit contributions. */
  field: Github_CommitContributionOrderField;
};

/** Properties by which commit contribution connections can be ordered. */
export enum Github_CommitContributionOrderField {
  /** Order commit contributions by how many commits they represent. */
  CommitCount = 'COMMIT_COUNT',
  /** Order commit contributions by when they were made. */
  OccurredAt = 'OCCURRED_AT'
}

/** This aggregates commits made by a user within one repository. */
export type Github_CommitContributionsByRepository = {
  __typename?: 'Github_CommitContributionsByRepository';
  /** The commit contributions, each representing a day. */
  contributions: Github_CreatedCommitContributionConnection;
  /** The repository in which the commits were made. */
  repository: Github_Repository;
  /** The HTTP path for the user's commits to the repository in this time range. */
  resourcePath: Scalars['Github_URI'];
  /** The HTTP URL for the user's commits to the repository in this time range. */
  url: Scalars['Github_URI'];
};


/** This aggregates commits made by a user within one repository. */
export type Github_CommitContributionsByRepositoryContributionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_CommitContributionOrder>;
};

/** An edge in a connection. */
export type Github_CommitEdge = {
  __typename?: 'Github_CommitEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Commit>;
};

/** The connection type for Commit. */
export type Github_CommitHistoryConnection = {
  __typename?: 'Github_CommitHistoryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_CommitEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Commit>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** A message to include with a new commit */
export type Github_CommitMessage = {
  /** The body of the message. */
  body?: InputMaybe<Scalars['String']>;
  /** The headline of the message. */
  headline: Scalars['String'];
};

/**
 * A git ref for a commit to be appended to.
 *
 * The ref must be a branch, i.e. its fully qualified name must start
 * with `refs/heads/` (although the input is not required to be fully
 * qualified).
 *
 * The Ref may be specified by its global node ID or by the
 * repository nameWithOwner and branch name.
 *
 * ### Examples
 *
 * Specify a branch using a global node ID:
 *
 *     { "id": "MDM6UmVmMTpyZWZzL2hlYWRzL21haW4=" }
 *
 * Specify a branch using nameWithOwner and branch name:
 *
 *     {
 *       "nameWithOwner": "github/graphql-client",
 *       "branchName": "main"
 *     }
 */
export type Github_CommittableBranch = {
  /** The unqualified name of the branch to append the commit to. */
  branchName?: InputMaybe<Scalars['String']>;
  /** The Node ID of the Ref to be updated. */
  id?: InputMaybe<Scalars['ID']>;
  /** The nameWithOwner of the repository to commit to. */
  repositoryNameWithOwner?: InputMaybe<Scalars['String']>;
};

/** Represents a 'connected' event on a given issue or pull request. */
export type Github_ConnectedEvent = Github_Node & {
  __typename?: 'Github_ConnectedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Reference originated in a different repository. */
  isCrossRepository: Scalars['Boolean'];
  /** Issue or pull request that made the reference. */
  source: Github_ReferencedSubject;
  /** Issue or pull request which was connected. */
  subject: Github_ReferencedSubject;
};

/** Represents a contribution a user made on GitHub, such as opening an issue. */
export type Github_Contribution = {
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean'];
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime'];
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this contribution. */
  url: Scalars['Github_URI'];
  /** The user who made this contribution. */
  user: Github_User;
};

/** A calendar of contributions made on GitHub by a user. */
export type Github_ContributionCalendar = {
  __typename?: 'Github_ContributionCalendar';
  /** A list of hex color codes used in this calendar. The darker the color, the more contributions it represents. */
  colors: Array<Scalars['String']>;
  /** Determine if the color set was chosen because it's currently Halloween. */
  isHalloween: Scalars['Boolean'];
  /** A list of the months of contributions in this calendar. */
  months: Array<Github_ContributionCalendarMonth>;
  /** The count of total contributions in the calendar. */
  totalContributions: Scalars['Int'];
  /** A list of the weeks of contributions in this calendar. */
  weeks: Array<Github_ContributionCalendarWeek>;
};

/** Represents a single day of contributions on GitHub by a user. */
export type Github_ContributionCalendarDay = {
  __typename?: 'Github_ContributionCalendarDay';
  /** The hex color code that represents how many contributions were made on this day compared to others in the calendar. */
  color: Scalars['String'];
  /** How many contributions were made by the user on this day. */
  contributionCount: Scalars['Int'];
  /**
   * Indication of contributions, relative to other days. Can be used to indicate
   * which color to represent this day on a calendar.
   */
  contributionLevel: Github_ContributionLevel;
  /** The day this square represents. */
  date: Scalars['Date'];
  /** A number representing which day of the week this square represents, e.g., 1 is Monday. */
  weekday: Scalars['Int'];
};

/** A month of contributions in a user's contribution graph. */
export type Github_ContributionCalendarMonth = {
  __typename?: 'Github_ContributionCalendarMonth';
  /** The date of the first day of this month. */
  firstDay: Scalars['Date'];
  /** The name of the month. */
  name: Scalars['String'];
  /** How many weeks started in this month. */
  totalWeeks: Scalars['Int'];
  /** The year the month occurred in. */
  year: Scalars['Int'];
};

/** A week of contributions in a user's contribution graph. */
export type Github_ContributionCalendarWeek = {
  __typename?: 'Github_ContributionCalendarWeek';
  /** The days of contributions in this week. */
  contributionDays: Array<Github_ContributionCalendarDay>;
  /** The date of the earliest square in this week. */
  firstDay: Scalars['Date'];
};

/** Varying levels of contributions from none to many. */
export enum Github_ContributionLevel {
  /** Lowest 25% of days of contributions. */
  FirstQuartile = 'FIRST_QUARTILE',
  /** Highest 25% of days of contributions. More contributions than the third quartile. */
  FourthQuartile = 'FOURTH_QUARTILE',
  /** No contributions occurred. */
  None = 'NONE',
  /** Second lowest 25% of days of contributions. More contributions than the first quartile. */
  SecondQuartile = 'SECOND_QUARTILE',
  /** Second highest 25% of days of contributions. More contributions than second quartile, less than the fourth quartile. */
  ThirdQuartile = 'THIRD_QUARTILE'
}

/** Ordering options for contribution connections. */
export type Github_ContributionOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
};

/** Github_Contribution mock concrete type. */
export type Github_Contribution__Mock = Github_Contribution & {
  __typename?: 'Github_Contribution__Mock';
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean'];
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime'];
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this contribution. */
  url: Scalars['Github_URI'];
  /** The user who made this contribution. */
  user: Github_User;
};

/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type Github_ContributionsCollection = {
  __typename?: 'Github_ContributionsCollection';
  /** Commit contributions made by the user, grouped by repository. */
  commitContributionsByRepository: Array<Github_CommitContributionsByRepository>;
  /** A calendar of this user's contributions on GitHub. */
  contributionCalendar: Github_ContributionCalendar;
  /** The years the user has been making contributions with the most recent year first. */
  contributionYears: Array<Scalars['Int']>;
  /** Determine if this collection's time span ends in the current month. */
  doesEndInCurrentMonth: Scalars['Boolean'];
  /**
   * The date of the first restricted contribution the user made in this time
   * period. Can only be non-null when the user has enabled private contribution counts.
   */
  earliestRestrictedContributionDate?: Maybe<Scalars['Date']>;
  /** The ending date and time of this collection. */
  endedAt: Scalars['DateTime'];
  /**
   * The first issue the user opened on GitHub. This will be null if that issue was
   * opened outside the collection's time range and ignoreTimeRange is false. If
   * the issue is not visible but the user has opted to show private contributions,
   * a RestrictedContribution will be returned.
   */
  firstIssueContribution?: Maybe<Github_CreatedIssueOrRestrictedContribution>;
  /**
   * The first pull request the user opened on GitHub. This will be null if that
   * pull request was opened outside the collection's time range and
   * ignoreTimeRange is not true. If the pull request is not visible but the user
   * has opted to show private contributions, a RestrictedContribution will be returned.
   */
  firstPullRequestContribution?: Maybe<Github_CreatedPullRequestOrRestrictedContribution>;
  /**
   * The first repository the user created on GitHub. This will be null if that
   * first repository was created outside the collection's time range and
   * ignoreTimeRange is false. If the repository is not visible, then a
   * RestrictedContribution is returned.
   */
  firstRepositoryContribution?: Maybe<Github_CreatedRepositoryOrRestrictedContribution>;
  /** Does the user have any more activity in the timeline that occurred prior to the collection's time range? */
  hasActivityInThePast: Scalars['Boolean'];
  /** Determine if there are any contributions in this collection. */
  hasAnyContributions: Scalars['Boolean'];
  /**
   * Determine if the user made any contributions in this time frame whose details
   * are not visible because they were made in a private repository. Can only be
   * true if the user enabled private contribution counts.
   */
  hasAnyRestrictedContributions: Scalars['Boolean'];
  /** Whether or not the collector's time span is all within the same day. */
  isSingleDay: Scalars['Boolean'];
  /** A list of issues the user opened. */
  issueContributions: Github_CreatedIssueContributionConnection;
  /** Issue contributions made by the user, grouped by repository. */
  issueContributionsByRepository: Array<Github_IssueContributionsByRepository>;
  /**
   * When the user signed up for GitHub. This will be null if that sign up date
   * falls outside the collection's time range and ignoreTimeRange is false.
   */
  joinedGitHubContribution?: Maybe<Github_JoinedGitHubContribution>;
  /**
   * The date of the most recent restricted contribution the user made in this time
   * period. Can only be non-null when the user has enabled private contribution counts.
   */
  latestRestrictedContributionDate?: Maybe<Scalars['Date']>;
  /**
   * When this collection's time range does not include any activity from the user, use this
   * to get a different collection from an earlier time range that does have activity.
   */
  mostRecentCollectionWithActivity?: Maybe<Github_ContributionsCollection>;
  /**
   * Returns a different contributions collection from an earlier time range than this one
   * that does not have any contributions.
   */
  mostRecentCollectionWithoutActivity?: Maybe<Github_ContributionsCollection>;
  /**
   * The issue the user opened on GitHub that received the most comments in the specified
   * time frame.
   */
  popularIssueContribution?: Maybe<Github_CreatedIssueContribution>;
  /**
   * The pull request the user opened on GitHub that received the most comments in the
   * specified time frame.
   */
  popularPullRequestContribution?: Maybe<Github_CreatedPullRequestContribution>;
  /** Pull request contributions made by the user. */
  pullRequestContributions: Github_CreatedPullRequestContributionConnection;
  /** Pull request contributions made by the user, grouped by repository. */
  pullRequestContributionsByRepository: Array<Github_PullRequestContributionsByRepository>;
  /** Pull request review contributions made by the user. */
  pullRequestReviewContributions: Github_CreatedPullRequestReviewContributionConnection;
  /** Pull request review contributions made by the user, grouped by repository. */
  pullRequestReviewContributionsByRepository: Array<Github_PullRequestReviewContributionsByRepository>;
  /** A list of repositories owned by the user that the user created in this time range. */
  repositoryContributions: Github_CreatedRepositoryContributionConnection;
  /**
   * A count of contributions made by the user that the viewer cannot access. Only
   * non-zero when the user has chosen to share their private contribution counts.
   */
  restrictedContributionsCount: Scalars['Int'];
  /** The beginning date and time of this collection. */
  startedAt: Scalars['DateTime'];
  /** How many commits were made by the user in this time span. */
  totalCommitContributions: Scalars['Int'];
  /** How many issues the user opened. */
  totalIssueContributions: Scalars['Int'];
  /** How many pull requests the user opened. */
  totalPullRequestContributions: Scalars['Int'];
  /** How many pull request reviews the user left. */
  totalPullRequestReviewContributions: Scalars['Int'];
  /** How many different repositories the user committed to. */
  totalRepositoriesWithContributedCommits: Scalars['Int'];
  /** How many different repositories the user opened issues in. */
  totalRepositoriesWithContributedIssues: Scalars['Int'];
  /** How many different repositories the user left pull request reviews in. */
  totalRepositoriesWithContributedPullRequestReviews: Scalars['Int'];
  /** How many different repositories the user opened pull requests in. */
  totalRepositoriesWithContributedPullRequests: Scalars['Int'];
  /** How many repositories the user created. */
  totalRepositoryContributions: Scalars['Int'];
  /** The user who made the contributions in this collection. */
  user: Github_User;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type Github_ContributionsCollectionCommitContributionsByRepositoryArgs = {
  maxRepositories?: InputMaybe<Scalars['Int']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type Github_ContributionsCollectionIssueContributionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  excludeFirst?: InputMaybe<Scalars['Boolean']>;
  excludePopular?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ContributionOrder>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type Github_ContributionsCollectionIssueContributionsByRepositoryArgs = {
  excludeFirst?: InputMaybe<Scalars['Boolean']>;
  excludePopular?: InputMaybe<Scalars['Boolean']>;
  maxRepositories?: InputMaybe<Scalars['Int']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type Github_ContributionsCollectionPullRequestContributionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  excludeFirst?: InputMaybe<Scalars['Boolean']>;
  excludePopular?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ContributionOrder>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type Github_ContributionsCollectionPullRequestContributionsByRepositoryArgs = {
  excludeFirst?: InputMaybe<Scalars['Boolean']>;
  excludePopular?: InputMaybe<Scalars['Boolean']>;
  maxRepositories?: InputMaybe<Scalars['Int']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type Github_ContributionsCollectionPullRequestReviewContributionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ContributionOrder>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type Github_ContributionsCollectionPullRequestReviewContributionsByRepositoryArgs = {
  maxRepositories?: InputMaybe<Scalars['Int']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type Github_ContributionsCollectionRepositoryContributionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  excludeFirst?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ContributionOrder>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type Github_ContributionsCollectionTotalIssueContributionsArgs = {
  excludeFirst?: InputMaybe<Scalars['Boolean']>;
  excludePopular?: InputMaybe<Scalars['Boolean']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type Github_ContributionsCollectionTotalPullRequestContributionsArgs = {
  excludeFirst?: InputMaybe<Scalars['Boolean']>;
  excludePopular?: InputMaybe<Scalars['Boolean']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type Github_ContributionsCollectionTotalRepositoriesWithContributedIssuesArgs = {
  excludeFirst?: InputMaybe<Scalars['Boolean']>;
  excludePopular?: InputMaybe<Scalars['Boolean']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type Github_ContributionsCollectionTotalRepositoriesWithContributedPullRequestsArgs = {
  excludeFirst?: InputMaybe<Scalars['Boolean']>;
  excludePopular?: InputMaybe<Scalars['Boolean']>;
};


/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */
export type Github_ContributionsCollectionTotalRepositoryContributionsArgs = {
  excludeFirst?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated input type of ConvertProjectCardNoteToIssue */
export type Github_ConvertProjectCardNoteToIssueInput = {
  /** The body of the newly created issue. */
  body?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ProjectCard ID to convert. */
  projectCardId: Scalars['ID'];
  /** The ID of the repository to create the issue in. */
  repositoryId: Scalars['ID'];
  /** The title of the newly created issue. Defaults to the card's note text. */
  title?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of ConvertProjectCardNoteToIssue */
export type Github_ConvertProjectCardNoteToIssuePayload = {
  __typename?: 'Github_ConvertProjectCardNoteToIssuePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated ProjectCard. */
  projectCard?: Maybe<Github_ProjectCard>;
};

/** Autogenerated input type of ConvertPullRequestToDraft */
export type Github_ConvertPullRequestToDraftInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the pull request to convert to draft */
  pullRequestId: Scalars['ID'];
};

/** Autogenerated return type of ConvertPullRequestToDraft */
export type Github_ConvertPullRequestToDraftPayload = {
  __typename?: 'Github_ConvertPullRequestToDraftPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The pull request that is now a draft. */
  pullRequest?: Maybe<Github_PullRequest>;
};

/** Represents a 'convert_to_draft' event on a given pull request. */
export type Github_ConvertToDraftEvent = Github_Node & Github_UniformResourceLocatable & {
  __typename?: 'Github_ConvertToDraftEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest: Github_PullRequest;
  /** The HTTP path for this convert to draft event. */
  resourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this convert to draft event. */
  url: Scalars['Github_URI'];
};

/** Represents a 'converted_note_to_issue' event on a given issue or pull request. */
export type Github_ConvertedNoteToIssueEvent = Github_Node & {
  __typename?: 'Github_ConvertedNoteToIssueEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** Project referenced by event. */
  project?: Maybe<Github_Project>;
  /** Project card referenced by this project event. */
  projectCard?: Maybe<Github_ProjectCard>;
  /** Column name referenced by this project event. */
  projectColumnName: Scalars['String'];
};

/** Represents a 'converted_to_discussion' event on a given issue. */
export type Github_ConvertedToDiscussionEvent = Github_Node & {
  __typename?: 'Github_ConvertedToDiscussionEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The discussion that the issue was converted into. */
  discussion?: Maybe<Github_Discussion>;
  id: Scalars['ID'];
};

/** Autogenerated input type of CreateBranchProtectionRule */
export type Github_CreateBranchProtectionRuleInput = {
  /** Can this branch be deleted. */
  allowsDeletions?: InputMaybe<Scalars['Boolean']>;
  /** Are force pushes allowed on this branch. */
  allowsForcePushes?: InputMaybe<Scalars['Boolean']>;
  /** A list of User or Team IDs allowed to bypass force push targeting matching branches. */
  bypassForcePushActorIds?: InputMaybe<Array<Scalars['ID']>>;
  /** A list of User or Team IDs allowed to bypass pull requests targeting matching branches. */
  bypassPullRequestActorIds?: InputMaybe<Array<Scalars['ID']>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Will new commits pushed to matching branches dismiss pull request review approvals. */
  dismissesStaleReviews?: InputMaybe<Scalars['Boolean']>;
  /** Can admins overwrite branch protection. */
  isAdminEnforced?: InputMaybe<Scalars['Boolean']>;
  /** The glob-like pattern used to determine matching branches. */
  pattern: Scalars['String'];
  /** A list of User, Team or App IDs allowed to push to matching branches. */
  pushActorIds?: InputMaybe<Array<Scalars['ID']>>;
  /** The global relay id of the repository in which a new branch protection rule should be created in. */
  repositoryId: Scalars['ID'];
  /** Number of approving reviews required to update matching branches. */
  requiredApprovingReviewCount?: InputMaybe<Scalars['Int']>;
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  requiredStatusCheckContexts?: InputMaybe<Array<Scalars['String']>>;
  /** The list of required status checks */
  requiredStatusChecks?: InputMaybe<Array<Github_RequiredStatusCheckInput>>;
  /** Are approving reviews required to update matching branches. */
  requiresApprovingReviews?: InputMaybe<Scalars['Boolean']>;
  /** Are reviews from code owners required to update matching branches. */
  requiresCodeOwnerReviews?: InputMaybe<Scalars['Boolean']>;
  /** Are commits required to be signed. */
  requiresCommitSignatures?: InputMaybe<Scalars['Boolean']>;
  /** Are conversations required to be resolved before merging. */
  requiresConversationResolution?: InputMaybe<Scalars['Boolean']>;
  /** Are merge commits prohibited from being pushed to this branch. */
  requiresLinearHistory?: InputMaybe<Scalars['Boolean']>;
  /** Are status checks required to update matching branches. */
  requiresStatusChecks?: InputMaybe<Scalars['Boolean']>;
  /** Are branches required to be up to date before merging. */
  requiresStrictStatusChecks?: InputMaybe<Scalars['Boolean']>;
  /** Is pushing to matching branches restricted. */
  restrictsPushes?: InputMaybe<Scalars['Boolean']>;
  /** Is dismissal of pull request reviews restricted. */
  restrictsReviewDismissals?: InputMaybe<Scalars['Boolean']>;
  /** A list of User or Team IDs allowed to dismiss reviews on pull requests targeting matching branches. */
  reviewDismissalActorIds?: InputMaybe<Array<Scalars['ID']>>;
};

/** Autogenerated return type of CreateBranchProtectionRule */
export type Github_CreateBranchProtectionRulePayload = {
  __typename?: 'Github_CreateBranchProtectionRulePayload';
  /** The newly created BranchProtectionRule. */
  branchProtectionRule?: Maybe<Github_BranchProtectionRule>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of CreateCheckRun */
export type Github_CreateCheckRunInput = {
  /** Possible further actions the integrator can perform, which a user may trigger. */
  actions?: InputMaybe<Array<Github_CheckRunAction>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The time that the check run finished. */
  completedAt?: InputMaybe<Scalars['DateTime']>;
  /** The final conclusion of the check. */
  conclusion?: InputMaybe<Github_CheckConclusionState>;
  /** The URL of the integrator's site that has the full details of the check. */
  detailsUrl?: InputMaybe<Scalars['Github_URI']>;
  /** A reference for the run on the integrator's system. */
  externalId?: InputMaybe<Scalars['String']>;
  /** The SHA of the head commit. */
  headSha: Scalars['Github_GitObjectID'];
  /** The name of the check. */
  name: Scalars['String'];
  /** Descriptive details about the run. */
  output?: InputMaybe<Github_CheckRunOutput>;
  /** The node ID of the repository. */
  repositoryId: Scalars['ID'];
  /** The time that the check run began. */
  startedAt?: InputMaybe<Scalars['DateTime']>;
  /** The current status. */
  status?: InputMaybe<Github_RequestableCheckStatusState>;
};

/** Autogenerated return type of CreateCheckRun */
export type Github_CreateCheckRunPayload = {
  __typename?: 'Github_CreateCheckRunPayload';
  /** The newly created check run. */
  checkRun?: Maybe<Github_CheckRun>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of CreateCheckSuite */
export type Github_CreateCheckSuiteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The SHA of the head commit. */
  headSha: Scalars['Github_GitObjectID'];
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of CreateCheckSuite */
export type Github_CreateCheckSuitePayload = {
  __typename?: 'Github_CreateCheckSuitePayload';
  /** The newly created check suite. */
  checkSuite?: Maybe<Github_CheckSuite>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of CreateCommitOnBranch */
export type Github_CreateCommitOnBranchInput = {
  /** The Ref to be updated.  Must be a branch. */
  branch: Github_CommittableBranch;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The git commit oid expected at the head of the branch prior to the commit */
  expectedHeadOid: Scalars['Github_GitObjectID'];
  /** A description of changes to files in this commit. */
  fileChanges?: InputMaybe<Github_FileChanges>;
  /** The commit message the be included with the commit. */
  message: Github_CommitMessage;
};

/** Autogenerated return type of CreateCommitOnBranch */
export type Github_CreateCommitOnBranchPayload = {
  __typename?: 'Github_CreateCommitOnBranchPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new commit. */
  commit?: Maybe<Github_Commit>;
  /** The ref which has been updated to point to the new commit. */
  ref?: Maybe<Github_Ref>;
};

/** Autogenerated input type of CreateDeployment */
export type Github_CreateDeploymentInput = {
  /** Attempt to automatically merge the default branch into the requested ref, defaults to true. */
  autoMerge?: InputMaybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Short description of the deployment. */
  description?: InputMaybe<Scalars['String']>;
  /** Name for the target deployment environment. */
  environment?: InputMaybe<Scalars['String']>;
  /** JSON payload with extra information about the deployment. */
  payload?: InputMaybe<Scalars['String']>;
  /** The node ID of the ref to be deployed. */
  refId: Scalars['ID'];
  /** The node ID of the repository. */
  repositoryId: Scalars['ID'];
  /**
   * The status contexts to verify against commit status checks. To bypass required
   * contexts, pass an empty array. Defaults to all unique contexts.
   */
  requiredContexts?: InputMaybe<Array<Scalars['String']>>;
  /** Specifies a task to execute. */
  task?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of CreateDeployment */
export type Github_CreateDeploymentPayload = {
  __typename?: 'Github_CreateDeploymentPayload';
  /** True if the default branch has been auto-merged into the deployment ref. */
  autoMerged?: Maybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new deployment. */
  deployment?: Maybe<Github_Deployment>;
};

/** Autogenerated input type of CreateDeploymentStatus */
export type Github_CreateDeploymentStatusInput = {
  /**
   * Adds a new inactive status to all non-transient, non-production environment
   * deployments with the same repository and environment name as the created
   * status's deployment.
   */
  autoInactive?: InputMaybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The node ID of the deployment. */
  deploymentId: Scalars['ID'];
  /** A short description of the status. Maximum length of 140 characters. */
  description?: InputMaybe<Scalars['String']>;
  /** If provided, updates the environment of the deploy. Otherwise, does not modify the environment. */
  environment?: InputMaybe<Scalars['String']>;
  /** Sets the URL for accessing your environment. */
  environmentUrl?: InputMaybe<Scalars['String']>;
  /**
   * The log URL to associate with this status.       This URL should contain
   * output to keep the user updated while the task is running       or serve as
   * historical information for what happened in the deployment.
   */
  logUrl?: InputMaybe<Scalars['String']>;
  /** The state of the deployment. */
  state: Github_DeploymentStatusState;
};

/** Autogenerated return type of CreateDeploymentStatus */
export type Github_CreateDeploymentStatusPayload = {
  __typename?: 'Github_CreateDeploymentStatusPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new deployment status. */
  deploymentStatus?: Maybe<Github_DeploymentStatus>;
};

/** Autogenerated input type of CreateDiscussion */
export type Github_CreateDiscussionInput = {
  /** The body of the discussion. */
  body: Scalars['String'];
  /** The id of the discussion category to associate with this discussion. */
  categoryId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The id of the repository on which to create the discussion. */
  repositoryId: Scalars['ID'];
  /** The title of the discussion. */
  title: Scalars['String'];
};

/** Autogenerated return type of CreateDiscussion */
export type Github_CreateDiscussionPayload = {
  __typename?: 'Github_CreateDiscussionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The discussion that was just created. */
  discussion?: Maybe<Github_Discussion>;
};

/** Autogenerated input type of CreateEnterpriseOrganization */
export type Github_CreateEnterpriseOrganizationInput = {
  /** The logins for the administrators of the new organization. */
  adminLogins: Array<Scalars['String']>;
  /** The email used for sending billing receipts. */
  billingEmail: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise owning the new organization. */
  enterpriseId: Scalars['ID'];
  /** The login of the new organization. */
  login: Scalars['String'];
  /** The profile name of the new organization. */
  profileName: Scalars['String'];
};

/** Autogenerated return type of CreateEnterpriseOrganization */
export type Github_CreateEnterpriseOrganizationPayload = {
  __typename?: 'Github_CreateEnterpriseOrganizationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise that owns the created organization. */
  enterprise?: Maybe<Github_Enterprise>;
  /** The organization that was created. */
  organization?: Maybe<Github_Organization>;
};

/** Autogenerated input type of CreateEnvironment */
export type Github_CreateEnvironmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The name of the environment. */
  name: Scalars['String'];
  /** The node ID of the repository. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of CreateEnvironment */
export type Github_CreateEnvironmentPayload = {
  __typename?: 'Github_CreateEnvironmentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new or existing environment. */
  environment?: Maybe<Github_Environment>;
};

/** Autogenerated input type of CreateIpAllowListEntry */
export type Github_CreateIpAllowListEntryInput = {
  /** An IP address or range of addresses in CIDR notation. */
  allowListValue: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Whether the IP allow list entry is active when an IP allow list is enabled. */
  isActive: Scalars['Boolean'];
  /** An optional name for the IP allow list entry. */
  name?: InputMaybe<Scalars['String']>;
  /** The ID of the owner for which to create the new IP allow list entry. */
  ownerId: Scalars['ID'];
};

/** Autogenerated return type of CreateIpAllowListEntry */
export type Github_CreateIpAllowListEntryPayload = {
  __typename?: 'Github_CreateIpAllowListEntryPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The IP allow list entry that was created. */
  ipAllowListEntry?: Maybe<Github_IpAllowListEntry>;
};

/** Autogenerated input type of CreateIssue */
export type Github_CreateIssueInput = {
  /** The Node ID for the user assignee for this issue. */
  assigneeIds?: InputMaybe<Array<Scalars['ID']>>;
  /** The body for the issue description. */
  body?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The name of an issue template in the repository, assigns labels and assignees from the template to the issue */
  issueTemplate?: InputMaybe<Scalars['String']>;
  /** An array of Node IDs of labels for this issue. */
  labelIds?: InputMaybe<Array<Scalars['ID']>>;
  /** The Node ID of the milestone for this issue. */
  milestoneId?: InputMaybe<Scalars['ID']>;
  /** An array of Node IDs for projects associated with this issue. */
  projectIds?: InputMaybe<Array<Scalars['ID']>>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
  /** The title for the issue. */
  title: Scalars['String'];
};

/** Autogenerated return type of CreateIssue */
export type Github_CreateIssuePayload = {
  __typename?: 'Github_CreateIssuePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new issue. */
  issue?: Maybe<Github_Issue>;
};

/** Autogenerated input type of CreateLabel */
export type Github_CreateLabelInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** A 6 character hex code, without the leading #, identifying the color of the label. */
  color: Scalars['String'];
  /** A brief description of the label, such as its purpose. */
  description?: InputMaybe<Scalars['String']>;
  /** The name of the label. */
  name: Scalars['String'];
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of CreateLabel */
export type Github_CreateLabelPayload = {
  __typename?: 'Github_CreateLabelPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new label. */
  label?: Maybe<Github_Label>;
};

/** Autogenerated input type of CreateProject */
export type Github_CreateProjectInput = {
  /** The description of project. */
  body?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The name of project. */
  name: Scalars['String'];
  /** The owner ID to create the project under. */
  ownerId: Scalars['ID'];
  /** A list of repository IDs to create as linked repositories for the project */
  repositoryIds?: InputMaybe<Array<Scalars['ID']>>;
  /** The name of the GitHub-provided template. */
  template?: InputMaybe<Github_ProjectTemplate>;
};

/** Autogenerated return type of CreateProject */
export type Github_CreateProjectPayload = {
  __typename?: 'Github_CreateProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new project. */
  project?: Maybe<Github_Project>;
};

/** Autogenerated input type of CreatePullRequest */
export type Github_CreatePullRequestInput = {
  /**
   * The name of the branch you want your changes pulled into. This should be an existing branch
   * on the current repository. You cannot update the base branch on a pull request to point
   * to another repository.
   */
  baseRefName: Scalars['String'];
  /** The contents of the pull request. */
  body?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Indicates whether this pull request should be a draft. */
  draft?: InputMaybe<Scalars['Boolean']>;
  /**
   * The name of the branch where your changes are implemented. For cross-repository pull requests
   * in the same network, namespace `head_ref_name` with a user like this: `username:branch`.
   */
  headRefName: Scalars['String'];
  /** Indicates whether maintainers can modify the pull request. */
  maintainerCanModify?: InputMaybe<Scalars['Boolean']>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
  /** The title of the pull request. */
  title: Scalars['String'];
};

/** Autogenerated return type of CreatePullRequest */
export type Github_CreatePullRequestPayload = {
  __typename?: 'Github_CreatePullRequestPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new pull request. */
  pullRequest?: Maybe<Github_PullRequest>;
};

/** Autogenerated input type of CreateRef */
export type Github_CreateRefInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The fully qualified name of the new Ref (ie: `refs/heads/my_new_branch`). */
  name: Scalars['String'];
  /** The GitObjectID that the new Ref shall target. Must point to a commit. */
  oid: Scalars['Github_GitObjectID'];
  /** The Node ID of the Repository to create the Ref in. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of CreateRef */
export type Github_CreateRefPayload = {
  __typename?: 'Github_CreateRefPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The newly created ref. */
  ref?: Maybe<Github_Ref>;
};

/** Autogenerated input type of CreateRepository */
export type Github_CreateRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** A short description of the new repository. */
  description?: InputMaybe<Scalars['String']>;
  /** Indicates if the repository should have the issues feature enabled. */
  hasIssuesEnabled?: InputMaybe<Scalars['Boolean']>;
  /** Indicates if the repository should have the wiki feature enabled. */
  hasWikiEnabled?: InputMaybe<Scalars['Boolean']>;
  /** The URL for a web page about this repository. */
  homepageUrl?: InputMaybe<Scalars['Github_URI']>;
  /** The name of the new repository. */
  name: Scalars['String'];
  /** The ID of the owner for the new repository. */
  ownerId?: InputMaybe<Scalars['ID']>;
  /**
   * When an organization is specified as the owner, this ID identifies the team
   * that should be granted access to the new repository.
   */
  teamId?: InputMaybe<Scalars['ID']>;
  /**
   * Whether this repository should be marked as a template such that anyone who
   * can access it can create new repositories with the same files and directory structure.
   */
  template?: InputMaybe<Scalars['Boolean']>;
  /** Indicates the repository's visibility level. */
  visibility: Github_RepositoryVisibility;
};

/** Autogenerated return type of CreateRepository */
export type Github_CreateRepositoryPayload = {
  __typename?: 'Github_CreateRepositoryPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new repository. */
  repository?: Maybe<Github_Repository>;
};

/** Autogenerated input type of CreateSponsorship */
export type Github_CreateSponsorshipInput = {
  /** The amount to pay to the sponsorable in US dollars. Required if a tierId is not specified. Valid values: 1-12000. */
  amount?: InputMaybe<Scalars['Int']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Whether the sponsorship should happen monthly/yearly or just this one time. Required if a tierId is not specified. */
  isRecurring?: InputMaybe<Scalars['Boolean']>;
  /**
   * Specify whether others should be able to see that the sponsor is sponsoring
   * the sponsorable. Public visibility still does not reveal which tier is used.
   */
  privacyLevel?: InputMaybe<Github_SponsorshipPrivacy>;
  /** Whether the sponsor should receive email updates from the sponsorable. */
  receiveEmails?: InputMaybe<Scalars['Boolean']>;
  /**
   * The ID of the user or organization who is acting as the sponsor, paying for
   * the sponsorship. Required if sponsorLogin is not given.
   */
  sponsorId?: InputMaybe<Scalars['ID']>;
  /**
   * The username of the user or organization who is acting as the sponsor, paying
   * for the sponsorship. Required if sponsorId is not given.
   */
  sponsorLogin?: InputMaybe<Scalars['String']>;
  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */
  sponsorableId?: InputMaybe<Scalars['ID']>;
  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */
  sponsorableLogin?: InputMaybe<Scalars['String']>;
  /** The ID of one of sponsorable's existing tiers to sponsor at. Required if amount is not specified. */
  tierId?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated return type of CreateSponsorship */
export type Github_CreateSponsorshipPayload = {
  __typename?: 'Github_CreateSponsorshipPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The sponsorship that was started. */
  sponsorship?: Maybe<Github_Sponsorship>;
};

/** Autogenerated input type of CreateTeamDiscussionComment */
export type Github_CreateTeamDiscussionCommentInput = {
  /** The content of the comment. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the discussion to which the comment belongs. */
  discussionId: Scalars['ID'];
};

/** Autogenerated return type of CreateTeamDiscussionComment */
export type Github_CreateTeamDiscussionCommentPayload = {
  __typename?: 'Github_CreateTeamDiscussionCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new comment. */
  teamDiscussionComment?: Maybe<Github_TeamDiscussionComment>;
};

/** Autogenerated input type of CreateTeamDiscussion */
export type Github_CreateTeamDiscussionInput = {
  /** The content of the discussion. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /**
   * If true, restricts the visibility of this discussion to team members and
   * organization admins. If false or not specified, allows any organization member
   * to view this discussion.
   */
  private?: InputMaybe<Scalars['Boolean']>;
  /** The ID of the team to which the discussion belongs. */
  teamId: Scalars['ID'];
  /** The title of the discussion. */
  title: Scalars['String'];
};

/** Autogenerated return type of CreateTeamDiscussion */
export type Github_CreateTeamDiscussionPayload = {
  __typename?: 'Github_CreateTeamDiscussionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new discussion. */
  teamDiscussion?: Maybe<Github_TeamDiscussion>;
};

/** Represents the contribution a user made by committing to a repository. */
export type Github_CreatedCommitContribution = Github_Contribution & {
  __typename?: 'Github_CreatedCommitContribution';
  /** How many commits were made on this day to this repository by the user. */
  commitCount: Scalars['Int'];
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean'];
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime'];
  /** The repository the user made a commit in. */
  repository: Github_Repository;
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this contribution. */
  url: Scalars['Github_URI'];
  /** The user who made this contribution. */
  user: Github_User;
};

/** The connection type for CreatedCommitContribution. */
export type Github_CreatedCommitContributionConnection = {
  __typename?: 'Github_CreatedCommitContributionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_CreatedCommitContributionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_CreatedCommitContribution>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of commits across days and repositories in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_CreatedCommitContributionEdge = {
  __typename?: 'Github_CreatedCommitContributionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_CreatedCommitContribution>;
};

/** Represents the contribution a user made on GitHub by opening an issue. */
export type Github_CreatedIssueContribution = Github_Contribution & {
  __typename?: 'Github_CreatedIssueContribution';
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean'];
  /** The issue that was opened. */
  issue: Github_Issue;
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime'];
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this contribution. */
  url: Scalars['Github_URI'];
  /** The user who made this contribution. */
  user: Github_User;
};

/** The connection type for CreatedIssueContribution. */
export type Github_CreatedIssueContributionConnection = {
  __typename?: 'Github_CreatedIssueContributionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_CreatedIssueContributionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_CreatedIssueContribution>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_CreatedIssueContributionEdge = {
  __typename?: 'Github_CreatedIssueContributionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_CreatedIssueContribution>;
};

/** Represents either a issue the viewer can access or a restricted contribution. */
export type Github_CreatedIssueOrRestrictedContribution = Github_CreatedIssueContribution | Github_RestrictedContribution;

/** Represents the contribution a user made on GitHub by opening a pull request. */
export type Github_CreatedPullRequestContribution = Github_Contribution & {
  __typename?: 'Github_CreatedPullRequestContribution';
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean'];
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime'];
  /** The pull request that was opened. */
  pullRequest: Github_PullRequest;
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this contribution. */
  url: Scalars['Github_URI'];
  /** The user who made this contribution. */
  user: Github_User;
};

/** The connection type for CreatedPullRequestContribution. */
export type Github_CreatedPullRequestContributionConnection = {
  __typename?: 'Github_CreatedPullRequestContributionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_CreatedPullRequestContributionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_CreatedPullRequestContribution>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_CreatedPullRequestContributionEdge = {
  __typename?: 'Github_CreatedPullRequestContributionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_CreatedPullRequestContribution>;
};

/** Represents either a pull request the viewer can access or a restricted contribution. */
export type Github_CreatedPullRequestOrRestrictedContribution = Github_CreatedPullRequestContribution | Github_RestrictedContribution;

/** Represents the contribution a user made by leaving a review on a pull request. */
export type Github_CreatedPullRequestReviewContribution = Github_Contribution & {
  __typename?: 'Github_CreatedPullRequestReviewContribution';
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean'];
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime'];
  /** The pull request the user reviewed. */
  pullRequest: Github_PullRequest;
  /** The review the user left on the pull request. */
  pullRequestReview: Github_PullRequestReview;
  /** The repository containing the pull request that the user reviewed. */
  repository: Github_Repository;
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this contribution. */
  url: Scalars['Github_URI'];
  /** The user who made this contribution. */
  user: Github_User;
};

/** The connection type for CreatedPullRequestReviewContribution. */
export type Github_CreatedPullRequestReviewContributionConnection = {
  __typename?: 'Github_CreatedPullRequestReviewContributionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_CreatedPullRequestReviewContributionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_CreatedPullRequestReviewContribution>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_CreatedPullRequestReviewContributionEdge = {
  __typename?: 'Github_CreatedPullRequestReviewContributionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_CreatedPullRequestReviewContribution>;
};

/** Represents the contribution a user made on GitHub by creating a repository. */
export type Github_CreatedRepositoryContribution = Github_Contribution & {
  __typename?: 'Github_CreatedRepositoryContribution';
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean'];
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime'];
  /** The repository that was created. */
  repository: Github_Repository;
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this contribution. */
  url: Scalars['Github_URI'];
  /** The user who made this contribution. */
  user: Github_User;
};

/** The connection type for CreatedRepositoryContribution. */
export type Github_CreatedRepositoryContributionConnection = {
  __typename?: 'Github_CreatedRepositoryContributionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_CreatedRepositoryContributionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_CreatedRepositoryContribution>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_CreatedRepositoryContributionEdge = {
  __typename?: 'Github_CreatedRepositoryContributionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_CreatedRepositoryContribution>;
};

/** Represents either a repository the viewer can access or a restricted contribution. */
export type Github_CreatedRepositoryOrRestrictedContribution = Github_CreatedRepositoryContribution | Github_RestrictedContribution;

/** Represents a mention made by one issue or pull request to another. */
export type Github_CrossReferencedEvent = Github_Node & Github_UniformResourceLocatable & {
  __typename?: 'Github_CrossReferencedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Reference originated in a different repository. */
  isCrossRepository: Scalars['Boolean'];
  /** Identifies when the reference was made. */
  referencedAt: Scalars['DateTime'];
  /** The HTTP path for this pull request. */
  resourcePath: Scalars['Github_URI'];
  /** Issue or pull request that made the reference. */
  source: Github_ReferencedSubject;
  /** Issue or pull request to which the reference was made. */
  target: Github_ReferencedSubject;
  /** The HTTP URL for this pull request. */
  url: Scalars['Github_URI'];
  /** Checks if the target will be closed when the source is merged. */
  willCloseTarget: Scalars['Boolean'];
};

/** Autogenerated input type of DeclineTopicSuggestion */
export type Github_DeclineTopicSuggestionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The name of the suggested topic. */
  name: Scalars['String'];
  /** The reason why the suggested topic is declined. */
  reason: Github_TopicSuggestionDeclineReason;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of DeclineTopicSuggestion */
export type Github_DeclineTopicSuggestionPayload = {
  __typename?: 'Github_DeclineTopicSuggestionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The declined topic. */
  topic?: Maybe<Github_Topic>;
};

/** The possible base permissions for repositories. */
export enum Github_DefaultRepositoryPermissionField {
  /** Can read, write, and administrate repos by default */
  Admin = 'ADMIN',
  /** No access */
  None = 'NONE',
  /** Can read repos by default */
  Read = 'READ',
  /** Can read and write repos by default */
  Write = 'WRITE'
}

/** Entities that can be deleted. */
export type Github_Deletable = {
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'];
};

/** Github_Deletable mock concrete type. */
export type Github_Deletable__Mock = Github_Deletable & {
  __typename?: 'Github_Deletable__Mock';
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'];
};

/** Autogenerated input type of DeleteBranchProtectionRule */
export type Github_DeleteBranchProtectionRuleInput = {
  /** The global relay id of the branch protection rule to be deleted. */
  branchProtectionRuleId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of DeleteBranchProtectionRule */
export type Github_DeleteBranchProtectionRulePayload = {
  __typename?: 'Github_DeleteBranchProtectionRulePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteDeployment */
export type Github_DeleteDeploymentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the deployment to be deleted. */
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteDeployment */
export type Github_DeleteDeploymentPayload = {
  __typename?: 'Github_DeleteDeploymentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteDiscussionComment */
export type Github_DeleteDiscussionCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node id of the discussion comment to delete. */
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteDiscussionComment */
export type Github_DeleteDiscussionCommentPayload = {
  __typename?: 'Github_DeleteDiscussionCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The discussion comment that was just deleted. */
  comment?: Maybe<Github_DiscussionComment>;
};

/** Autogenerated input type of DeleteDiscussion */
export type Github_DeleteDiscussionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The id of the discussion to delete. */
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteDiscussion */
export type Github_DeleteDiscussionPayload = {
  __typename?: 'Github_DeleteDiscussionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The discussion that was just deleted. */
  discussion?: Maybe<Github_Discussion>;
};

/** Autogenerated input type of DeleteEnvironment */
export type Github_DeleteEnvironmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the environment to be deleted. */
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteEnvironment */
export type Github_DeleteEnvironmentPayload = {
  __typename?: 'Github_DeleteEnvironmentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteIpAllowListEntry */
export type Github_DeleteIpAllowListEntryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the IP allow list entry to delete. */
  ipAllowListEntryId: Scalars['ID'];
};

/** Autogenerated return type of DeleteIpAllowListEntry */
export type Github_DeleteIpAllowListEntryPayload = {
  __typename?: 'Github_DeleteIpAllowListEntryPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The IP allow list entry that was deleted. */
  ipAllowListEntry?: Maybe<Github_IpAllowListEntry>;
};

/** Autogenerated input type of DeleteIssueComment */
export type Github_DeleteIssueCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the comment to delete. */
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteIssueComment */
export type Github_DeleteIssueCommentPayload = {
  __typename?: 'Github_DeleteIssueCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteIssue */
export type Github_DeleteIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the issue to delete. */
  issueId: Scalars['ID'];
};

/** Autogenerated return type of DeleteIssue */
export type Github_DeleteIssuePayload = {
  __typename?: 'Github_DeleteIssuePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The repository the issue belonged to */
  repository?: Maybe<Github_Repository>;
};

/** Autogenerated input type of DeleteLabel */
export type Github_DeleteLabelInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the label to be deleted. */
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteLabel */
export type Github_DeleteLabelPayload = {
  __typename?: 'Github_DeleteLabelPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeletePackageVersion */
export type Github_DeletePackageVersionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the package version to be deleted. */
  packageVersionId: Scalars['ID'];
};

/** Autogenerated return type of DeletePackageVersion */
export type Github_DeletePackageVersionPayload = {
  __typename?: 'Github_DeletePackageVersionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Whether or not the operation succeeded. */
  success?: Maybe<Scalars['Boolean']>;
};

/** Autogenerated input type of DeleteProjectCard */
export type Github_DeleteProjectCardInput = {
  /** The id of the card to delete. */
  cardId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of DeleteProjectCard */
export type Github_DeleteProjectCardPayload = {
  __typename?: 'Github_DeleteProjectCardPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The column the deleted card was in. */
  column?: Maybe<Github_ProjectColumn>;
  /** The deleted card ID. */
  deletedCardId?: Maybe<Scalars['ID']>;
};

/** Autogenerated input type of DeleteProjectColumn */
export type Github_DeleteProjectColumnInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The id of the column to delete. */
  columnId: Scalars['ID'];
};

/** Autogenerated return type of DeleteProjectColumn */
export type Github_DeleteProjectColumnPayload = {
  __typename?: 'Github_DeleteProjectColumnPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The deleted column ID. */
  deletedColumnId?: Maybe<Scalars['ID']>;
  /** The project the deleted column was in. */
  project?: Maybe<Github_Project>;
};

/** Autogenerated input type of DeleteProject */
export type Github_DeleteProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Project ID to update. */
  projectId: Scalars['ID'];
};

/** Autogenerated input type of DeleteProjectNextItem */
export type Github_DeleteProjectNextItemInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the item to be removed. */
  itemId: Scalars['ID'];
  /** The ID of the Project from which the item should be removed. */
  projectId: Scalars['ID'];
};

/** Autogenerated return type of DeleteProjectNextItem */
export type Github_DeleteProjectNextItemPayload = {
  __typename?: 'Github_DeleteProjectNextItemPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the deleted item. */
  deletedItemId?: Maybe<Scalars['ID']>;
};

/** Autogenerated return type of DeleteProject */
export type Github_DeleteProjectPayload = {
  __typename?: 'Github_DeleteProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The repository or organization the project was removed from. */
  owner?: Maybe<Github_ProjectOwner>;
};

/** Autogenerated input type of DeletePullRequestReviewComment */
export type Github_DeletePullRequestReviewCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the comment to delete. */
  id: Scalars['ID'];
};

/** Autogenerated return type of DeletePullRequestReviewComment */
export type Github_DeletePullRequestReviewCommentPayload = {
  __typename?: 'Github_DeletePullRequestReviewCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The pull request review the deleted comment belonged to. */
  pullRequestReview?: Maybe<Github_PullRequestReview>;
};

/** Autogenerated input type of DeletePullRequestReview */
export type Github_DeletePullRequestReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the pull request review to delete. */
  pullRequestReviewId: Scalars['ID'];
};

/** Autogenerated return type of DeletePullRequestReview */
export type Github_DeletePullRequestReviewPayload = {
  __typename?: 'Github_DeletePullRequestReviewPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The deleted pull request review. */
  pullRequestReview?: Maybe<Github_PullRequestReview>;
};

/** Autogenerated input type of DeleteRef */
export type Github_DeleteRefInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the Ref to be deleted. */
  refId: Scalars['ID'];
};

/** Autogenerated return type of DeleteRef */
export type Github_DeleteRefPayload = {
  __typename?: 'Github_DeleteRefPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteTeamDiscussionComment */
export type Github_DeleteTeamDiscussionCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the comment to delete. */
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteTeamDiscussionComment */
export type Github_DeleteTeamDiscussionCommentPayload = {
  __typename?: 'Github_DeleteTeamDiscussionCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteTeamDiscussion */
export type Github_DeleteTeamDiscussionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The discussion ID to delete. */
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteTeamDiscussion */
export type Github_DeleteTeamDiscussionPayload = {
  __typename?: 'Github_DeleteTeamDiscussionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of DeleteVerifiableDomain */
export type Github_DeleteVerifiableDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the verifiable domain to delete. */
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteVerifiableDomain */
export type Github_DeleteVerifiableDomainPayload = {
  __typename?: 'Github_DeleteVerifiableDomainPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The owning account from which the domain was deleted. */
  owner?: Maybe<Github_VerifiableDomainOwner>;
};

/** Represents a 'demilestoned' event on a given issue or pull request. */
export type Github_DemilestonedEvent = Github_Node & {
  __typename?: 'Github_DemilestonedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Identifies the milestone title associated with the 'demilestoned' event. */
  milestoneTitle: Scalars['String'];
  /** Object referenced by event. */
  subject: Github_MilestoneItem;
};

/** A dependency manifest entry */
export type Github_DependencyGraphDependency = {
  __typename?: 'Github_DependencyGraphDependency';
  /** Does the dependency itself have dependencies? */
  hasDependencies: Scalars['Boolean'];
  /** The original name of the package, as it appears in the manifest. */
  packageLabel: Scalars['String'];
  /** The dependency package manager */
  packageManager?: Maybe<Scalars['String']>;
  /**
   * The name of the package in the canonical form used by the package manager.
   * This may differ from the original textual form (see packageLabel), for example
   * in a package manager that uses case-insensitive comparisons.
   */
  packageName: Scalars['String'];
  /** The repository containing the package */
  repository?: Maybe<Github_Repository>;
  /** The dependency version requirements */
  requirements: Scalars['String'];
};

/** The connection type for DependencyGraphDependency. */
export type Github_DependencyGraphDependencyConnection = {
  __typename?: 'Github_DependencyGraphDependencyConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_DependencyGraphDependencyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_DependencyGraphDependency>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_DependencyGraphDependencyEdge = {
  __typename?: 'Github_DependencyGraphDependencyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_DependencyGraphDependency>;
};

/** Dependency manifest for a repository */
export type Github_DependencyGraphManifest = Github_Node & {
  __typename?: 'Github_DependencyGraphManifest';
  /** Path to view the manifest file blob */
  blobPath: Scalars['String'];
  /** A list of manifest dependencies */
  dependencies?: Maybe<Github_DependencyGraphDependencyConnection>;
  /** The number of dependencies listed in the manifest */
  dependenciesCount?: Maybe<Scalars['Int']>;
  /** Is the manifest too big to parse? */
  exceedsMaxSize: Scalars['Boolean'];
  /** Fully qualified manifest filename */
  filename: Scalars['String'];
  id: Scalars['ID'];
  /** Were we able to parse the manifest? */
  parseable: Scalars['Boolean'];
  /** The repository containing the manifest */
  repository: Github_Repository;
};


/** Dependency manifest for a repository */
export type Github_DependencyGraphManifestDependenciesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for DependencyGraphManifest. */
export type Github_DependencyGraphManifestConnection = {
  __typename?: 'Github_DependencyGraphManifestConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_DependencyGraphManifestEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_DependencyGraphManifest>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_DependencyGraphManifestEdge = {
  __typename?: 'Github_DependencyGraphManifestEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_DependencyGraphManifest>;
};

/** A repository deploy key. */
export type Github_DeployKey = Github_Node & {
  __typename?: 'Github_DeployKey';
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** The deploy key. */
  key: Scalars['String'];
  /** Whether or not the deploy key is read only. */
  readOnly: Scalars['Boolean'];
  /** The deploy key title. */
  title: Scalars['String'];
  /** Whether or not the deploy key has been verified. */
  verified: Scalars['Boolean'];
};

/** The connection type for DeployKey. */
export type Github_DeployKeyConnection = {
  __typename?: 'Github_DeployKeyConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_DeployKeyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_DeployKey>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_DeployKeyEdge = {
  __typename?: 'Github_DeployKeyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_DeployKey>;
};

/** Represents a 'deployed' event on a given pull request. */
export type Github_DeployedEvent = Github_Node & {
  __typename?: 'Github_DeployedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The deployment associated with the 'deployed' event. */
  deployment: Github_Deployment;
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest: Github_PullRequest;
  /** The ref associated with the 'deployed' event. */
  ref?: Maybe<Github_Ref>;
};

/** Represents triggered deployment instance. */
export type Github_Deployment = Github_Node & {
  __typename?: 'Github_Deployment';
  /** Identifies the commit sha of the deployment. */
  commit?: Maybe<Github_Commit>;
  /** Identifies the oid of the deployment commit, even if the commit has been deleted. */
  commitOid: Scalars['String'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the actor who triggered the deployment. */
  creator: Github_Actor;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The deployment description. */
  description?: Maybe<Scalars['String']>;
  /** The latest environment to which this deployment was made. */
  environment?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The latest environment to which this deployment was made. */
  latestEnvironment?: Maybe<Scalars['String']>;
  /** The latest status of this deployment. */
  latestStatus?: Maybe<Github_DeploymentStatus>;
  /** The original environment to which this deployment was made. */
  originalEnvironment?: Maybe<Scalars['String']>;
  /** Extra information that a deployment system might need. */
  payload?: Maybe<Scalars['String']>;
  /** Identifies the Ref of the deployment, if the deployment was created by ref. */
  ref?: Maybe<Github_Ref>;
  /** Identifies the repository associated with the deployment. */
  repository: Github_Repository;
  /** The current state of the deployment. */
  state?: Maybe<Github_DeploymentState>;
  /** A list of statuses associated with the deployment. */
  statuses?: Maybe<Github_DeploymentStatusConnection>;
  /** The deployment task. */
  task?: Maybe<Scalars['String']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};


/** Represents triggered deployment instance. */
export type Github_DeploymentStatusesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for Deployment. */
export type Github_DeploymentConnection = {
  __typename?: 'Github_DeploymentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_DeploymentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Deployment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_DeploymentEdge = {
  __typename?: 'Github_DeploymentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Deployment>;
};

/** Represents a 'deployment_environment_changed' event on a given pull request. */
export type Github_DeploymentEnvironmentChangedEvent = Github_Node & {
  __typename?: 'Github_DeploymentEnvironmentChangedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The deployment status that updated the deployment environment. */
  deploymentStatus: Github_DeploymentStatus;
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest: Github_PullRequest;
};

/** Ordering options for deployment connections */
export type Github_DeploymentOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order deployments by. */
  field: Github_DeploymentOrderField;
};

/** Properties by which deployment connections can be ordered. */
export enum Github_DeploymentOrderField {
  /** Order collection by creation time */
  CreatedAt = 'CREATED_AT'
}

/** A protection rule. */
export type Github_DeploymentProtectionRule = {
  __typename?: 'Github_DeploymentProtectionRule';
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The teams or users that can review the deployment */
  reviewers: Github_DeploymentReviewerConnection;
  /** The timeout in minutes for this protection rule. */
  timeout: Scalars['Int'];
  /** The type of protection rule. */
  type: Github_DeploymentProtectionRuleType;
};


/** A protection rule. */
export type Github_DeploymentProtectionRuleReviewersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for DeploymentProtectionRule. */
export type Github_DeploymentProtectionRuleConnection = {
  __typename?: 'Github_DeploymentProtectionRuleConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_DeploymentProtectionRuleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_DeploymentProtectionRule>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_DeploymentProtectionRuleEdge = {
  __typename?: 'Github_DeploymentProtectionRuleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_DeploymentProtectionRule>;
};

/** The possible protection rule types. */
export enum Github_DeploymentProtectionRuleType {
  /** Required reviewers */
  RequiredReviewers = 'REQUIRED_REVIEWERS',
  /** Wait timer */
  WaitTimer = 'WAIT_TIMER'
}

/** A request to deploy a workflow run to an environment. */
export type Github_DeploymentRequest = {
  __typename?: 'Github_DeploymentRequest';
  /** Whether or not the current user can approve the deployment */
  currentUserCanApprove: Scalars['Boolean'];
  /** The target environment of the deployment */
  environment: Github_Environment;
  /** The teams or users that can review the deployment */
  reviewers: Github_DeploymentReviewerConnection;
  /** The wait timer in minutes configured in the environment */
  waitTimer: Scalars['Int'];
  /** The wait timer in minutes configured in the environment */
  waitTimerStartedAt?: Maybe<Scalars['DateTime']>;
};


/** A request to deploy a workflow run to an environment. */
export type Github_DeploymentRequestReviewersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for DeploymentRequest. */
export type Github_DeploymentRequestConnection = {
  __typename?: 'Github_DeploymentRequestConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_DeploymentRequestEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_DeploymentRequest>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_DeploymentRequestEdge = {
  __typename?: 'Github_DeploymentRequestEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_DeploymentRequest>;
};

/** A deployment review. */
export type Github_DeploymentReview = Github_Node & {
  __typename?: 'Github_DeploymentReview';
  /** The comment the user left. */
  comment: Scalars['String'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The environments approved or rejected */
  environments: Github_EnvironmentConnection;
  id: Scalars['ID'];
  /** The decision of the user. */
  state: Github_DeploymentReviewState;
  /** The user that reviewed the deployment. */
  user: Github_User;
};


/** A deployment review. */
export type Github_DeploymentReviewEnvironmentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for DeploymentReview. */
export type Github_DeploymentReviewConnection = {
  __typename?: 'Github_DeploymentReviewConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_DeploymentReviewEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_DeploymentReview>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_DeploymentReviewEdge = {
  __typename?: 'Github_DeploymentReviewEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_DeploymentReview>;
};

/** The possible states for a deployment review. */
export enum Github_DeploymentReviewState {
  /** The deployment was approved. */
  Approved = 'APPROVED',
  /** The deployment was rejected. */
  Rejected = 'REJECTED'
}

/** Users and teams. */
export type Github_DeploymentReviewer = Github_Team | Github_User;

/** The connection type for DeploymentReviewer. */
export type Github_DeploymentReviewerConnection = {
  __typename?: 'Github_DeploymentReviewerConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_DeploymentReviewerEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_DeploymentReviewer>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_DeploymentReviewerEdge = {
  __typename?: 'Github_DeploymentReviewerEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_DeploymentReviewer>;
};

/** The possible states in which a deployment can be. */
export enum Github_DeploymentState {
  /** The pending deployment was not updated after 30 minutes. */
  Abandoned = 'ABANDONED',
  /** The deployment is currently active. */
  Active = 'ACTIVE',
  /** An inactive transient deployment. */
  Destroyed = 'DESTROYED',
  /** The deployment experienced an error. */
  Error = 'ERROR',
  /** The deployment has failed. */
  Failure = 'FAILURE',
  /** The deployment is inactive. */
  Inactive = 'INACTIVE',
  /** The deployment is in progress. */
  InProgress = 'IN_PROGRESS',
  /** The deployment is pending. */
  Pending = 'PENDING',
  /** The deployment has queued */
  Queued = 'QUEUED',
  /** The deployment is waiting. */
  Waiting = 'WAITING'
}

/** Describes the status of a given deployment attempt. */
export type Github_DeploymentStatus = Github_Node & {
  __typename?: 'Github_DeploymentStatus';
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the actor who triggered the deployment. */
  creator: Github_Actor;
  /** Identifies the deployment associated with status. */
  deployment: Github_Deployment;
  /** Identifies the description of the deployment. */
  description?: Maybe<Scalars['String']>;
  /** Identifies the environment of the deployment at the time of this deployment status */
  environment?: Maybe<Scalars['String']>;
  /** Identifies the environment URL of the deployment. */
  environmentUrl?: Maybe<Scalars['Github_URI']>;
  id: Scalars['ID'];
  /** Identifies the log URL of the deployment. */
  logUrl?: Maybe<Scalars['Github_URI']>;
  /** Identifies the current state of the deployment. */
  state: Github_DeploymentStatusState;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** The connection type for DeploymentStatus. */
export type Github_DeploymentStatusConnection = {
  __typename?: 'Github_DeploymentStatusConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_DeploymentStatusEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_DeploymentStatus>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_DeploymentStatusEdge = {
  __typename?: 'Github_DeploymentStatusEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_DeploymentStatus>;
};

/** The possible states for a deployment status. */
export enum Github_DeploymentStatusState {
  /** The deployment experienced an error. */
  Error = 'ERROR',
  /** The deployment has failed. */
  Failure = 'FAILURE',
  /** The deployment is inactive. */
  Inactive = 'INACTIVE',
  /** The deployment is in progress. */
  InProgress = 'IN_PROGRESS',
  /** The deployment is pending. */
  Pending = 'PENDING',
  /** The deployment is queued */
  Queued = 'QUEUED',
  /** The deployment was successful. */
  Success = 'SUCCESS',
  /** The deployment is waiting. */
  Waiting = 'WAITING'
}

/** The possible sides of a diff. */
export enum Github_DiffSide {
  /** The left side of the diff. */
  Left = 'LEFT',
  /** The right side of the diff. */
  Right = 'RIGHT'
}

/** Autogenerated input type of DisablePullRequestAutoMerge */
export type Github_DisablePullRequestAutoMergeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the pull request to disable auto merge on. */
  pullRequestId: Scalars['ID'];
};

/** Autogenerated return type of DisablePullRequestAutoMerge */
export type Github_DisablePullRequestAutoMergePayload = {
  __typename?: 'Github_DisablePullRequestAutoMergePayload';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The pull request auto merge was disabled on. */
  pullRequest?: Maybe<Github_PullRequest>;
};

/** Represents a 'disconnected' event on a given issue or pull request. */
export type Github_DisconnectedEvent = Github_Node & {
  __typename?: 'Github_DisconnectedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Reference originated in a different repository. */
  isCrossRepository: Scalars['Boolean'];
  /** Issue or pull request from which the issue was disconnected. */
  source: Github_ReferencedSubject;
  /** Issue or pull request which was disconnected. */
  subject: Github_ReferencedSubject;
};

/** A discussion in a repository. */
export type Github_Discussion = Github_Comment & Github_Deletable & Github_Labelable & Github_Lockable & Github_Node & Github_Reactable & Github_RepositoryNode & Github_Subscribable & Github_Updatable & Github_Votable & {
  __typename?: 'Github_Discussion';
  /** Reason that the conversation was locked. */
  activeLockReason?: Maybe<Github_LockReason>;
  /** The comment chosen as this discussion's answer, if any. */
  answer?: Maybe<Github_DiscussionComment>;
  /** The time when a user chose this discussion's answer, if answered. */
  answerChosenAt?: Maybe<Scalars['DateTime']>;
  /** The user who chose this discussion's answer, if answered. */
  answerChosenBy?: Maybe<Github_Actor>;
  /** The actor who authored the comment. */
  author?: Maybe<Github_Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: Github_CommentAuthorAssociation;
  /** The main text of the discussion post. */
  body: Scalars['String'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['Github_HTML'];
  /** The body rendered to text. */
  bodyText: Scalars['String'];
  /** The category for this discussion. */
  category: Github_DiscussionCategory;
  /** The replies to the discussion. */
  comments: Github_DiscussionCommentConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The actor who edited the comment. */
  editor?: Maybe<Github_Actor>;
  id: Scalars['ID'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'];
  /** A list of labels associated with the object. */
  labels?: Maybe<Github_LabelConnection>;
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>;
  /** `true` if the object is locked */
  locked: Scalars['Boolean'];
  /** The number identifying this discussion within the repository. */
  number: Scalars['Int'];
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<Github_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: Github_ReactionConnection;
  /** The repository associated with this node. */
  repository: Github_Repository;
  /** The path for this discussion. */
  resourcePath: Scalars['Github_URI'];
  /** The title of this discussion. */
  title: Scalars['String'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** Number of upvotes that this subject has received. */
  upvoteCount: Scalars['Int'];
  /** The URL for this discussion. */
  url: Scalars['Github_URI'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<Github_UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
  /** Whether or not the current user can add or remove an upvote on this subject. */
  viewerCanUpvote: Scalars['Boolean'];
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'];
  /** Whether or not the current user has already upvoted this subject. */
  viewerHasUpvoted: Scalars['Boolean'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<Github_SubscriptionState>;
};


/** A discussion in a repository. */
export type Github_DiscussionCommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A discussion in a repository. */
export type Github_DiscussionLabelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_LabelOrder>;
};


/** A discussion in a repository. */
export type Github_DiscussionReactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Github_ReactionContent>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ReactionOrder>;
};


/** A discussion in a repository. */
export type Github_DiscussionUserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** A category for discussions in a repository. */
export type Github_DiscussionCategory = Github_Node & Github_RepositoryNode & {
  __typename?: 'Github_DiscussionCategory';
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** A description of this category. */
  description?: Maybe<Scalars['String']>;
  /** An emoji representing this category. */
  emoji: Scalars['String'];
  /** This category's emoji rendered as HTML. */
  emojiHTML: Scalars['Github_HTML'];
  id: Scalars['ID'];
  /** Whether or not discussions in this category support choosing an answer with the markDiscussionCommentAsAnswer mutation. */
  isAnswerable: Scalars['Boolean'];
  /** The name of this category. */
  name: Scalars['String'];
  /** The repository associated with this node. */
  repository: Github_Repository;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** The connection type for DiscussionCategory. */
export type Github_DiscussionCategoryConnection = {
  __typename?: 'Github_DiscussionCategoryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_DiscussionCategoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_DiscussionCategory>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_DiscussionCategoryEdge = {
  __typename?: 'Github_DiscussionCategoryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_DiscussionCategory>;
};

/** A comment on a discussion. */
export type Github_DiscussionComment = Github_Comment & Github_Deletable & Github_Minimizable & Github_Node & Github_Reactable & Github_Updatable & Github_UpdatableComment & Github_Votable & {
  __typename?: 'Github_DiscussionComment';
  /** The actor who authored the comment. */
  author?: Maybe<Github_Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: Github_CommentAuthorAssociation;
  /** The body as Markdown. */
  body: Scalars['String'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['Github_HTML'];
  /** The body rendered to text. */
  bodyText: Scalars['String'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The time when this replied-to comment was deleted */
  deletedAt?: Maybe<Scalars['DateTime']>;
  /** The discussion this comment was created in */
  discussion?: Maybe<Github_Discussion>;
  /** The actor who edited the comment. */
  editor?: Maybe<Github_Actor>;
  id: Scalars['ID'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'];
  /** Has this comment been chosen as the answer of its discussion? */
  isAnswer: Scalars['Boolean'];
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars['Boolean'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>;
  /** Returns why the comment was minimized. */
  minimizedReason?: Maybe<Scalars['String']>;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<Github_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: Github_ReactionConnection;
  /** The threaded replies to this comment. */
  replies: Github_DiscussionCommentConnection;
  /** The discussion comment this comment is a reply to */
  replyTo?: Maybe<Github_DiscussionComment>;
  /** The path for this discussion comment. */
  resourcePath: Scalars['Github_URI'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** Number of upvotes that this subject has received. */
  upvoteCount: Scalars['Int'];
  /** The URL for this discussion comment. */
  url: Scalars['Github_URI'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<Github_UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'];
  /** Can the current user mark this comment as an answer? */
  viewerCanMarkAsAnswer: Scalars['Boolean'];
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars['Boolean'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'];
  /** Can the current user unmark this comment as an answer? */
  viewerCanUnmarkAsAnswer: Scalars['Boolean'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
  /** Whether or not the current user can add or remove an upvote on this subject. */
  viewerCanUpvote: Scalars['Boolean'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<Github_CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'];
  /** Whether or not the current user has already upvoted this subject. */
  viewerHasUpvoted: Scalars['Boolean'];
};


/** A comment on a discussion. */
export type Github_DiscussionCommentReactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Github_ReactionContent>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ReactionOrder>;
};


/** A comment on a discussion. */
export type Github_DiscussionCommentRepliesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A comment on a discussion. */
export type Github_DiscussionCommentUserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for DiscussionComment. */
export type Github_DiscussionCommentConnection = {
  __typename?: 'Github_DiscussionCommentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_DiscussionCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_DiscussionComment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_DiscussionCommentEdge = {
  __typename?: 'Github_DiscussionCommentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_DiscussionComment>;
};

/** The connection type for Discussion. */
export type Github_DiscussionConnection = {
  __typename?: 'Github_DiscussionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_DiscussionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Discussion>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_DiscussionEdge = {
  __typename?: 'Github_DiscussionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Discussion>;
};

/** Ways in which lists of discussions can be ordered upon return. */
export type Github_DiscussionOrder = {
  /** The direction in which to order discussions by the specified field. */
  direction: Github_OrderDirection;
  /** The field by which to order discussions. */
  field: Github_DiscussionOrderField;
};

/** Properties by which discussion connections can be ordered. */
export enum Github_DiscussionOrderField {
  /** Order discussions by creation time. */
  CreatedAt = 'CREATED_AT',
  /** Order discussions by most recent modification time. */
  UpdatedAt = 'UPDATED_AT'
}

/** Autogenerated input type of DismissPullRequestReview */
export type Github_DismissPullRequestReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The contents of the pull request review dismissal message. */
  message: Scalars['String'];
  /** The Node ID of the pull request review to modify. */
  pullRequestReviewId: Scalars['ID'];
};

/** Autogenerated return type of DismissPullRequestReview */
export type Github_DismissPullRequestReviewPayload = {
  __typename?: 'Github_DismissPullRequestReviewPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The dismissed pull request review. */
  pullRequestReview?: Maybe<Github_PullRequestReview>;
};

/** The possible reasons that a Dependabot alert was dismissed. */
export enum Github_DismissReason {
  /** A fix has already been started */
  FixStarted = 'FIX_STARTED',
  /** This alert is inaccurate or incorrect */
  Inaccurate = 'INACCURATE',
  /** Vulnerable code is not actually used */
  NotUsed = 'NOT_USED',
  /** No bandwidth to fix this */
  NoBandwidth = 'NO_BANDWIDTH',
  /** Risk is tolerable to this project */
  TolerableRisk = 'TOLERABLE_RISK'
}

/** Autogenerated input type of DismissRepositoryVulnerabilityAlert */
export type Github_DismissRepositoryVulnerabilityAlertInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The reason the Dependabot alert is being dismissed. */
  dismissReason: Github_DismissReason;
  /** The Dependabot alert ID to dismiss. */
  repositoryVulnerabilityAlertId: Scalars['ID'];
};

/** Autogenerated return type of DismissRepositoryVulnerabilityAlert */
export type Github_DismissRepositoryVulnerabilityAlertPayload = {
  __typename?: 'Github_DismissRepositoryVulnerabilityAlertPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Dependabot alert that was dismissed */
  repositoryVulnerabilityAlert?: Maybe<Github_RepositoryVulnerabilityAlert>;
};

/** Specifies a review comment to be left with a Pull Request Review. */
export type Github_DraftPullRequestReviewComment = {
  /** Body of the comment to leave. */
  body: Scalars['String'];
  /** Path to the file being commented on. */
  path: Scalars['String'];
  /** Position in the file to leave a comment on. */
  position: Scalars['Int'];
};

/** Specifies a review comment thread to be left with a Pull Request Review. */
export type Github_DraftPullRequestReviewThread = {
  /** Body of the comment to leave. */
  body: Scalars['String'];
  /** The line of the blob to which the thread refers. The end of the line range for multi-line comments. */
  line: Scalars['Int'];
  /** Path to the file being commented on. */
  path: Scalars['String'];
  /** The side of the diff on which the line resides. For multi-line comments, this is the side for the end of the line range. */
  side?: InputMaybe<Github_DiffSide>;
  /** The first line of the range to which the comment refers. */
  startLine?: InputMaybe<Scalars['Int']>;
  /** The side of the diff on which the start line resides. */
  startSide?: InputMaybe<Github_DiffSide>;
};

/** Autogenerated input type of EnablePullRequestAutoMerge */
export type Github_EnablePullRequestAutoMergeInput = {
  /** The email address to associate with this merge. */
  authorEmail?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Commit body to use for the commit when the PR is mergable; if omitted, a default message will be used. */
  commitBody?: InputMaybe<Scalars['String']>;
  /** Commit headline to use for the commit when the PR is mergable; if omitted, a default message will be used. */
  commitHeadline?: InputMaybe<Scalars['String']>;
  /** The merge method to use. If omitted, defaults to 'MERGE' */
  mergeMethod?: InputMaybe<Github_PullRequestMergeMethod>;
  /** ID of the pull request to enable auto-merge on. */
  pullRequestId: Scalars['ID'];
};

/** Autogenerated return type of EnablePullRequestAutoMerge */
export type Github_EnablePullRequestAutoMergePayload = {
  __typename?: 'Github_EnablePullRequestAutoMergePayload';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The pull request auto-merge was enabled on. */
  pullRequest?: Maybe<Github_PullRequest>;
};

/** An account to manage multiple organizations with consolidated policy and billing. */
export type Github_Enterprise = Github_Node & {
  __typename?: 'Github_Enterprise';
  /** A URL pointing to the enterprise's public avatar. */
  avatarUrl: Scalars['Github_URI'];
  /** Enterprise billing informationvisible to enterprise billing managers. */
  billingInfo?: Maybe<Github_EnterpriseBillingInfo>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The description of the enterprise. */
  description?: Maybe<Scalars['String']>;
  /** The description of the enterprise as HTML. */
  descriptionHTML: Scalars['Github_HTML'];
  id: Scalars['ID'];
  /** The location of the enterprise. */
  location?: Maybe<Scalars['String']>;
  /** A list of users who are members of this enterprise. */
  members: Github_EnterpriseMemberConnection;
  /** The name of the enterprise. */
  name: Scalars['String'];
  /** A list of organizations that belong to this enterprise. */
  organizations: Github_OrganizationConnection;
  /** Enterprise information only visible to enterprise owners. */
  ownerInfo?: Maybe<Github_EnterpriseOwnerInfo>;
  /** The HTTP path for this enterprise. */
  resourcePath: Scalars['Github_URI'];
  /** The URL-friendly identifier for the enterprise. */
  slug: Scalars['String'];
  /** The HTTP URL for this enterprise. */
  url: Scalars['Github_URI'];
  /** A list of user accounts on this enterprise. */
  userAccounts: Github_EnterpriseUserAccountConnection;
  /** Is the current viewer an admin of this enterprise? */
  viewerIsAdmin: Scalars['Boolean'];
  /** The URL of the enterprise website. */
  websiteUrl?: Maybe<Scalars['Github_URI']>;
};


/** An account to manage multiple organizations with consolidated policy and billing. */
export type Github_EnterpriseAvatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']>;
};


/** An account to manage multiple organizations with consolidated policy and billing. */
export type Github_EnterpriseMembersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  deployment?: InputMaybe<Github_EnterpriseUserDeployment>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_EnterpriseMemberOrder>;
  organizationLogins?: InputMaybe<Array<Scalars['String']>>;
  query?: InputMaybe<Scalars['String']>;
  role?: InputMaybe<Github_EnterpriseUserAccountMembershipRole>;
};


/** An account to manage multiple organizations with consolidated policy and billing. */
export type Github_EnterpriseOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_OrganizationOrder>;
  query?: InputMaybe<Scalars['String']>;
  viewerOrganizationRole?: InputMaybe<Github_RoleInOrganization>;
};


/** An account to manage multiple organizations with consolidated policy and billing. */
export type Github_EnterpriseUserAccountsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for User. */
export type Github_EnterpriseAdministratorConnection = {
  __typename?: 'Github_EnterpriseAdministratorConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_EnterpriseAdministratorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** A User who is an administrator of an enterprise. */
export type Github_EnterpriseAdministratorEdge = {
  __typename?: 'Github_EnterpriseAdministratorEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_User>;
  /** The role of the administrator. */
  role: Github_EnterpriseAdministratorRole;
};

/** An invitation for a user to become an owner or billing manager of an enterprise. */
export type Github_EnterpriseAdministratorInvitation = Github_Node & {
  __typename?: 'Github_EnterpriseAdministratorInvitation';
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The email of the person who was invited to the enterprise. */
  email?: Maybe<Scalars['String']>;
  /** The enterprise the invitation is for. */
  enterprise: Github_Enterprise;
  id: Scalars['ID'];
  /** The user who was invited to the enterprise. */
  invitee?: Maybe<Github_User>;
  /** The user who created the invitation. */
  inviter?: Maybe<Github_User>;
  /** The invitee's pending role in the enterprise (owner or billing_manager). */
  role: Github_EnterpriseAdministratorRole;
};

/** The connection type for EnterpriseAdministratorInvitation. */
export type Github_EnterpriseAdministratorInvitationConnection = {
  __typename?: 'Github_EnterpriseAdministratorInvitationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_EnterpriseAdministratorInvitationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_EnterpriseAdministratorInvitation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_EnterpriseAdministratorInvitationEdge = {
  __typename?: 'Github_EnterpriseAdministratorInvitationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_EnterpriseAdministratorInvitation>;
};

/** Ordering options for enterprise administrator invitation connections */
export type Github_EnterpriseAdministratorInvitationOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order enterprise administrator invitations by. */
  field: Github_EnterpriseAdministratorInvitationOrderField;
};

/** Properties by which enterprise administrator invitation connections can be ordered. */
export enum Github_EnterpriseAdministratorInvitationOrderField {
  /** Order enterprise administrator member invitations by creation time */
  CreatedAt = 'CREATED_AT'
}

/** The possible administrator roles in an enterprise account. */
export enum Github_EnterpriseAdministratorRole {
  /** Represents a billing manager of the enterprise account. */
  BillingManager = 'BILLING_MANAGER',
  /** Represents an owner of the enterprise account. */
  Owner = 'OWNER'
}

/** Metadata for an audit entry containing enterprise account information. */
export type Github_EnterpriseAuditEntryData = {
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['Github_URI']>;
};

/** Github_EnterpriseAuditEntryData mock concrete type. */
export type Github_EnterpriseAuditEntryData__Mock = Github_EnterpriseAuditEntryData & {
  __typename?: 'Github_EnterpriseAuditEntryData__Mock';
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['Github_URI']>;
};

/** Enterprise billing information visible to enterprise billing managers and owners. */
export type Github_EnterpriseBillingInfo = {
  __typename?: 'Github_EnterpriseBillingInfo';
  /** The number of licenseable users/emails across the enterprise. */
  allLicensableUsersCount: Scalars['Int'];
  /** The number of data packs used by all organizations owned by the enterprise. */
  assetPacks: Scalars['Int'];
  /**
   * The number of available seats across all owned organizations based on the unique number of billable users.
   * @deprecated `availableSeats` will be replaced with `totalAvailableLicenses` to provide more clarity on the value being returned Use EnterpriseBillingInfo.totalAvailableLicenses instead. Removal on 2020-01-01 UTC.
   */
  availableSeats: Scalars['Int'];
  /** The bandwidth quota in GB for all organizations owned by the enterprise. */
  bandwidthQuota: Scalars['Float'];
  /** The bandwidth usage in GB for all organizations owned by the enterprise. */
  bandwidthUsage: Scalars['Float'];
  /** The bandwidth usage as a percentage of the bandwidth quota. */
  bandwidthUsagePercentage: Scalars['Int'];
  /**
   * The total seats across all organizations owned by the enterprise.
   * @deprecated `seats` will be replaced with `totalLicenses` to provide more clarity on the value being returned Use EnterpriseBillingInfo.totalLicenses instead. Removal on 2020-01-01 UTC.
   */
  seats: Scalars['Int'];
  /** The storage quota in GB for all organizations owned by the enterprise. */
  storageQuota: Scalars['Float'];
  /** The storage usage in GB for all organizations owned by the enterprise. */
  storageUsage: Scalars['Float'];
  /** The storage usage as a percentage of the storage quota. */
  storageUsagePercentage: Scalars['Int'];
  /** The number of available licenses across all owned organizations based on the unique number of billable users. */
  totalAvailableLicenses: Scalars['Int'];
  /** The total number of licenses allocated. */
  totalLicenses: Scalars['Int'];
};

/** The possible values for the enterprise base repository permission setting. */
export enum Github_EnterpriseDefaultRepositoryPermissionSettingValue {
  /** Organization members will be able to clone, pull, push, and add new collaborators to all organization repositories. */
  Admin = 'ADMIN',
  /** Organization members will only be able to clone and pull public repositories. */
  None = 'NONE',
  /** Organizations in the enterprise choose base repository permissions for their members. */
  NoPolicy = 'NO_POLICY',
  /** Organization members will be able to clone and pull all organization repositories. */
  Read = 'READ',
  /** Organization members will be able to clone, pull, and push all organization repositories. */
  Write = 'WRITE'
}

/** The possible values for an enabled/disabled enterprise setting. */
export enum Github_EnterpriseEnabledDisabledSettingValue {
  /** The setting is disabled for organizations in the enterprise. */
  Disabled = 'DISABLED',
  /** The setting is enabled for organizations in the enterprise. */
  Enabled = 'ENABLED',
  /** There is no policy set for organizations in the enterprise. */
  NoPolicy = 'NO_POLICY'
}

/** The possible values for an enabled/no policy enterprise setting. */
export enum Github_EnterpriseEnabledSettingValue {
  /** The setting is enabled for organizations in the enterprise. */
  Enabled = 'ENABLED',
  /** There is no policy set for organizations in the enterprise. */
  NoPolicy = 'NO_POLICY'
}

/** An identity provider configured to provision identities for an enterprise. */
export type Github_EnterpriseIdentityProvider = Github_Node & {
  __typename?: 'Github_EnterpriseIdentityProvider';
  /** The digest algorithm used to sign SAML requests for the identity provider. */
  digestMethod?: Maybe<Github_SamlDigestAlgorithm>;
  /** The enterprise this identity provider belongs to. */
  enterprise?: Maybe<Github_Enterprise>;
  /** ExternalIdentities provisioned by this identity provider. */
  externalIdentities: Github_ExternalIdentityConnection;
  id: Scalars['ID'];
  /** The x509 certificate used by the identity provider to sign assertions and responses. */
  idpCertificate?: Maybe<Scalars['Github_X509Certificate']>;
  /** The Issuer Entity ID for the SAML identity provider. */
  issuer?: Maybe<Scalars['String']>;
  /** Recovery codes that can be used by admins to access the enterprise if the identity provider is unavailable. */
  recoveryCodes?: Maybe<Array<Scalars['String']>>;
  /** The signature algorithm used to sign SAML requests for the identity provider. */
  signatureMethod?: Maybe<Github_SamlSignatureAlgorithm>;
  /** The URL endpoint for the identity provider's SAML SSO. */
  ssoUrl?: Maybe<Scalars['Github_URI']>;
};


/** An identity provider configured to provision identities for an enterprise. */
export type Github_EnterpriseIdentityProviderExternalIdentitiesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  membersOnly?: InputMaybe<Scalars['Boolean']>;
};

/** An object that is a member of an enterprise. */
export type Github_EnterpriseMember = Github_EnterpriseUserAccount | Github_User;

/** The connection type for EnterpriseMember. */
export type Github_EnterpriseMemberConnection = {
  __typename?: 'Github_EnterpriseMemberConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_EnterpriseMemberEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_EnterpriseMember>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** A User who is a member of an enterprise through one or more organizations. */
export type Github_EnterpriseMemberEdge = {
  __typename?: 'Github_EnterpriseMemberEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /**
   * Whether the user does not have a license for the enterprise.
   * @deprecated All members consume a license Removal on 2021-01-01 UTC.
   */
  isUnlicensed: Scalars['Boolean'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_EnterpriseMember>;
};

/** Ordering options for enterprise member connections. */
export type Github_EnterpriseMemberOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order enterprise members by. */
  field: Github_EnterpriseMemberOrderField;
};

/** Properties by which enterprise member connections can be ordered. */
export enum Github_EnterpriseMemberOrderField {
  /** Order enterprise members by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order enterprise members by login */
  Login = 'LOGIN'
}

/** The possible values for the enterprise members can create repositories setting. */
export enum Github_EnterpriseMembersCanCreateRepositoriesSettingValue {
  /** Members will be able to create public and private repositories. */
  All = 'ALL',
  /** Members will not be able to create public or private repositories. */
  Disabled = 'DISABLED',
  /** Organization administrators choose whether to allow members to create repositories. */
  NoPolicy = 'NO_POLICY',
  /** Members will be able to create only private repositories. */
  Private = 'PRIVATE',
  /** Members will be able to create only public repositories. */
  Public = 'PUBLIC'
}

/** The possible values for the members can make purchases setting. */
export enum Github_EnterpriseMembersCanMakePurchasesSettingValue {
  /** The setting is disabled for organizations in the enterprise. */
  Disabled = 'DISABLED',
  /** The setting is enabled for organizations in the enterprise. */
  Enabled = 'ENABLED'
}

/** The connection type for Organization. */
export type Github_EnterpriseOrganizationMembershipConnection = {
  __typename?: 'Github_EnterpriseOrganizationMembershipConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_EnterpriseOrganizationMembershipEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Organization>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An enterprise organization that a user is a member of. */
export type Github_EnterpriseOrganizationMembershipEdge = {
  __typename?: 'Github_EnterpriseOrganizationMembershipEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Organization>;
  /** The role of the user in the enterprise membership. */
  role: Github_EnterpriseUserAccountMembershipRole;
};

/** The connection type for User. */
export type Github_EnterpriseOutsideCollaboratorConnection = {
  __typename?: 'Github_EnterpriseOutsideCollaboratorConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_EnterpriseOutsideCollaboratorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** A User who is an outside collaborator of an enterprise through one or more organizations. */
export type Github_EnterpriseOutsideCollaboratorEdge = {
  __typename?: 'Github_EnterpriseOutsideCollaboratorEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /**
   * Whether the outside collaborator does not have a license for the enterprise.
   * @deprecated All outside collaborators consume a license Removal on 2021-01-01 UTC.
   */
  isUnlicensed: Scalars['Boolean'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_User>;
  /** The enterprise organization repositories this user is a member of. */
  repositories: Github_EnterpriseRepositoryInfoConnection;
};


/** A User who is an outside collaborator of an enterprise through one or more organizations. */
export type Github_EnterpriseOutsideCollaboratorEdgeRepositoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_RepositoryOrder>;
};

/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfo = {
  __typename?: 'Github_EnterpriseOwnerInfo';
  /** A list of all of the administrators for this enterprise. */
  admins: Github_EnterpriseAdministratorConnection;
  /** A list of users in the enterprise who currently have two-factor authentication disabled. */
  affiliatedUsersWithTwoFactorDisabled: Github_UserConnection;
  /** Whether or not affiliated users with two-factor authentication disabled exist in the enterprise. */
  affiliatedUsersWithTwoFactorDisabledExist: Scalars['Boolean'];
  /** The setting value for whether private repository forking is enabled for repositories in organizations in this enterprise. */
  allowPrivateRepositoryForkingSetting: Github_EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided private repository forking setting value. */
  allowPrivateRepositoryForkingSettingOrganizations: Github_OrganizationConnection;
  /** The setting value for base repository permissions for organizations in this enterprise. */
  defaultRepositoryPermissionSetting: Github_EnterpriseDefaultRepositoryPermissionSettingValue;
  /** A list of enterprise organizations configured with the provided base repository permission. */
  defaultRepositoryPermissionSettingOrganizations: Github_OrganizationConnection;
  /** A list of domains owned by the enterprise. */
  domains: Github_VerifiableDomainConnection;
  /** Enterprise Server installations owned by the enterprise. */
  enterpriseServerInstallations: Github_EnterpriseServerInstallationConnection;
  /** The setting value for whether the enterprise has an IP allow list enabled. */
  ipAllowListEnabledSetting: Github_IpAllowListEnabledSettingValue;
  /** The IP addresses that are allowed to access resources owned by the enterprise. */
  ipAllowListEntries: Github_IpAllowListEntryConnection;
  /** The setting value for whether the enterprise has IP allow list configuration for installed GitHub Apps enabled. */
  ipAllowListForInstalledAppsEnabledSetting: Github_IpAllowListForInstalledAppsEnabledSettingValue;
  /** Whether or not the base repository permission is currently being updated. */
  isUpdatingDefaultRepositoryPermission: Scalars['Boolean'];
  /** Whether the two-factor authentication requirement is currently being enforced. */
  isUpdatingTwoFactorRequirement: Scalars['Boolean'];
  /**
   * The setting value for whether organization members with admin permissions on a
   * repository can change repository visibility.
   */
  membersCanChangeRepositoryVisibilitySetting: Github_EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided can change repository visibility setting value. */
  membersCanChangeRepositoryVisibilitySettingOrganizations: Github_OrganizationConnection;
  /** The setting value for whether members of organizations in the enterprise can create internal repositories. */
  membersCanCreateInternalRepositoriesSetting?: Maybe<Scalars['Boolean']>;
  /** The setting value for whether members of organizations in the enterprise can create private repositories. */
  membersCanCreatePrivateRepositoriesSetting?: Maybe<Scalars['Boolean']>;
  /** The setting value for whether members of organizations in the enterprise can create public repositories. */
  membersCanCreatePublicRepositoriesSetting?: Maybe<Scalars['Boolean']>;
  /** The setting value for whether members of organizations in the enterprise can create repositories. */
  membersCanCreateRepositoriesSetting?: Maybe<Github_EnterpriseMembersCanCreateRepositoriesSettingValue>;
  /** A list of enterprise organizations configured with the provided repository creation setting value. */
  membersCanCreateRepositoriesSettingOrganizations: Github_OrganizationConnection;
  /** The setting value for whether members with admin permissions for repositories can delete issues. */
  membersCanDeleteIssuesSetting: Github_EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided members can delete issues setting value. */
  membersCanDeleteIssuesSettingOrganizations: Github_OrganizationConnection;
  /** The setting value for whether members with admin permissions for repositories can delete or transfer repositories. */
  membersCanDeleteRepositoriesSetting: Github_EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided members can delete repositories setting value. */
  membersCanDeleteRepositoriesSettingOrganizations: Github_OrganizationConnection;
  /** The setting value for whether members of organizations in the enterprise can invite outside collaborators. */
  membersCanInviteCollaboratorsSetting: Github_EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided members can invite collaborators setting value. */
  membersCanInviteCollaboratorsSettingOrganizations: Github_OrganizationConnection;
  /** Indicates whether members of this enterprise's organizations can purchase additional services for those organizations. */
  membersCanMakePurchasesSetting: Github_EnterpriseMembersCanMakePurchasesSettingValue;
  /** The setting value for whether members with admin permissions for repositories can update protected branches. */
  membersCanUpdateProtectedBranchesSetting: Github_EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided members can update protected branches setting value. */
  membersCanUpdateProtectedBranchesSettingOrganizations: Github_OrganizationConnection;
  /** The setting value for whether members can view dependency insights. */
  membersCanViewDependencyInsightsSetting: Github_EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided members can view dependency insights setting value. */
  membersCanViewDependencyInsightsSettingOrganizations: Github_OrganizationConnection;
  /** Indicates if email notification delivery for this enterprise is restricted to verified or approved domains. */
  notificationDeliveryRestrictionEnabledSetting: Github_NotificationRestrictionSettingValue;
  /** The OIDC Identity Provider for the enterprise. */
  oidcProvider?: Maybe<Github_OidcProvider>;
  /** The setting value for whether organization projects are enabled for organizations in this enterprise. */
  organizationProjectsSetting: Github_EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided organization projects setting value. */
  organizationProjectsSettingOrganizations: Github_OrganizationConnection;
  /** A list of outside collaborators across the repositories in the enterprise. */
  outsideCollaborators: Github_EnterpriseOutsideCollaboratorConnection;
  /** A list of pending administrator invitations for the enterprise. */
  pendingAdminInvitations: Github_EnterpriseAdministratorInvitationConnection;
  /** A list of pending collaborator invitations across the repositories in the enterprise. */
  pendingCollaboratorInvitations: Github_RepositoryInvitationConnection;
  /**
   * A list of pending collaborators across the repositories in the enterprise.
   * @deprecated Repository invitations can now be associated with an email, not only an invitee. Use the `pendingCollaboratorInvitations` field instead. Removal on 2020-10-01 UTC.
   */
  pendingCollaborators: Github_EnterprisePendingCollaboratorConnection;
  /** A list of pending member invitations for organizations in the enterprise. */
  pendingMemberInvitations: Github_EnterprisePendingMemberInvitationConnection;
  /** The setting value for whether repository projects are enabled in this enterprise. */
  repositoryProjectsSetting: Github_EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided repository projects setting value. */
  repositoryProjectsSettingOrganizations: Github_OrganizationConnection;
  /** The SAML Identity Provider for the enterprise. */
  samlIdentityProvider?: Maybe<Github_EnterpriseIdentityProvider>;
  /** A list of enterprise organizations configured with the SAML single sign-on setting value. */
  samlIdentityProviderSettingOrganizations: Github_OrganizationConnection;
  /** A list of members with a support entitlement. */
  supportEntitlements: Github_EnterpriseMemberConnection;
  /** The setting value for whether team discussions are enabled for organizations in this enterprise. */
  teamDiscussionsSetting: Github_EnterpriseEnabledDisabledSettingValue;
  /** A list of enterprise organizations configured with the provided team discussions setting value. */
  teamDiscussionsSettingOrganizations: Github_OrganizationConnection;
  /** The setting value for whether the enterprise requires two-factor authentication for its organizations and users. */
  twoFactorRequiredSetting: Github_EnterpriseEnabledSettingValue;
  /** A list of enterprise organizations configured with the two-factor authentication setting value. */
  twoFactorRequiredSettingOrganizations: Github_OrganizationConnection;
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfoAdminsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_EnterpriseMemberOrder>;
  query?: InputMaybe<Scalars['String']>;
  role?: InputMaybe<Github_EnterpriseAdministratorRole>;
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfoAffiliatedUsersWithTwoFactorDisabledArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfoAllowPrivateRepositoryForkingSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_OrganizationOrder>;
  value: Scalars['Boolean'];
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfoDefaultRepositoryPermissionSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_OrganizationOrder>;
  value: Github_DefaultRepositoryPermissionField;
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfoDomainsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  isApproved?: InputMaybe<Scalars['Boolean']>;
  isVerified?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_VerifiableDomainOrder>;
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfoEnterpriseServerInstallationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  connectedOnly?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_EnterpriseServerInstallationOrder>;
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfoIpAllowListEntriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_IpAllowListEntryOrder>;
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfoMembersCanChangeRepositoryVisibilitySettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_OrganizationOrder>;
  value: Scalars['Boolean'];
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfoMembersCanCreateRepositoriesSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_OrganizationOrder>;
  value: Github_OrganizationMembersCanCreateRepositoriesSettingValue;
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfoMembersCanDeleteIssuesSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_OrganizationOrder>;
  value: Scalars['Boolean'];
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfoMembersCanDeleteRepositoriesSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_OrganizationOrder>;
  value: Scalars['Boolean'];
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfoMembersCanInviteCollaboratorsSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_OrganizationOrder>;
  value: Scalars['Boolean'];
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfoMembersCanUpdateProtectedBranchesSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_OrganizationOrder>;
  value: Scalars['Boolean'];
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfoMembersCanViewDependencyInsightsSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_OrganizationOrder>;
  value: Scalars['Boolean'];
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfoOrganizationProjectsSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_OrganizationOrder>;
  value: Scalars['Boolean'];
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfoOutsideCollaboratorsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  login?: InputMaybe<Scalars['String']>;
  orderBy?: InputMaybe<Github_EnterpriseMemberOrder>;
  query?: InputMaybe<Scalars['String']>;
  visibility?: InputMaybe<Github_RepositoryVisibility>;
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfoPendingAdminInvitationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_EnterpriseAdministratorInvitationOrder>;
  query?: InputMaybe<Scalars['String']>;
  role?: InputMaybe<Github_EnterpriseAdministratorRole>;
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfoPendingCollaboratorInvitationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_RepositoryInvitationOrder>;
  query?: InputMaybe<Scalars['String']>;
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfoPendingCollaboratorsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_RepositoryInvitationOrder>;
  query?: InputMaybe<Scalars['String']>;
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfoPendingMemberInvitationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  query?: InputMaybe<Scalars['String']>;
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfoRepositoryProjectsSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_OrganizationOrder>;
  value: Scalars['Boolean'];
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfoSamlIdentityProviderSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_OrganizationOrder>;
  value: Github_IdentityProviderConfigurationState;
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfoSupportEntitlementsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_EnterpriseMemberOrder>;
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfoTeamDiscussionsSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_OrganizationOrder>;
  value: Scalars['Boolean'];
};


/** Enterprise information only visible to enterprise owners. */
export type Github_EnterpriseOwnerInfoTwoFactorRequiredSettingOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_OrganizationOrder>;
  value: Scalars['Boolean'];
};

/** The connection type for User. */
export type Github_EnterprisePendingCollaboratorConnection = {
  __typename?: 'Github_EnterprisePendingCollaboratorConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_EnterprisePendingCollaboratorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** A user with an invitation to be a collaborator on a repository owned by an organization in an enterprise. */
export type Github_EnterprisePendingCollaboratorEdge = {
  __typename?: 'Github_EnterprisePendingCollaboratorEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /**
   * Whether the invited collaborator does not have a license for the enterprise.
   * @deprecated All pending collaborators consume a license Removal on 2021-01-01 UTC.
   */
  isUnlicensed: Scalars['Boolean'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_User>;
  /** The enterprise organization repositories this user is a member of. */
  repositories: Github_EnterpriseRepositoryInfoConnection;
};


/** A user with an invitation to be a collaborator on a repository owned by an organization in an enterprise. */
export type Github_EnterprisePendingCollaboratorEdgeRepositoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_RepositoryOrder>;
};

/** The connection type for OrganizationInvitation. */
export type Github_EnterprisePendingMemberInvitationConnection = {
  __typename?: 'Github_EnterprisePendingMemberInvitationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_EnterprisePendingMemberInvitationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_OrganizationInvitation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
  /** Identifies the total count of unique users in the connection. */
  totalUniqueUserCount: Scalars['Int'];
};

/** An invitation to be a member in an enterprise organization. */
export type Github_EnterprisePendingMemberInvitationEdge = {
  __typename?: 'Github_EnterprisePendingMemberInvitationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /**
   * Whether the invitation has a license for the enterprise.
   * @deprecated All pending members consume a license Removal on 2020-07-01 UTC.
   */
  isUnlicensed: Scalars['Boolean'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_OrganizationInvitation>;
};

/** A subset of repository information queryable from an enterprise. */
export type Github_EnterpriseRepositoryInfo = Github_Node & {
  __typename?: 'Github_EnterpriseRepositoryInfo';
  id: Scalars['ID'];
  /** Identifies if the repository is private or internal. */
  isPrivate: Scalars['Boolean'];
  /** The repository's name. */
  name: Scalars['String'];
  /** The repository's name with owner. */
  nameWithOwner: Scalars['String'];
};

/** The connection type for EnterpriseRepositoryInfo. */
export type Github_EnterpriseRepositoryInfoConnection = {
  __typename?: 'Github_EnterpriseRepositoryInfoConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_EnterpriseRepositoryInfoEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_EnterpriseRepositoryInfo>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_EnterpriseRepositoryInfoEdge = {
  __typename?: 'Github_EnterpriseRepositoryInfoEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_EnterpriseRepositoryInfo>;
};

/** An Enterprise Server installation. */
export type Github_EnterpriseServerInstallation = Github_Node & {
  __typename?: 'Github_EnterpriseServerInstallation';
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The customer name to which the Enterprise Server installation belongs. */
  customerName: Scalars['String'];
  /** The host name of the Enterprise Server installation. */
  hostName: Scalars['String'];
  id: Scalars['ID'];
  /** Whether or not the installation is connected to an Enterprise Server installation via GitHub Connect. */
  isConnected: Scalars['Boolean'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** User accounts on this Enterprise Server installation. */
  userAccounts: Github_EnterpriseServerUserAccountConnection;
  /** User accounts uploads for the Enterprise Server installation. */
  userAccountsUploads: Github_EnterpriseServerUserAccountsUploadConnection;
};


/** An Enterprise Server installation. */
export type Github_EnterpriseServerInstallationUserAccountsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_EnterpriseServerUserAccountOrder>;
};


/** An Enterprise Server installation. */
export type Github_EnterpriseServerInstallationUserAccountsUploadsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_EnterpriseServerUserAccountsUploadOrder>;
};

/** The connection type for EnterpriseServerInstallation. */
export type Github_EnterpriseServerInstallationConnection = {
  __typename?: 'Github_EnterpriseServerInstallationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_EnterpriseServerInstallationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_EnterpriseServerInstallation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_EnterpriseServerInstallationEdge = {
  __typename?: 'Github_EnterpriseServerInstallationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_EnterpriseServerInstallation>;
};

/** Ordering options for Enterprise Server installation connections. */
export type Github_EnterpriseServerInstallationOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order Enterprise Server installations by. */
  field: Github_EnterpriseServerInstallationOrderField;
};

/** Properties by which Enterprise Server installation connections can be ordered. */
export enum Github_EnterpriseServerInstallationOrderField {
  /** Order Enterprise Server installations by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order Enterprise Server installations by customer name */
  CustomerName = 'CUSTOMER_NAME',
  /** Order Enterprise Server installations by host name */
  HostName = 'HOST_NAME'
}

/** A user account on an Enterprise Server installation. */
export type Github_EnterpriseServerUserAccount = Github_Node & {
  __typename?: 'Github_EnterpriseServerUserAccount';
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** User emails belonging to this user account. */
  emails: Github_EnterpriseServerUserAccountEmailConnection;
  /** The Enterprise Server installation on which this user account exists. */
  enterpriseServerInstallation: Github_EnterpriseServerInstallation;
  id: Scalars['ID'];
  /** Whether the user account is a site administrator on the Enterprise Server installation. */
  isSiteAdmin: Scalars['Boolean'];
  /** The login of the user account on the Enterprise Server installation. */
  login: Scalars['String'];
  /** The profile name of the user account on the Enterprise Server installation. */
  profileName?: Maybe<Scalars['String']>;
  /** The date and time when the user account was created on the Enterprise Server installation. */
  remoteCreatedAt: Scalars['DateTime'];
  /** The ID of the user account on the Enterprise Server installation. */
  remoteUserId: Scalars['Int'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};


/** A user account on an Enterprise Server installation. */
export type Github_EnterpriseServerUserAccountEmailsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_EnterpriseServerUserAccountEmailOrder>;
};

/** The connection type for EnterpriseServerUserAccount. */
export type Github_EnterpriseServerUserAccountConnection = {
  __typename?: 'Github_EnterpriseServerUserAccountConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_EnterpriseServerUserAccountEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_EnterpriseServerUserAccount>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_EnterpriseServerUserAccountEdge = {
  __typename?: 'Github_EnterpriseServerUserAccountEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_EnterpriseServerUserAccount>;
};

/** An email belonging to a user account on an Enterprise Server installation. */
export type Github_EnterpriseServerUserAccountEmail = Github_Node & {
  __typename?: 'Github_EnterpriseServerUserAccountEmail';
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The email address. */
  email: Scalars['String'];
  id: Scalars['ID'];
  /** Indicates whether this is the primary email of the associated user account. */
  isPrimary: Scalars['Boolean'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The user account to which the email belongs. */
  userAccount: Github_EnterpriseServerUserAccount;
};

/** The connection type for EnterpriseServerUserAccountEmail. */
export type Github_EnterpriseServerUserAccountEmailConnection = {
  __typename?: 'Github_EnterpriseServerUserAccountEmailConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_EnterpriseServerUserAccountEmailEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_EnterpriseServerUserAccountEmail>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_EnterpriseServerUserAccountEmailEdge = {
  __typename?: 'Github_EnterpriseServerUserAccountEmailEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_EnterpriseServerUserAccountEmail>;
};

/** Ordering options for Enterprise Server user account email connections. */
export type Github_EnterpriseServerUserAccountEmailOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order emails by. */
  field: Github_EnterpriseServerUserAccountEmailOrderField;
};

/** Properties by which Enterprise Server user account email connections can be ordered. */
export enum Github_EnterpriseServerUserAccountEmailOrderField {
  /** Order emails by email */
  Email = 'EMAIL'
}

/** Ordering options for Enterprise Server user account connections. */
export type Github_EnterpriseServerUserAccountOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order user accounts by. */
  field: Github_EnterpriseServerUserAccountOrderField;
};

/** Properties by which Enterprise Server user account connections can be ordered. */
export enum Github_EnterpriseServerUserAccountOrderField {
  /** Order user accounts by login */
  Login = 'LOGIN',
  /** Order user accounts by creation time on the Enterprise Server installation */
  RemoteCreatedAt = 'REMOTE_CREATED_AT'
}

/** A user accounts upload from an Enterprise Server installation. */
export type Github_EnterpriseServerUserAccountsUpload = Github_Node & {
  __typename?: 'Github_EnterpriseServerUserAccountsUpload';
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The enterprise to which this upload belongs. */
  enterprise: Github_Enterprise;
  /** The Enterprise Server installation for which this upload was generated. */
  enterpriseServerInstallation: Github_EnterpriseServerInstallation;
  id: Scalars['ID'];
  /** The name of the file uploaded. */
  name: Scalars['String'];
  /** The synchronization state of the upload */
  syncState: Github_EnterpriseServerUserAccountsUploadSyncState;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** The connection type for EnterpriseServerUserAccountsUpload. */
export type Github_EnterpriseServerUserAccountsUploadConnection = {
  __typename?: 'Github_EnterpriseServerUserAccountsUploadConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_EnterpriseServerUserAccountsUploadEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_EnterpriseServerUserAccountsUpload>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_EnterpriseServerUserAccountsUploadEdge = {
  __typename?: 'Github_EnterpriseServerUserAccountsUploadEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_EnterpriseServerUserAccountsUpload>;
};

/** Ordering options for Enterprise Server user accounts upload connections. */
export type Github_EnterpriseServerUserAccountsUploadOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order user accounts uploads by. */
  field: Github_EnterpriseServerUserAccountsUploadOrderField;
};

/** Properties by which Enterprise Server user accounts upload connections can be ordered. */
export enum Github_EnterpriseServerUserAccountsUploadOrderField {
  /** Order user accounts uploads by creation time */
  CreatedAt = 'CREATED_AT'
}

/** Synchronization state of the Enterprise Server user accounts upload */
export enum Github_EnterpriseServerUserAccountsUploadSyncState {
  /** The synchronization of the upload failed. */
  Failure = 'FAILURE',
  /** The synchronization of the upload is pending. */
  Pending = 'PENDING',
  /** The synchronization of the upload succeeded. */
  Success = 'SUCCESS'
}

/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */
export type Github_EnterpriseUserAccount = Github_Actor & Github_Node & {
  __typename?: 'Github_EnterpriseUserAccount';
  /** A URL pointing to the enterprise user account's public avatar. */
  avatarUrl: Scalars['Github_URI'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The enterprise in which this user account exists. */
  enterprise: Github_Enterprise;
  id: Scalars['ID'];
  /** An identifier for the enterprise user account, a login or email address */
  login: Scalars['String'];
  /** The name of the enterprise user account */
  name?: Maybe<Scalars['String']>;
  /** A list of enterprise organizations this user is a member of. */
  organizations: Github_EnterpriseOrganizationMembershipConnection;
  /** The HTTP path for this user. */
  resourcePath: Scalars['Github_URI'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this user. */
  url: Scalars['Github_URI'];
  /** The user within the enterprise. */
  user?: Maybe<Github_User>;
};


/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */
export type Github_EnterpriseUserAccountAvatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']>;
};


/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */
export type Github_EnterpriseUserAccountOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_OrganizationOrder>;
  query?: InputMaybe<Scalars['String']>;
  role?: InputMaybe<Github_EnterpriseUserAccountMembershipRole>;
};

/** The connection type for EnterpriseUserAccount. */
export type Github_EnterpriseUserAccountConnection = {
  __typename?: 'Github_EnterpriseUserAccountConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_EnterpriseUserAccountEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_EnterpriseUserAccount>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_EnterpriseUserAccountEdge = {
  __typename?: 'Github_EnterpriseUserAccountEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_EnterpriseUserAccount>;
};

/** The possible roles for enterprise membership. */
export enum Github_EnterpriseUserAccountMembershipRole {
  /** The user is a member of the enterprise membership. */
  Member = 'MEMBER',
  /** The user is an owner of the enterprise membership. */
  Owner = 'OWNER'
}

/** The possible GitHub Enterprise deployments where this user can exist. */
export enum Github_EnterpriseUserDeployment {
  /** The user is part of a GitHub Enterprise Cloud deployment. */
  Cloud = 'CLOUD',
  /** The user is part of a GitHub Enterprise Server deployment. */
  Server = 'SERVER'
}

/** An environment. */
export type Github_Environment = Github_Node & {
  __typename?: 'Github_Environment';
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** The name of the environment */
  name: Scalars['String'];
  /** The protection rules defined for this environment */
  protectionRules: Github_DeploymentProtectionRuleConnection;
};


/** An environment. */
export type Github_EnvironmentProtectionRulesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for Environment. */
export type Github_EnvironmentConnection = {
  __typename?: 'Github_EnvironmentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_EnvironmentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Environment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_EnvironmentEdge = {
  __typename?: 'Github_EnvironmentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Environment>;
};

/** An external identity provisioned by SAML SSO or SCIM. */
export type Github_ExternalIdentity = Github_Node & {
  __typename?: 'Github_ExternalIdentity';
  /** The GUID for this identity */
  guid: Scalars['String'];
  id: Scalars['ID'];
  /** Organization invitation for this SCIM-provisioned external identity */
  organizationInvitation?: Maybe<Github_OrganizationInvitation>;
  /** SAML Identity attributes */
  samlIdentity?: Maybe<Github_ExternalIdentitySamlAttributes>;
  /** SCIM Identity attributes */
  scimIdentity?: Maybe<Github_ExternalIdentityScimAttributes>;
  /** User linked to this external identity. Will be NULL if this identity has not been claimed by an organization member. */
  user?: Maybe<Github_User>;
};

/** The connection type for ExternalIdentity. */
export type Github_ExternalIdentityConnection = {
  __typename?: 'Github_ExternalIdentityConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_ExternalIdentityEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_ExternalIdentity>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_ExternalIdentityEdge = {
  __typename?: 'Github_ExternalIdentityEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_ExternalIdentity>;
};

/** SAML attributes for the External Identity */
export type Github_ExternalIdentitySamlAttributes = {
  __typename?: 'Github_ExternalIdentitySamlAttributes';
  /** The emails associated with the SAML identity */
  emails?: Maybe<Array<Github_UserEmailMetadata>>;
  /** Family name of the SAML identity */
  familyName?: Maybe<Scalars['String']>;
  /** Given name of the SAML identity */
  givenName?: Maybe<Scalars['String']>;
  /** The groups linked to this identity in IDP */
  groups?: Maybe<Array<Scalars['String']>>;
  /** The NameID of the SAML identity */
  nameId?: Maybe<Scalars['String']>;
  /** The userName of the SAML identity */
  username?: Maybe<Scalars['String']>;
};

/** SCIM attributes for the External Identity */
export type Github_ExternalIdentityScimAttributes = {
  __typename?: 'Github_ExternalIdentityScimAttributes';
  /** The emails associated with the SCIM identity */
  emails?: Maybe<Array<Github_UserEmailMetadata>>;
  /** Family name of the SCIM identity */
  familyName?: Maybe<Scalars['String']>;
  /** Given name of the SCIM identity */
  givenName?: Maybe<Scalars['String']>;
  /** The groups linked to this identity in IDP */
  groups?: Maybe<Array<Scalars['String']>>;
  /** The userName of the SCIM identity */
  username?: Maybe<Scalars['String']>;
};

/**
 * A command to add a file at the given path with the given contents as part of a
 * commit.  Any existing file at that that path will be replaced.
 */
export type Github_FileAddition = {
  /** The base64 encoded contents of the file */
  contents: Scalars['Github_Base64String'];
  /** The path in the repository where the file will be located */
  path: Scalars['String'];
};

/**
 * A description of a set of changes to a file tree to be made as part of
 * a git commit, modeled as zero or more file `additions` and zero or more
 * file `deletions`.
 *
 * Both fields are optional; omitting both will produce a commit with no
 * file changes.
 *
 * `deletions` and `additions` describe changes to files identified
 * by their path in the git tree using unix-style path separators, i.e.
 * `/`.  The root of a git tree is an empty string, so paths are not
 * slash-prefixed.
 *
 * `path` values must be unique across all `additions` and `deletions`
 * provided.  Any duplication will result in a validation error.
 *
 * ### Encoding
 *
 * File contents must be provided in full for each `FileAddition`.
 *
 * The `contents` of a `FileAddition` must be encoded using RFC 4648
 * compliant base64, i.e. correct padding is required and no characters
 * outside the standard alphabet may be used.  Invalid base64
 * encoding will be rejected with a validation error.
 *
 * The encoded contents may be binary.
 *
 * For text files, no assumptions are made about the character encoding of
 * the file contents (after base64 decoding).  No charset transcoding or
 * line-ending normalization will be performed; it is the client's
 * responsibility to manage the character encoding of files they provide.
 * However, for maximum compatibility we recommend using UTF-8 encoding
 * and ensuring that all files in a repository use a consistent
 * line-ending convention (`\n` or `\r\n`), and that all files end
 * with a newline.
 *
 * ### Modeling file changes
 *
 * Each of the the five types of conceptual changes that can be made in a
 * git commit can be described using the `FileChanges` type as follows:
 *
 * 1. New file addition: create file `hello world\n` at path `docs/README.txt`:
 *
 *        {
 *          "additions" [
 *            {
 *              "path": "docs/README.txt",
 *              "contents": base64encode("hello world\n")
 *            }
 *          ]
 *        }
 *
 * 2. Existing file modification: change existing `docs/README.txt` to have new
 *    content `new content here\n`:
 *
 *        {
 *          "additions" [
 *            {
 *              "path": "docs/README.txt",
 *              "contents": base64encode("new content here\n")
 *            }
 *          ]
 *        }
 *
 * 3. Existing file deletion: remove existing file `docs/README.txt`.
 *    Note that the path is required to exist -- specifying a
 *    path that does not exist on the given branch will abort the
 *    commit and return an error.
 *
 *        {
 *          "deletions" [
 *            {
 *              "path": "docs/README.txt"
 *            }
 *          ]
 *        }
 *
 *
 * 4. File rename with no changes: rename `docs/README.txt` with
 *    previous content `hello world\n` to the same content at
 *    `newdocs/README.txt`:
 *
 *        {
 *          "deletions" [
 *            {
 *              "path": "docs/README.txt",
 *            }
 *          ],
 *          "additions" [
 *            {
 *              "path": "newdocs/README.txt",
 *              "contents": base64encode("hello world\n")
 *            }
 *          ]
 *        }
 *
 *
 * 5. File rename with changes: rename `docs/README.txt` with
 *    previous content `hello world\n` to a file at path
 *    `newdocs/README.txt` with content `new contents\n`:
 *
 *        {
 *          "deletions" [
 *            {
 *              "path": "docs/README.txt",
 *            }
 *          ],
 *          "additions" [
 *            {
 *              "path": "newdocs/README.txt",
 *              "contents": base64encode("new contents\n")
 *            }
 *          ]
 *        }
 */
export type Github_FileChanges = {
  /** File to add or change. */
  additions?: InputMaybe<Array<Github_FileAddition>>;
  /** Files to delete. */
  deletions?: InputMaybe<Array<Github_FileDeletion>>;
};

/** A command to delete the file at the given path as part of a commit. */
export type Github_FileDeletion = {
  /** The path to delete */
  path: Scalars['String'];
};

/** The possible viewed states of a file . */
export enum Github_FileViewedState {
  /** The file has new changes since last viewed. */
  Dismissed = 'DISMISSED',
  /** The file has not been marked as viewed. */
  Unviewed = 'UNVIEWED',
  /** The file has been marked as viewed. */
  Viewed = 'VIEWED'
}

/** Autogenerated input type of FollowUser */
export type Github_FollowUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the user to follow. */
  userId: Scalars['ID'];
};

/** Autogenerated return type of FollowUser */
export type Github_FollowUserPayload = {
  __typename?: 'Github_FollowUserPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The user that was followed. */
  user?: Maybe<Github_User>;
};

/** The connection type for User. */
export type Github_FollowerConnection = {
  __typename?: 'Github_FollowerConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_UserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** The connection type for User. */
export type Github_FollowingConnection = {
  __typename?: 'Github_FollowingConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_UserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** A funding platform link for a repository. */
export type Github_FundingLink = {
  __typename?: 'Github_FundingLink';
  /** The funding platform this link is for. */
  platform: Github_FundingPlatform;
  /** The configured URL for this funding link. */
  url: Scalars['Github_URI'];
};

/** The possible funding platforms for repository funding links. */
export enum Github_FundingPlatform {
  /** Community Bridge funding platform. */
  CommunityBridge = 'COMMUNITY_BRIDGE',
  /** Custom funding platform. */
  Custom = 'CUSTOM',
  /** GitHub funding platform. */
  Github = 'GITHUB',
  /** IssueHunt funding platform. */
  Issuehunt = 'ISSUEHUNT',
  /** Ko-fi funding platform. */
  KoFi = 'KO_FI',
  /** Liberapay funding platform. */
  Liberapay = 'LIBERAPAY',
  /** Open Collective funding platform. */
  OpenCollective = 'OPEN_COLLECTIVE',
  /** Otechie funding platform. */
  Otechie = 'OTECHIE',
  /** Patreon funding platform. */
  Patreon = 'PATREON',
  /** Tidelift funding platform. */
  Tidelift = 'TIDELIFT'
}

/** A generic hovercard context with a message and icon */
export type Github_GenericHovercardContext = Github_HovercardContext & {
  __typename?: 'Github_GenericHovercardContext';
  /** A string describing this context */
  message: Scalars['String'];
  /** An octicon to accompany this context */
  octicon: Scalars['String'];
};

/** A Gist. */
export type Github_Gist = Github_Node & Github_Starrable & Github_UniformResourceLocatable & {
  __typename?: 'Github_Gist';
  /** A list of comments associated with the gist */
  comments: Github_GistCommentConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The gist description. */
  description?: Maybe<Scalars['String']>;
  /** The files in this gist. */
  files?: Maybe<Array<Maybe<Github_GistFile>>>;
  /** A list of forks associated with the gist */
  forks: Github_GistConnection;
  id: Scalars['ID'];
  /** Identifies if the gist is a fork. */
  isFork: Scalars['Boolean'];
  /** Whether the gist is public or not. */
  isPublic: Scalars['Boolean'];
  /** The gist name. */
  name: Scalars['String'];
  /** The gist owner. */
  owner?: Maybe<Github_RepositoryOwner>;
  /** Identifies when the gist was last pushed to. */
  pushedAt?: Maybe<Scalars['DateTime']>;
  /** The HTML path to this resource. */
  resourcePath: Scalars['Github_URI'];
  /** Returns a count of how many stargazers there are on this object */
  stargazerCount: Scalars['Int'];
  /** A list of users who have starred this starrable. */
  stargazers: Github_StargazerConnection;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this Gist. */
  url: Scalars['Github_URI'];
  /** Returns a boolean indicating whether the viewing user has starred this starrable. */
  viewerHasStarred: Scalars['Boolean'];
};


/** A Gist. */
export type Github_GistCommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A Gist. */
export type Github_GistFilesArgs = {
  limit?: InputMaybe<Scalars['Int']>;
  oid?: InputMaybe<Scalars['Github_GitObjectID']>;
};


/** A Gist. */
export type Github_GistForksArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_GistOrder>;
};


/** A Gist. */
export type Github_GistStargazersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_StarOrder>;
};

/** Represents a comment on an Gist. */
export type Github_GistComment = Github_Comment & Github_Deletable & Github_Minimizable & Github_Node & Github_Updatable & Github_UpdatableComment & {
  __typename?: 'Github_GistComment';
  /** The actor who authored the comment. */
  author?: Maybe<Github_Actor>;
  /** Author's association with the gist. */
  authorAssociation: Github_CommentAuthorAssociation;
  /** Identifies the comment body. */
  body: Scalars['String'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['Github_HTML'];
  /** The body rendered to text. */
  bodyText: Scalars['String'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The actor who edited the comment. */
  editor?: Maybe<Github_Actor>;
  /** The associated gist. */
  gist: Github_Gist;
  id: Scalars['ID'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'];
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars['Boolean'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>;
  /** Returns why the comment was minimized. */
  minimizedReason?: Maybe<Scalars['String']>;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<Github_UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'];
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars['Boolean'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<Github_CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'];
};


/** Represents a comment on an Gist. */
export type Github_GistCommentUserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for GistComment. */
export type Github_GistCommentConnection = {
  __typename?: 'Github_GistCommentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_GistCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_GistComment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_GistCommentEdge = {
  __typename?: 'Github_GistCommentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_GistComment>;
};

/** The connection type for Gist. */
export type Github_GistConnection = {
  __typename?: 'Github_GistConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_GistEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Gist>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_GistEdge = {
  __typename?: 'Github_GistEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Gist>;
};

/** A file in a gist. */
export type Github_GistFile = {
  __typename?: 'Github_GistFile';
  /** The file name encoded to remove characters that are invalid in URL paths. */
  encodedName?: Maybe<Scalars['String']>;
  /** The gist file encoding. */
  encoding?: Maybe<Scalars['String']>;
  /** The file extension from the file name. */
  extension?: Maybe<Scalars['String']>;
  /** Indicates if this file is an image. */
  isImage: Scalars['Boolean'];
  /** Whether the file's contents were truncated. */
  isTruncated: Scalars['Boolean'];
  /** The programming language this file is written in. */
  language?: Maybe<Github_Language>;
  /** The gist file name. */
  name?: Maybe<Scalars['String']>;
  /** The gist file size in bytes. */
  size?: Maybe<Scalars['Int']>;
  /** UTF8 text data or null if the file is binary */
  text?: Maybe<Scalars['String']>;
};


/** A file in a gist. */
export type Github_GistFileTextArgs = {
  truncate?: InputMaybe<Scalars['Int']>;
};

/** Ordering options for gist connections */
export type Github_GistOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order repositories by. */
  field: Github_GistOrderField;
};

/** Properties by which gist connections can be ordered. */
export enum Github_GistOrderField {
  /** Order gists by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order gists by push time */
  PushedAt = 'PUSHED_AT',
  /** Order gists by update time */
  UpdatedAt = 'UPDATED_AT'
}

/** The privacy of a Gist */
export enum Github_GistPrivacy {
  /** Gists that are public and secret */
  All = 'ALL',
  /** Public */
  Public = 'PUBLIC',
  /** Secret */
  Secret = 'SECRET'
}

/** Represents an actor in a Git commit (ie. an author or committer). */
export type Github_GitActor = {
  __typename?: 'Github_GitActor';
  /** A URL pointing to the author's public avatar. */
  avatarUrl: Scalars['Github_URI'];
  /** The timestamp of the Git action (authoring or committing). */
  date?: Maybe<Scalars['Github_GitTimestamp']>;
  /** The email in the Git commit. */
  email?: Maybe<Scalars['String']>;
  /** The name in the Git commit. */
  name?: Maybe<Scalars['String']>;
  /** The GitHub user corresponding to the email field. Null if no such user exists. */
  user?: Maybe<Github_User>;
};


/** Represents an actor in a Git commit (ie. an author or committer). */
export type Github_GitActorAvatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']>;
};

/** The connection type for GitActor. */
export type Github_GitActorConnection = {
  __typename?: 'Github_GitActorConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_GitActorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_GitActor>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_GitActorEdge = {
  __typename?: 'Github_GitActorEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_GitActor>;
};

/** Represents information about the GitHub instance. */
export type Github_GitHubMetadata = {
  __typename?: 'Github_GitHubMetadata';
  /** Returns a String that's a SHA of `github-services` */
  gitHubServicesSha: Scalars['Github_GitObjectID'];
  /** IP addresses that users connect to for git operations */
  gitIpAddresses?: Maybe<Array<Scalars['String']>>;
  /** IP addresses that service hooks are sent from */
  hookIpAddresses?: Maybe<Array<Scalars['String']>>;
  /** IP addresses that the importer connects from */
  importerIpAddresses?: Maybe<Array<Scalars['String']>>;
  /** Whether or not users are verified */
  isPasswordAuthenticationVerifiable: Scalars['Boolean'];
  /** IP addresses for GitHub Pages' A records */
  pagesIpAddresses?: Maybe<Array<Scalars['String']>>;
};

/** Represents a Git object. */
export type Github_GitObject = {
  /** An abbreviated version of the Git object ID */
  abbreviatedOid: Scalars['String'];
  /** The HTTP path for this Git object */
  commitResourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this Git object */
  commitUrl: Scalars['Github_URI'];
  id: Scalars['ID'];
  /** The Git object ID */
  oid: Scalars['Github_GitObjectID'];
  /** The Repository the Git object belongs to */
  repository: Github_Repository;
};

/** Github_GitObject mock concrete type. */
export type Github_GitObject__Mock = Github_GitObject & {
  __typename?: 'Github_GitObject__Mock';
  /** An abbreviated version of the Git object ID */
  abbreviatedOid: Scalars['String'];
  /** The HTTP path for this Git object */
  commitResourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this Git object */
  commitUrl: Scalars['Github_URI'];
  id: Scalars['ID'];
  /** The Git object ID */
  oid: Scalars['Github_GitObjectID'];
  /** The Repository the Git object belongs to */
  repository: Github_Repository;
};

/** Information about a signature (GPG or S/MIME) on a Commit or Tag. */
export type Github_GitSignature = {
  /** Email used to sign this object. */
  email: Scalars['String'];
  /** True if the signature is valid and verified by GitHub. */
  isValid: Scalars['Boolean'];
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  payload: Scalars['String'];
  /** ASCII-armored signature header from object. */
  signature: Scalars['String'];
  /** GitHub user corresponding to the email signing this commit. */
  signer?: Maybe<Github_User>;
  /**
   * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
   */
  state: Github_GitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  wasSignedByGitHub: Scalars['Boolean'];
};

/** The state of a Git signature. */
export enum Github_GitSignatureState {
  /** The signing certificate or its chain could not be verified */
  BadCert = 'BAD_CERT',
  /** Invalid email used for signing */
  BadEmail = 'BAD_EMAIL',
  /** Signing key expired */
  ExpiredKey = 'EXPIRED_KEY',
  /** Internal error - the GPG verification service misbehaved */
  GpgverifyError = 'GPGVERIFY_ERROR',
  /** Internal error - the GPG verification service is unavailable at the moment */
  GpgverifyUnavailable = 'GPGVERIFY_UNAVAILABLE',
  /** Invalid signature */
  Invalid = 'INVALID',
  /** Malformed signature */
  MalformedSig = 'MALFORMED_SIG',
  /** The usage flags for the key that signed this don't allow signing */
  NotSigningKey = 'NOT_SIGNING_KEY',
  /** Email used for signing not known to GitHub */
  NoUser = 'NO_USER',
  /** Valid signature, though certificate revocation check failed */
  OcspError = 'OCSP_ERROR',
  /** Valid signature, pending certificate revocation checking */
  OcspPending = 'OCSP_PENDING',
  /** One or more certificates in chain has been revoked */
  OcspRevoked = 'OCSP_REVOKED',
  /** Key used for signing not known to GitHub */
  UnknownKey = 'UNKNOWN_KEY',
  /** Unknown signature type */
  UnknownSigType = 'UNKNOWN_SIG_TYPE',
  /** Unsigned */
  Unsigned = 'UNSIGNED',
  /** Email used for signing unverified on GitHub */
  UnverifiedEmail = 'UNVERIFIED_EMAIL',
  /** Valid signature and verified by GitHub */
  Valid = 'VALID'
}

/** Github_GitSignature mock concrete type. */
export type Github_GitSignature__Mock = Github_GitSignature & {
  __typename?: 'Github_GitSignature__Mock';
  /** Email used to sign this object. */
  email: Scalars['String'];
  /** True if the signature is valid and verified by GitHub. */
  isValid: Scalars['Boolean'];
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  payload: Scalars['String'];
  /** ASCII-armored signature header from object. */
  signature: Scalars['String'];
  /** GitHub user corresponding to the email signing this commit. */
  signer?: Maybe<Github_User>;
  /**
   * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
   */
  state: Github_GitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  wasSignedByGitHub: Scalars['Boolean'];
};

/** Represents a GPG signature on a Commit or Tag. */
export type Github_GpgSignature = Github_GitSignature & {
  __typename?: 'Github_GpgSignature';
  /** Email used to sign this object. */
  email: Scalars['String'];
  /** True if the signature is valid and verified by GitHub. */
  isValid: Scalars['Boolean'];
  /** Hex-encoded ID of the key that signed this object. */
  keyId?: Maybe<Scalars['String']>;
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  payload: Scalars['String'];
  /** ASCII-armored signature header from object. */
  signature: Scalars['String'];
  /** GitHub user corresponding to the email signing this commit. */
  signer?: Maybe<Github_User>;
  /**
   * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
   */
  state: Github_GitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  wasSignedByGitHub: Scalars['Boolean'];
};

/** Represents a 'head_ref_deleted' event on a given pull request. */
export type Github_HeadRefDeletedEvent = Github_Node & {
  __typename?: 'Github_HeadRefDeletedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the Ref associated with the `head_ref_deleted` event. */
  headRef?: Maybe<Github_Ref>;
  /** Identifies the name of the Ref associated with the `head_ref_deleted` event. */
  headRefName: Scalars['String'];
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest: Github_PullRequest;
};

/** Represents a 'head_ref_force_pushed' event on a given pull request. */
export type Github_HeadRefForcePushedEvent = Github_Node & {
  __typename?: 'Github_HeadRefForcePushedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the after commit SHA for the 'head_ref_force_pushed' event. */
  afterCommit?: Maybe<Github_Commit>;
  /** Identifies the before commit SHA for the 'head_ref_force_pushed' event. */
  beforeCommit?: Maybe<Github_Commit>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest: Github_PullRequest;
  /** Identifies the fully qualified ref name for the 'head_ref_force_pushed' event. */
  ref?: Maybe<Github_Ref>;
};

/** Represents a 'head_ref_restored' event on a given pull request. */
export type Github_HeadRefRestoredEvent = Github_Node & {
  __typename?: 'Github_HeadRefRestoredEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest: Github_PullRequest;
};

/** Detail needed to display a hovercard for a user */
export type Github_Hovercard = {
  __typename?: 'Github_Hovercard';
  /** Each of the contexts for this hovercard */
  contexts: Array<Github_HovercardContext>;
};

/** An individual line of a hovercard */
export type Github_HovercardContext = {
  /** A string describing this context */
  message: Scalars['String'];
  /** An octicon to accompany this context */
  octicon: Scalars['String'];
};

/** Github_HovercardContext mock concrete type. */
export type Github_HovercardContext__Mock = Github_HovercardContext & {
  __typename?: 'Github_HovercardContext__Mock';
  /** A string describing this context */
  message: Scalars['String'];
  /** An octicon to accompany this context */
  octicon: Scalars['String'];
};

/** The possible states in which authentication can be configured with an identity provider. */
export enum Github_IdentityProviderConfigurationState {
  /** Authentication with an identity provider is configured but not enforced. */
  Configured = 'CONFIGURED',
  /** Authentication with an identity provider is configured and enforced. */
  Enforced = 'ENFORCED',
  /** Authentication with an identity provider is not configured. */
  Unconfigured = 'UNCONFIGURED'
}

/** Autogenerated input type of ImportProject */
export type Github_ImportProjectInput = {
  /** The description of Project. */
  body?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** A list of columns containing issues and pull requests. */
  columnImports: Array<Github_ProjectColumnImport>;
  /** The name of Project. */
  name: Scalars['String'];
  /** The name of the Organization or User to create the Project under. */
  ownerName: Scalars['String'];
  /** Whether the Project is public or not. */
  public?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of ImportProject */
export type Github_ImportProjectPayload = {
  __typename?: 'Github_ImportProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new Project! */
  project?: Maybe<Github_Project>;
};

/** Autogenerated input type of InviteEnterpriseAdmin */
export type Github_InviteEnterpriseAdminInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The email of the person to invite as an administrator. */
  email?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise to which you want to invite an administrator. */
  enterpriseId: Scalars['ID'];
  /** The login of a user to invite as an administrator. */
  invitee?: InputMaybe<Scalars['String']>;
  /** The role of the administrator. */
  role?: InputMaybe<Github_EnterpriseAdministratorRole>;
};

/** Autogenerated return type of InviteEnterpriseAdmin */
export type Github_InviteEnterpriseAdminPayload = {
  __typename?: 'Github_InviteEnterpriseAdminPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The created enterprise administrator invitation. */
  invitation?: Maybe<Github_EnterpriseAdministratorInvitation>;
};

/** The possible values for the IP allow list enabled setting. */
export enum Github_IpAllowListEnabledSettingValue {
  /** The setting is disabled for the owner. */
  Disabled = 'DISABLED',
  /** The setting is enabled for the owner. */
  Enabled = 'ENABLED'
}

/** An IP address or range of addresses that is allowed to access an owner's resources. */
export type Github_IpAllowListEntry = Github_Node & {
  __typename?: 'Github_IpAllowListEntry';
  /** A single IP address or range of IP addresses in CIDR notation. */
  allowListValue: Scalars['String'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Whether the entry is currently active. */
  isActive: Scalars['Boolean'];
  /** The name of the IP allow list entry. */
  name?: Maybe<Scalars['String']>;
  /** The owner of the IP allow list entry. */
  owner: Github_IpAllowListOwner;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** The connection type for IpAllowListEntry. */
export type Github_IpAllowListEntryConnection = {
  __typename?: 'Github_IpAllowListEntryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_IpAllowListEntryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_IpAllowListEntry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_IpAllowListEntryEdge = {
  __typename?: 'Github_IpAllowListEntryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_IpAllowListEntry>;
};

/** Ordering options for IP allow list entry connections. */
export type Github_IpAllowListEntryOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order IP allow list entries by. */
  field: Github_IpAllowListEntryOrderField;
};

/** Properties by which IP allow list entry connections can be ordered. */
export enum Github_IpAllowListEntryOrderField {
  /** Order IP allow list entries by the allow list value. */
  AllowListValue = 'ALLOW_LIST_VALUE',
  /** Order IP allow list entries by creation time. */
  CreatedAt = 'CREATED_AT'
}

/** The possible values for the IP allow list configuration for installed GitHub Apps setting. */
export enum Github_IpAllowListForInstalledAppsEnabledSettingValue {
  /** The setting is disabled for the owner. */
  Disabled = 'DISABLED',
  /** The setting is enabled for the owner. */
  Enabled = 'ENABLED'
}

/** Types that can own an IP allow list. */
export type Github_IpAllowListOwner = Github_App | Github_Enterprise | Github_Organization;

/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type Github_Issue = Github_Assignable & Github_Closable & Github_Comment & Github_Labelable & Github_Lockable & Github_Node & Github_ProjectNextOwner & Github_Reactable & Github_RepositoryNode & Github_Subscribable & Github_UniformResourceLocatable & Github_Updatable & Github_UpdatableComment & {
  __typename?: 'Github_Issue';
  /** Reason that the conversation was locked. */
  activeLockReason?: Maybe<Github_LockReason>;
  /** A list of Users assigned to this object. */
  assignees: Github_UserConnection;
  /** The actor who authored the comment. */
  author?: Maybe<Github_Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: Github_CommentAuthorAssociation;
  /** Identifies the body of the issue. */
  body: Scalars['String'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['Github_HTML'];
  /** The http path for this issue body */
  bodyResourcePath: Scalars['Github_URI'];
  /** Identifies the body of the issue rendered to text. */
  bodyText: Scalars['String'];
  /** The http URL for this issue body */
  bodyUrl: Scalars['Github_URI'];
  /** `true` if the object is closed (definition of closed may depend on type) */
  closed: Scalars['Boolean'];
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']>;
  /** A list of comments associated with the Issue. */
  comments: Github_IssueCommentConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The actor who edited the comment. */
  editor?: Maybe<Github_Actor>;
  /** The hovercard information for this issue */
  hovercard: Github_Hovercard;
  id: Scalars['ID'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'];
  /** Indicates whether or not this issue is currently pinned to the repository issues list */
  isPinned?: Maybe<Scalars['Boolean']>;
  /** Is this issue read by the viewer */
  isReadByViewer?: Maybe<Scalars['Boolean']>;
  /** A list of labels associated with the object. */
  labels?: Maybe<Github_LabelConnection>;
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>;
  /** `true` if the object is locked */
  locked: Scalars['Boolean'];
  /** Identifies the milestone associated with the issue. */
  milestone?: Maybe<Github_Milestone>;
  /** Identifies the issue number. */
  number: Scalars['Int'];
  /** A list of Users that are participating in the Issue conversation. */
  participants: Github_UserConnection;
  /** List of project cards associated with this issue. */
  projectCards: Github_ProjectCardConnection;
  /** Find a project by project (beta) number. */
  projectNext?: Maybe<Github_ProjectNext>;
  /** A list of project (beta) items under the owner. */
  projectsNext: Github_ProjectNextConnection;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<Github_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: Github_ReactionConnection;
  /** The repository associated with this node. */
  repository: Github_Repository;
  /** The HTTP path for this issue */
  resourcePath: Scalars['Github_URI'];
  /** Identifies the state of the issue. */
  state: Github_IssueState;
  /**
   * A list of events, comments, commits, etc. associated with the issue.
   * @deprecated `timeline` will be removed Use Issue.timelineItems instead. Removal on 2020-10-01 UTC.
   */
  timeline: Github_IssueTimelineConnection;
  /** A list of events, comments, commits, etc. associated with the issue. */
  timelineItems: Github_IssueTimelineItemsConnection;
  /** Identifies the issue title. */
  title: Scalars['String'];
  /** Identifies the issue title rendered to HTML. */
  titleHTML: Scalars['String'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this issue */
  url: Scalars['Github_URI'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<Github_UserContentEditConnection>;
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<Github_CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<Github_SubscriptionState>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type Github_IssueAssigneesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type Github_IssueCommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_IssueCommentOrder>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type Github_IssueHovercardArgs = {
  includeNotificationContexts?: InputMaybe<Scalars['Boolean']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type Github_IssueLabelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_LabelOrder>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type Github_IssueParticipantsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type Github_IssueProjectCardsArgs = {
  after?: InputMaybe<Scalars['String']>;
  archivedStates?: InputMaybe<Array<InputMaybe<Github_ProjectCardArchivedState>>>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type Github_IssueProjectNextArgs = {
  number: Scalars['Int'];
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type Github_IssueProjectsNextArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  query?: InputMaybe<Scalars['String']>;
  sortBy?: InputMaybe<Github_ProjectNextOrderField>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type Github_IssueReactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Github_ReactionContent>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ReactionOrder>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type Github_IssueTimelineArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  since?: InputMaybe<Scalars['DateTime']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type Github_IssueTimelineItemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  itemTypes?: InputMaybe<Array<Github_IssueTimelineItemsItemType>>;
  last?: InputMaybe<Scalars['Int']>;
  since?: InputMaybe<Scalars['DateTime']>;
  skip?: InputMaybe<Scalars['Int']>;
};


/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */
export type Github_IssueUserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Represents a comment on an Issue. */
export type Github_IssueComment = Github_Comment & Github_Deletable & Github_Minimizable & Github_Node & Github_Reactable & Github_RepositoryNode & Github_Updatable & Github_UpdatableComment & {
  __typename?: 'Github_IssueComment';
  /** The actor who authored the comment. */
  author?: Maybe<Github_Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: Github_CommentAuthorAssociation;
  /** The body as Markdown. */
  body: Scalars['String'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['Github_HTML'];
  /** The body rendered to text. */
  bodyText: Scalars['String'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The actor who edited the comment. */
  editor?: Maybe<Github_Actor>;
  id: Scalars['ID'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'];
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars['Boolean'];
  /** Identifies the issue associated with the comment. */
  issue: Github_Issue;
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>;
  /** Returns why the comment was minimized. */
  minimizedReason?: Maybe<Scalars['String']>;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /**
   * Returns the pull request associated with the comment, if this comment was made on a
   * pull request.
   */
  pullRequest?: Maybe<Github_PullRequest>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<Github_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: Github_ReactionConnection;
  /** The repository associated with this node. */
  repository: Github_Repository;
  /** The HTTP path for this issue comment */
  resourcePath: Scalars['Github_URI'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this issue comment */
  url: Scalars['Github_URI'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<Github_UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'];
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars['Boolean'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<Github_CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'];
};


/** Represents a comment on an Issue. */
export type Github_IssueCommentReactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Github_ReactionContent>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ReactionOrder>;
};


/** Represents a comment on an Issue. */
export type Github_IssueCommentUserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for IssueComment. */
export type Github_IssueCommentConnection = {
  __typename?: 'Github_IssueCommentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_IssueCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_IssueComment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_IssueCommentEdge = {
  __typename?: 'Github_IssueCommentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_IssueComment>;
};

/** Ways in which lists of issue comments can be ordered upon return. */
export type Github_IssueCommentOrder = {
  /** The direction in which to order issue comments by the specified field. */
  direction: Github_OrderDirection;
  /** The field in which to order issue comments by. */
  field: Github_IssueCommentOrderField;
};

/** Properties by which issue comment connections can be ordered. */
export enum Github_IssueCommentOrderField {
  /** Order issue comments by update time */
  UpdatedAt = 'UPDATED_AT'
}

/** The connection type for Issue. */
export type Github_IssueConnection = {
  __typename?: 'Github_IssueConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_IssueEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Issue>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** This aggregates issues opened by a user within one repository. */
export type Github_IssueContributionsByRepository = {
  __typename?: 'Github_IssueContributionsByRepository';
  /** The issue contributions. */
  contributions: Github_CreatedIssueContributionConnection;
  /** The repository in which the issues were opened. */
  repository: Github_Repository;
};


/** This aggregates issues opened by a user within one repository. */
export type Github_IssueContributionsByRepositoryContributionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ContributionOrder>;
};

/** An edge in a connection. */
export type Github_IssueEdge = {
  __typename?: 'Github_IssueEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Issue>;
};

/** Ways in which to filter lists of issues. */
export type Github_IssueFilters = {
  /**
   * List issues assigned to given name. Pass in `null` for issues with no assigned
   * user, and `*` for issues assigned to any user.
   */
  assignee?: InputMaybe<Scalars['String']>;
  /** List issues created by given name. */
  createdBy?: InputMaybe<Scalars['String']>;
  /** List issues where the list of label names exist on the issue. */
  labels?: InputMaybe<Array<Scalars['String']>>;
  /** List issues where the given name is mentioned in the issue. */
  mentioned?: InputMaybe<Scalars['String']>;
  /**
   * List issues by given milestone argument. If an string representation of an
   * integer is passed, it should refer to a milestone by its number field. Pass in
   * `null` for issues with no milestone, and `*` for issues that are assigned to any milestone.
   */
  milestone?: InputMaybe<Scalars['String']>;
  /** List issues that have been updated at or after the given date. */
  since?: InputMaybe<Scalars['DateTime']>;
  /** List issues filtered by the list of states given. */
  states?: InputMaybe<Array<Github_IssueState>>;
  /** List issues subscribed to by viewer. */
  viewerSubscribed?: InputMaybe<Scalars['Boolean']>;
};

/** Used for return value of Repository.issueOrPullRequest. */
export type Github_IssueOrPullRequest = Github_Issue | Github_PullRequest;

/** Ways in which lists of issues can be ordered upon return. */
export type Github_IssueOrder = {
  /** The direction in which to order issues by the specified field. */
  direction: Github_OrderDirection;
  /** The field in which to order issues by. */
  field: Github_IssueOrderField;
};

/** Properties by which issue connections can be ordered. */
export enum Github_IssueOrderField {
  /** Order issues by comment count */
  Comments = 'COMMENTS',
  /** Order issues by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order issues by update time */
  UpdatedAt = 'UPDATED_AT'
}

/** The possible states of an issue. */
export enum Github_IssueState {
  /** An issue that has been closed */
  Closed = 'CLOSED',
  /** An issue that is still open */
  Open = 'OPEN'
}

/** A repository issue template. */
export type Github_IssueTemplate = {
  __typename?: 'Github_IssueTemplate';
  /** The template purpose. */
  about?: Maybe<Scalars['String']>;
  /** The suggested issue body. */
  body?: Maybe<Scalars['String']>;
  /** The template name. */
  name: Scalars['String'];
  /** The suggested issue title. */
  title?: Maybe<Scalars['String']>;
};

/** The connection type for IssueTimelineItem. */
export type Github_IssueTimelineConnection = {
  __typename?: 'Github_IssueTimelineConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_IssueTimelineItemEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_IssueTimelineItem>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An item in an issue timeline */
export type Github_IssueTimelineItem = Github_AssignedEvent | Github_ClosedEvent | Github_Commit | Github_CrossReferencedEvent | Github_DemilestonedEvent | Github_IssueComment | Github_LabeledEvent | Github_LockedEvent | Github_MilestonedEvent | Github_ReferencedEvent | Github_RenamedTitleEvent | Github_ReopenedEvent | Github_SubscribedEvent | Github_TransferredEvent | Github_UnassignedEvent | Github_UnlabeledEvent | Github_UnlockedEvent | Github_UnsubscribedEvent | Github_UserBlockedEvent;

/** An edge in a connection. */
export type Github_IssueTimelineItemEdge = {
  __typename?: 'Github_IssueTimelineItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_IssueTimelineItem>;
};

/** An item in an issue timeline */
export type Github_IssueTimelineItems = Github_AddedToProjectEvent | Github_AssignedEvent | Github_ClosedEvent | Github_CommentDeletedEvent | Github_ConnectedEvent | Github_ConvertedNoteToIssueEvent | Github_ConvertedToDiscussionEvent | Github_CrossReferencedEvent | Github_DemilestonedEvent | Github_DisconnectedEvent | Github_IssueComment | Github_LabeledEvent | Github_LockedEvent | Github_MarkedAsDuplicateEvent | Github_MentionedEvent | Github_MilestonedEvent | Github_MovedColumnsInProjectEvent | Github_PinnedEvent | Github_ReferencedEvent | Github_RemovedFromProjectEvent | Github_RenamedTitleEvent | Github_ReopenedEvent | Github_SubscribedEvent | Github_TransferredEvent | Github_UnassignedEvent | Github_UnlabeledEvent | Github_UnlockedEvent | Github_UnmarkedAsDuplicateEvent | Github_UnpinnedEvent | Github_UnsubscribedEvent | Github_UserBlockedEvent;

/** The connection type for IssueTimelineItems. */
export type Github_IssueTimelineItemsConnection = {
  __typename?: 'Github_IssueTimelineItemsConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_IssueTimelineItemsEdge>>>;
  /** Identifies the count of items after applying `before` and `after` filters. */
  filteredCount: Scalars['Int'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_IssueTimelineItems>>>;
  /** Identifies the count of items after applying `before`/`after` filters and `first`/`last`/`skip` slicing. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
  /** Identifies the date and time when the timeline was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** An edge in a connection. */
export type Github_IssueTimelineItemsEdge = {
  __typename?: 'Github_IssueTimelineItemsEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_IssueTimelineItems>;
};

/** The possible item types found in a timeline. */
export enum Github_IssueTimelineItemsItemType {
  /** Represents a 'added_to_project' event on a given issue or pull request. */
  AddedToProjectEvent = 'ADDED_TO_PROJECT_EVENT',
  /** Represents an 'assigned' event on any assignable object. */
  AssignedEvent = 'ASSIGNED_EVENT',
  /** Represents a 'closed' event on any `Closable`. */
  ClosedEvent = 'CLOSED_EVENT',
  /** Represents a 'comment_deleted' event on a given issue or pull request. */
  CommentDeletedEvent = 'COMMENT_DELETED_EVENT',
  /** Represents a 'connected' event on a given issue or pull request. */
  ConnectedEvent = 'CONNECTED_EVENT',
  /** Represents a 'converted_note_to_issue' event on a given issue or pull request. */
  ConvertedNoteToIssueEvent = 'CONVERTED_NOTE_TO_ISSUE_EVENT',
  /** Represents a 'converted_to_discussion' event on a given issue. */
  ConvertedToDiscussionEvent = 'CONVERTED_TO_DISCUSSION_EVENT',
  /** Represents a mention made by one issue or pull request to another. */
  CrossReferencedEvent = 'CROSS_REFERENCED_EVENT',
  /** Represents a 'demilestoned' event on a given issue or pull request. */
  DemilestonedEvent = 'DEMILESTONED_EVENT',
  /** Represents a 'disconnected' event on a given issue or pull request. */
  DisconnectedEvent = 'DISCONNECTED_EVENT',
  /** Represents a comment on an Issue. */
  IssueComment = 'ISSUE_COMMENT',
  /** Represents a 'labeled' event on a given issue or pull request. */
  LabeledEvent = 'LABELED_EVENT',
  /** Represents a 'locked' event on a given issue or pull request. */
  LockedEvent = 'LOCKED_EVENT',
  /** Represents a 'marked_as_duplicate' event on a given issue or pull request. */
  MarkedAsDuplicateEvent = 'MARKED_AS_DUPLICATE_EVENT',
  /** Represents a 'mentioned' event on a given issue or pull request. */
  MentionedEvent = 'MENTIONED_EVENT',
  /** Represents a 'milestoned' event on a given issue or pull request. */
  MilestonedEvent = 'MILESTONED_EVENT',
  /** Represents a 'moved_columns_in_project' event on a given issue or pull request. */
  MovedColumnsInProjectEvent = 'MOVED_COLUMNS_IN_PROJECT_EVENT',
  /** Represents a 'pinned' event on a given issue or pull request. */
  PinnedEvent = 'PINNED_EVENT',
  /** Represents a 'referenced' event on a given `ReferencedSubject`. */
  ReferencedEvent = 'REFERENCED_EVENT',
  /** Represents a 'removed_from_project' event on a given issue or pull request. */
  RemovedFromProjectEvent = 'REMOVED_FROM_PROJECT_EVENT',
  /** Represents a 'renamed' event on a given issue or pull request */
  RenamedTitleEvent = 'RENAMED_TITLE_EVENT',
  /** Represents a 'reopened' event on any `Closable`. */
  ReopenedEvent = 'REOPENED_EVENT',
  /** Represents a 'subscribed' event on a given `Subscribable`. */
  SubscribedEvent = 'SUBSCRIBED_EVENT',
  /** Represents a 'transferred' event on a given issue or pull request. */
  TransferredEvent = 'TRANSFERRED_EVENT',
  /** Represents an 'unassigned' event on any assignable object. */
  UnassignedEvent = 'UNASSIGNED_EVENT',
  /** Represents an 'unlabeled' event on a given issue or pull request. */
  UnlabeledEvent = 'UNLABELED_EVENT',
  /** Represents an 'unlocked' event on a given issue or pull request. */
  UnlockedEvent = 'UNLOCKED_EVENT',
  /** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */
  UnmarkedAsDuplicateEvent = 'UNMARKED_AS_DUPLICATE_EVENT',
  /** Represents an 'unpinned' event on a given issue or pull request. */
  UnpinnedEvent = 'UNPINNED_EVENT',
  /** Represents an 'unsubscribed' event on a given `Subscribable`. */
  UnsubscribedEvent = 'UNSUBSCRIBED_EVENT',
  /** Represents a 'user_blocked' event on a given user. */
  UserBlockedEvent = 'USER_BLOCKED_EVENT'
}

/** Represents a user signing up for a GitHub account. */
export type Github_JoinedGitHubContribution = Github_Contribution & {
  __typename?: 'Github_JoinedGitHubContribution';
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean'];
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime'];
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this contribution. */
  url: Scalars['Github_URI'];
  /** The user who made this contribution. */
  user: Github_User;
};

/** A label for categorizing Issues, Pull Requests, Milestones, or Discussions with a given Repository. */
export type Github_Label = Github_Node & {
  __typename?: 'Github_Label';
  /** Identifies the label color. */
  color: Scalars['String'];
  /** Identifies the date and time when the label was created. */
  createdAt?: Maybe<Scalars['DateTime']>;
  /** A brief description of this label. */
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** Indicates whether or not this is a default label. */
  isDefault: Scalars['Boolean'];
  /** A list of issues associated with this label. */
  issues: Github_IssueConnection;
  /** Identifies the label name. */
  name: Scalars['String'];
  /** A list of pull requests associated with this label. */
  pullRequests: Github_PullRequestConnection;
  /** The repository associated with this label. */
  repository: Github_Repository;
  /** The HTTP path for this label. */
  resourcePath: Scalars['Github_URI'];
  /** Identifies the date and time when the label was last updated. */
  updatedAt?: Maybe<Scalars['DateTime']>;
  /** The HTTP URL for this label. */
  url: Scalars['Github_URI'];
};


/** A label for categorizing Issues, Pull Requests, Milestones, or Discussions with a given Repository. */
export type Github_LabelIssuesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filterBy?: InputMaybe<Github_IssueFilters>;
  first?: InputMaybe<Scalars['Int']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_IssueOrder>;
  states?: InputMaybe<Array<Github_IssueState>>;
};


/** A label for categorizing Issues, Pull Requests, Milestones, or Discussions with a given Repository. */
export type Github_LabelPullRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  baseRefName?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  headRefName?: InputMaybe<Scalars['String']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_IssueOrder>;
  states?: InputMaybe<Array<Github_PullRequestState>>;
};

/** The connection type for Label. */
export type Github_LabelConnection = {
  __typename?: 'Github_LabelConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_LabelEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Label>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_LabelEdge = {
  __typename?: 'Github_LabelEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Label>;
};

/** Ways in which lists of labels can be ordered upon return. */
export type Github_LabelOrder = {
  /** The direction in which to order labels by the specified field. */
  direction: Github_OrderDirection;
  /** The field in which to order labels by. */
  field: Github_LabelOrderField;
};

/** Properties by which label connections can be ordered. */
export enum Github_LabelOrderField {
  /** Order labels by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order labels by name */
  Name = 'NAME'
}

/** An object that can have labels assigned to it. */
export type Github_Labelable = {
  /** A list of labels associated with the object. */
  labels?: Maybe<Github_LabelConnection>;
};


/** An object that can have labels assigned to it. */
export type Github_LabelableLabelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_LabelOrder>;
};

/** Github_Labelable mock concrete type. */
export type Github_Labelable__Mock = Github_Labelable & {
  __typename?: 'Github_Labelable__Mock';
  /** A list of labels associated with the object. */
  labels?: Maybe<Github_LabelConnection>;
};


/** Github_Labelable mock concrete type. */
export type Github_Labelable__MockLabelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_LabelOrder>;
};

/** Represents a 'labeled' event on a given issue or pull request. */
export type Github_LabeledEvent = Github_Node & {
  __typename?: 'Github_LabeledEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Identifies the label associated with the 'labeled' event. */
  label: Github_Label;
  /** Identifies the `Labelable` associated with the event. */
  labelable: Github_Labelable;
};

/** Represents a given language found in repositories. */
export type Github_Language = Github_Node & {
  __typename?: 'Github_Language';
  /** The color defined for the current language. */
  color?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The name of the current language. */
  name: Scalars['String'];
};

/** A list of languages associated with the parent. */
export type Github_LanguageConnection = {
  __typename?: 'Github_LanguageConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_LanguageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Language>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
  /** The total size in bytes of files written in that language. */
  totalSize: Scalars['Int'];
};

/** Represents the language of a repository. */
export type Github_LanguageEdge = {
  __typename?: 'Github_LanguageEdge';
  cursor: Scalars['String'];
  node: Github_Language;
  /** The number of bytes of code written in the language. */
  size: Scalars['Int'];
};

/** Ordering options for language connections. */
export type Github_LanguageOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order languages by. */
  field: Github_LanguageOrderField;
};

/** Properties by which language connections can be ordered. */
export enum Github_LanguageOrderField {
  /** Order languages by the size of all files containing the language */
  Size = 'SIZE'
}

/** A repository's open source license */
export type Github_License = Github_Node & {
  __typename?: 'Github_License';
  /** The full text of the license */
  body: Scalars['String'];
  /** The conditions set by the license */
  conditions: Array<Maybe<Github_LicenseRule>>;
  /** A human-readable description of the license */
  description?: Maybe<Scalars['String']>;
  /** Whether the license should be featured */
  featured: Scalars['Boolean'];
  /** Whether the license should be displayed in license pickers */
  hidden: Scalars['Boolean'];
  id: Scalars['ID'];
  /** Instructions on how to implement the license */
  implementation?: Maybe<Scalars['String']>;
  /** The lowercased SPDX ID of the license */
  key: Scalars['String'];
  /** The limitations set by the license */
  limitations: Array<Maybe<Github_LicenseRule>>;
  /** The license full name specified by <https://spdx.org/licenses> */
  name: Scalars['String'];
  /** Customary short name if applicable (e.g, GPLv3) */
  nickname?: Maybe<Scalars['String']>;
  /** The permissions set by the license */
  permissions: Array<Maybe<Github_LicenseRule>>;
  /** Whether the license is a pseudo-license placeholder (e.g., other, no-license) */
  pseudoLicense: Scalars['Boolean'];
  /** Short identifier specified by <https://spdx.org/licenses> */
  spdxId?: Maybe<Scalars['String']>;
  /** URL to the license on <https://choosealicense.com> */
  url?: Maybe<Scalars['Github_URI']>;
};

/** Describes a License's conditions, permissions, and limitations */
export type Github_LicenseRule = {
  __typename?: 'Github_LicenseRule';
  /** A description of the rule */
  description: Scalars['String'];
  /** The machine-readable rule key */
  key: Scalars['String'];
  /** The human-readable rule label */
  label: Scalars['String'];
};

/** Autogenerated input type of LinkRepositoryToProject */
export type Github_LinkRepositoryToProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the Project to link to a Repository */
  projectId: Scalars['ID'];
  /** The ID of the Repository to link to a Project. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of LinkRepositoryToProject */
export type Github_LinkRepositoryToProjectPayload = {
  __typename?: 'Github_LinkRepositoryToProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The linked Project. */
  project?: Maybe<Github_Project>;
  /** The linked Repository. */
  repository?: Maybe<Github_Repository>;
};

/** Autogenerated input type of LockLockable */
export type Github_LockLockableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** A reason for why the item will be locked. */
  lockReason?: InputMaybe<Github_LockReason>;
  /** ID of the item to be locked. */
  lockableId: Scalars['ID'];
};

/** Autogenerated return type of LockLockable */
export type Github_LockLockablePayload = {
  __typename?: 'Github_LockLockablePayload';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The item that was locked. */
  lockedRecord?: Maybe<Github_Lockable>;
};

/** The possible reasons that an issue or pull request was locked. */
export enum Github_LockReason {
  /** The issue or pull request was locked because the conversation was off-topic. */
  OffTopic = 'OFF_TOPIC',
  /** The issue or pull request was locked because the conversation was resolved. */
  Resolved = 'RESOLVED',
  /** The issue or pull request was locked because the conversation was spam. */
  Spam = 'SPAM',
  /** The issue or pull request was locked because the conversation was too heated. */
  TooHeated = 'TOO_HEATED'
}

/** An object that can be locked. */
export type Github_Lockable = {
  /** Reason that the conversation was locked. */
  activeLockReason?: Maybe<Github_LockReason>;
  /** `true` if the object is locked */
  locked: Scalars['Boolean'];
};

/** Github_Lockable mock concrete type. */
export type Github_Lockable__Mock = Github_Lockable & {
  __typename?: 'Github_Lockable__Mock';
  /** Reason that the conversation was locked. */
  activeLockReason?: Maybe<Github_LockReason>;
  /** `true` if the object is locked */
  locked: Scalars['Boolean'];
};

/** Represents a 'locked' event on a given issue or pull request. */
export type Github_LockedEvent = Github_Node & {
  __typename?: 'Github_LockedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Reason that the conversation was locked (optional). */
  lockReason?: Maybe<Github_LockReason>;
  /** Object that was locked. */
  lockable: Github_Lockable;
};

/** A placeholder user for attribution of imported data on GitHub. */
export type Github_Mannequin = Github_Actor & Github_Node & Github_UniformResourceLocatable & {
  __typename?: 'Github_Mannequin';
  /** A URL pointing to the GitHub App's public avatar. */
  avatarUrl: Scalars['Github_URI'];
  /** The user that has claimed the data attributed to this mannequin. */
  claimant?: Maybe<Github_User>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The mannequin's email on the source instance. */
  email?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The username of the actor. */
  login: Scalars['String'];
  /** The HTML path to this resource. */
  resourcePath: Scalars['Github_URI'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The URL to this resource. */
  url: Scalars['Github_URI'];
};


/** A placeholder user for attribution of imported data on GitHub. */
export type Github_MannequinAvatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated input type of MarkDiscussionCommentAsAnswer */
export type Github_MarkDiscussionCommentAsAnswerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the discussion comment to mark as an answer. */
  id: Scalars['ID'];
};

/** Autogenerated return type of MarkDiscussionCommentAsAnswer */
export type Github_MarkDiscussionCommentAsAnswerPayload = {
  __typename?: 'Github_MarkDiscussionCommentAsAnswerPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The discussion that includes the chosen comment. */
  discussion?: Maybe<Github_Discussion>;
};

/** Autogenerated input type of MarkFileAsViewed */
export type Github_MarkFileAsViewedInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The path of the file to mark as viewed */
  path: Scalars['String'];
  /** The Node ID of the pull request. */
  pullRequestId: Scalars['ID'];
};

/** Autogenerated return type of MarkFileAsViewed */
export type Github_MarkFileAsViewedPayload = {
  __typename?: 'Github_MarkFileAsViewedPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated pull request. */
  pullRequest?: Maybe<Github_PullRequest>;
};

/** Autogenerated input type of MarkPullRequestReadyForReview */
export type Github_MarkPullRequestReadyForReviewInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the pull request to be marked as ready for review. */
  pullRequestId: Scalars['ID'];
};

/** Autogenerated return type of MarkPullRequestReadyForReview */
export type Github_MarkPullRequestReadyForReviewPayload = {
  __typename?: 'Github_MarkPullRequestReadyForReviewPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The pull request that is ready for review. */
  pullRequest?: Maybe<Github_PullRequest>;
};

/** Represents a 'marked_as_duplicate' event on a given issue or pull request. */
export type Github_MarkedAsDuplicateEvent = Github_Node & {
  __typename?: 'Github_MarkedAsDuplicateEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** The authoritative issue or pull request which has been duplicated by another. */
  canonical?: Maybe<Github_IssueOrPullRequest>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The issue or pull request which has been marked as a duplicate of another. */
  duplicate?: Maybe<Github_IssueOrPullRequest>;
  id: Scalars['ID'];
  /** Canonical and duplicate belong to different repositories. */
  isCrossRepository: Scalars['Boolean'];
};

/** A public description of a Marketplace category. */
export type Github_MarketplaceCategory = Github_Node & {
  __typename?: 'Github_MarketplaceCategory';
  /** The category's description. */
  description?: Maybe<Scalars['String']>;
  /** The technical description of how apps listed in this category work with GitHub. */
  howItWorks?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The category's name. */
  name: Scalars['String'];
  /** How many Marketplace listings have this as their primary category. */
  primaryListingCount: Scalars['Int'];
  /** The HTTP path for this Marketplace category. */
  resourcePath: Scalars['Github_URI'];
  /** How many Marketplace listings have this as their secondary category. */
  secondaryListingCount: Scalars['Int'];
  /** The short name of the category used in its URL. */
  slug: Scalars['String'];
  /** The HTTP URL for this Marketplace category. */
  url: Scalars['Github_URI'];
};

/** A listing in the GitHub integration marketplace. */
export type Github_MarketplaceListing = Github_Node & {
  __typename?: 'Github_MarketplaceListing';
  /** The GitHub App this listing represents. */
  app?: Maybe<Github_App>;
  /** URL to the listing owner's company site. */
  companyUrl?: Maybe<Scalars['Github_URI']>;
  /** The HTTP path for configuring access to the listing's integration or OAuth app */
  configurationResourcePath: Scalars['Github_URI'];
  /** The HTTP URL for configuring access to the listing's integration or OAuth app */
  configurationUrl: Scalars['Github_URI'];
  /** URL to the listing's documentation. */
  documentationUrl?: Maybe<Scalars['Github_URI']>;
  /** The listing's detailed description. */
  extendedDescription?: Maybe<Scalars['String']>;
  /** The listing's detailed description rendered to HTML. */
  extendedDescriptionHTML: Scalars['Github_HTML'];
  /** The listing's introductory description. */
  fullDescription: Scalars['String'];
  /** The listing's introductory description rendered to HTML. */
  fullDescriptionHTML: Scalars['Github_HTML'];
  /** Does this listing have any plans with a free trial? */
  hasPublishedFreeTrialPlans: Scalars['Boolean'];
  /** Does this listing have a terms of service link? */
  hasTermsOfService: Scalars['Boolean'];
  /** Whether the creator of the app is a verified org */
  hasVerifiedOwner: Scalars['Boolean'];
  /** A technical description of how this app works with GitHub. */
  howItWorks?: Maybe<Scalars['String']>;
  /** The listing's technical description rendered to HTML. */
  howItWorksHTML: Scalars['Github_HTML'];
  id: Scalars['ID'];
  /** URL to install the product to the viewer's account or organization. */
  installationUrl?: Maybe<Scalars['Github_URI']>;
  /** Whether this listing's app has been installed for the current viewer */
  installedForViewer: Scalars['Boolean'];
  /** Whether this listing has been removed from the Marketplace. */
  isArchived: Scalars['Boolean'];
  /**
   * Whether this listing is still an editable draft that has not been submitted
   * for review and is not publicly visible in the Marketplace.
   */
  isDraft: Scalars['Boolean'];
  /** Whether the product this listing represents is available as part of a paid plan. */
  isPaid: Scalars['Boolean'];
  /** Whether this listing has been approved for display in the Marketplace. */
  isPublic: Scalars['Boolean'];
  /** Whether this listing has been rejected by GitHub for display in the Marketplace. */
  isRejected: Scalars['Boolean'];
  /** Whether this listing has been approved for unverified display in the Marketplace. */
  isUnverified: Scalars['Boolean'];
  /** Whether this draft listing has been submitted for review for approval to be unverified in the Marketplace. */
  isUnverifiedPending: Scalars['Boolean'];
  /** Whether this draft listing has been submitted for review from GitHub for approval to be verified in the Marketplace. */
  isVerificationPendingFromDraft: Scalars['Boolean'];
  /** Whether this unverified listing has been submitted for review from GitHub for approval to be verified in the Marketplace. */
  isVerificationPendingFromUnverified: Scalars['Boolean'];
  /** Whether this listing has been approved for verified display in the Marketplace. */
  isVerified: Scalars['Boolean'];
  /** The hex color code, without the leading '#', for the logo background. */
  logoBackgroundColor: Scalars['String'];
  /** URL for the listing's logo image. */
  logoUrl?: Maybe<Scalars['Github_URI']>;
  /** The listing's full name. */
  name: Scalars['String'];
  /** The listing's very short description without a trailing period or ampersands. */
  normalizedShortDescription: Scalars['String'];
  /** URL to the listing's detailed pricing. */
  pricingUrl?: Maybe<Scalars['Github_URI']>;
  /** The category that best describes the listing. */
  primaryCategory: Github_MarketplaceCategory;
  /** URL to the listing's privacy policy, may return an empty string for listings that do not require a privacy policy URL. */
  privacyPolicyUrl: Scalars['Github_URI'];
  /** The HTTP path for the Marketplace listing. */
  resourcePath: Scalars['Github_URI'];
  /** The URLs for the listing's screenshots. */
  screenshotUrls: Array<Maybe<Scalars['String']>>;
  /** An alternate category that describes the listing. */
  secondaryCategory?: Maybe<Github_MarketplaceCategory>;
  /** The listing's very short description. */
  shortDescription: Scalars['String'];
  /** The short name of the listing used in its URL. */
  slug: Scalars['String'];
  /** URL to the listing's status page. */
  statusUrl?: Maybe<Scalars['Github_URI']>;
  /** An email address for support for this listing's app. */
  supportEmail?: Maybe<Scalars['String']>;
  /**
   * Either a URL or an email address for support for this listing's app, may
   * return an empty string for listings that do not require a support URL.
   */
  supportUrl: Scalars['Github_URI'];
  /** URL to the listing's terms of service. */
  termsOfServiceUrl?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the Marketplace listing. */
  url: Scalars['Github_URI'];
  /** Can the current viewer add plans for this Marketplace listing. */
  viewerCanAddPlans: Scalars['Boolean'];
  /** Can the current viewer approve this Marketplace listing. */
  viewerCanApprove: Scalars['Boolean'];
  /** Can the current viewer delist this Marketplace listing. */
  viewerCanDelist: Scalars['Boolean'];
  /** Can the current viewer edit this Marketplace listing. */
  viewerCanEdit: Scalars['Boolean'];
  /**
   * Can the current viewer edit the primary and secondary category of this
   * Marketplace listing.
   */
  viewerCanEditCategories: Scalars['Boolean'];
  /** Can the current viewer edit the plans for this Marketplace listing. */
  viewerCanEditPlans: Scalars['Boolean'];
  /**
   * Can the current viewer return this Marketplace listing to draft state
   * so it becomes editable again.
   */
  viewerCanRedraft: Scalars['Boolean'];
  /**
   * Can the current viewer reject this Marketplace listing by returning it to
   * an editable draft state or rejecting it entirely.
   */
  viewerCanReject: Scalars['Boolean'];
  /**
   * Can the current viewer request this listing be reviewed for display in
   * the Marketplace as verified.
   */
  viewerCanRequestApproval: Scalars['Boolean'];
  /** Indicates whether the current user has an active subscription to this Marketplace listing. */
  viewerHasPurchased: Scalars['Boolean'];
  /**
   * Indicates if the current user has purchased a subscription to this Marketplace listing
   * for all of the organizations the user owns.
   */
  viewerHasPurchasedForAllOrganizations: Scalars['Boolean'];
  /** Does the current viewer role allow them to administer this Marketplace listing. */
  viewerIsListingAdmin: Scalars['Boolean'];
};


/** A listing in the GitHub integration marketplace. */
export type Github_MarketplaceListingLogoUrlArgs = {
  size?: InputMaybe<Scalars['Int']>;
};

/** Look up Marketplace Listings */
export type Github_MarketplaceListingConnection = {
  __typename?: 'Github_MarketplaceListingConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_MarketplaceListingEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_MarketplaceListing>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_MarketplaceListingEdge = {
  __typename?: 'Github_MarketplaceListingEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_MarketplaceListing>;
};

/** Entities that have members who can set status messages. */
export type Github_MemberStatusable = {
  /** Get the status messages members of this entity have set that are either public or visible only to the organization. */
  memberStatuses: Github_UserStatusConnection;
};


/** Entities that have members who can set status messages. */
export type Github_MemberStatusableMemberStatusesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_UserStatusOrder>;
};

/** Github_MemberStatusable mock concrete type. */
export type Github_MemberStatusable__Mock = Github_MemberStatusable & {
  __typename?: 'Github_MemberStatusable__Mock';
  /** Get the status messages members of this entity have set that are either public or visible only to the organization. */
  memberStatuses: Github_UserStatusConnection;
};


/** Github_MemberStatusable mock concrete type. */
export type Github_MemberStatusable__MockMemberStatusesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_UserStatusOrder>;
};

/** Audit log entry for a members_can_delete_repos.clear event. */
export type Github_MembersCanDeleteReposClearAuditEntry = Github_AuditEntry & Github_EnterpriseAuditEntryData & Github_Node & Github_OrganizationAuditEntryData & {
  __typename?: 'Github_MembersCanDeleteReposClearAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['Github_URI']>;
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a members_can_delete_repos.disable event. */
export type Github_MembersCanDeleteReposDisableAuditEntry = Github_AuditEntry & Github_EnterpriseAuditEntryData & Github_Node & Github_OrganizationAuditEntryData & {
  __typename?: 'Github_MembersCanDeleteReposDisableAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['Github_URI']>;
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a members_can_delete_repos.enable event. */
export type Github_MembersCanDeleteReposEnableAuditEntry = Github_AuditEntry & Github_EnterpriseAuditEntryData & Github_Node & Github_OrganizationAuditEntryData & {
  __typename?: 'Github_MembersCanDeleteReposEnableAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['Github_URI']>;
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Represents a 'mentioned' event on a given issue or pull request. */
export type Github_MentionedEvent = Github_Node & {
  __typename?: 'Github_MentionedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
};

/** Autogenerated input type of MergeBranch */
export type Github_MergeBranchInput = {
  /** The email address to associate with this commit. */
  authorEmail?: InputMaybe<Scalars['String']>;
  /** The name of the base branch that the provided head will be merged into. */
  base: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Message to use for the merge commit. If omitted, a default will be used. */
  commitMessage?: InputMaybe<Scalars['String']>;
  /** The head to merge into the base branch. This can be a branch name or a commit GitObjectID. */
  head: Scalars['String'];
  /** The Node ID of the Repository containing the base branch that will be modified. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of MergeBranch */
export type Github_MergeBranchPayload = {
  __typename?: 'Github_MergeBranchPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The resulting merge Commit. */
  mergeCommit?: Maybe<Github_Commit>;
};

/** Autogenerated input type of MergePullRequest */
export type Github_MergePullRequestInput = {
  /** The email address to associate with this merge. */
  authorEmail?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Commit body to use for the merge commit; if omitted, a default message will be used */
  commitBody?: InputMaybe<Scalars['String']>;
  /** Commit headline to use for the merge commit; if omitted, a default message will be used. */
  commitHeadline?: InputMaybe<Scalars['String']>;
  /** OID that the pull request head ref must match to allow merge; if omitted, no check is performed. */
  expectedHeadOid?: InputMaybe<Scalars['Github_GitObjectID']>;
  /** The merge method to use. If omitted, defaults to 'MERGE' */
  mergeMethod?: InputMaybe<Github_PullRequestMergeMethod>;
  /** ID of the pull request to be merged. */
  pullRequestId: Scalars['ID'];
};

/** Autogenerated return type of MergePullRequest */
export type Github_MergePullRequestPayload = {
  __typename?: 'Github_MergePullRequestPayload';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The pull request that was merged. */
  pullRequest?: Maybe<Github_PullRequest>;
};

/** Detailed status information about a pull request merge. */
export enum Github_MergeStateStatus {
  /** The head ref is out of date. */
  Behind = 'BEHIND',
  /** The merge is blocked. */
  Blocked = 'BLOCKED',
  /** Mergeable and passing commit status. */
  Clean = 'CLEAN',
  /** The merge commit cannot be cleanly created. */
  Dirty = 'DIRTY',
  /**
   * The merge is blocked due to the pull request being a draft.
   * @deprecated DRAFT state will be removed from this enum and `isDraft` should be used instead Use PullRequest.isDraft instead. Removal on 2021-01-01 UTC.
   */
  Draft = 'DRAFT',
  /** Mergeable with passing commit status and pre-receive hooks. */
  HasHooks = 'HAS_HOOKS',
  /** The state cannot currently be determined. */
  Unknown = 'UNKNOWN',
  /** Mergeable with non-passing commit status. */
  Unstable = 'UNSTABLE'
}

/** Whether or not a PullRequest can be merged. */
export enum Github_MergeableState {
  /** The pull request cannot be merged due to merge conflicts. */
  Conflicting = 'CONFLICTING',
  /** The pull request can be merged. */
  Mergeable = 'MERGEABLE',
  /** The mergeability of the pull request is still being calculated. */
  Unknown = 'UNKNOWN'
}

/** Represents a 'merged' event on a given pull request. */
export type Github_MergedEvent = Github_Node & Github_UniformResourceLocatable & {
  __typename?: 'Github_MergedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the commit associated with the `merge` event. */
  commit?: Maybe<Github_Commit>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Identifies the Ref associated with the `merge` event. */
  mergeRef?: Maybe<Github_Ref>;
  /** Identifies the name of the Ref associated with the `merge` event. */
  mergeRefName: Scalars['String'];
  /** PullRequest referenced by event. */
  pullRequest: Github_PullRequest;
  /** The HTTP path for this merged event. */
  resourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this merged event. */
  url: Scalars['Github_URI'];
};

/** Represents a Milestone object on a given repository. */
export type Github_Milestone = Github_Closable & Github_Node & Github_UniformResourceLocatable & {
  __typename?: 'Github_Milestone';
  /** `true` if the object is closed (definition of closed may depend on type) */
  closed: Scalars['Boolean'];
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the actor who created the milestone. */
  creator?: Maybe<Github_Actor>;
  /** Identifies the description of the milestone. */
  description?: Maybe<Scalars['String']>;
  /** Identifies the due date of the milestone. */
  dueOn?: Maybe<Scalars['DateTime']>;
  id: Scalars['ID'];
  /** A list of issues associated with the milestone. */
  issues: Github_IssueConnection;
  /** Identifies the number of the milestone. */
  number: Scalars['Int'];
  /** Identifies the percentage complete for the milestone */
  progressPercentage: Scalars['Float'];
  /** A list of pull requests associated with the milestone. */
  pullRequests: Github_PullRequestConnection;
  /** The repository associated with this milestone. */
  repository: Github_Repository;
  /** The HTTP path for this milestone */
  resourcePath: Scalars['Github_URI'];
  /** Identifies the state of the milestone. */
  state: Github_MilestoneState;
  /** Identifies the title of the milestone. */
  title: Scalars['String'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this milestone */
  url: Scalars['Github_URI'];
};


/** Represents a Milestone object on a given repository. */
export type Github_MilestoneIssuesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filterBy?: InputMaybe<Github_IssueFilters>;
  first?: InputMaybe<Scalars['Int']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_IssueOrder>;
  states?: InputMaybe<Array<Github_IssueState>>;
};


/** Represents a Milestone object on a given repository. */
export type Github_MilestonePullRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  baseRefName?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  headRefName?: InputMaybe<Scalars['String']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_IssueOrder>;
  states?: InputMaybe<Array<Github_PullRequestState>>;
};

/** The connection type for Milestone. */
export type Github_MilestoneConnection = {
  __typename?: 'Github_MilestoneConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_MilestoneEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Milestone>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_MilestoneEdge = {
  __typename?: 'Github_MilestoneEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Milestone>;
};

/** Types that can be inside a Milestone. */
export type Github_MilestoneItem = Github_Issue | Github_PullRequest;

/** Ordering options for milestone connections. */
export type Github_MilestoneOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order milestones by. */
  field: Github_MilestoneOrderField;
};

/** Properties by which milestone connections can be ordered. */
export enum Github_MilestoneOrderField {
  /** Order milestones by when they were created. */
  CreatedAt = 'CREATED_AT',
  /** Order milestones by when they are due. */
  DueDate = 'DUE_DATE',
  /** Order milestones by their number. */
  Number = 'NUMBER',
  /** Order milestones by when they were last updated. */
  UpdatedAt = 'UPDATED_AT'
}

/** The possible states of a milestone. */
export enum Github_MilestoneState {
  /** A milestone that has been closed. */
  Closed = 'CLOSED',
  /** A milestone that is still open. */
  Open = 'OPEN'
}

/** Represents a 'milestoned' event on a given issue or pull request. */
export type Github_MilestonedEvent = Github_Node & {
  __typename?: 'Github_MilestonedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Identifies the milestone title associated with the 'milestoned' event. */
  milestoneTitle: Scalars['String'];
  /** Object referenced by event. */
  subject: Github_MilestoneItem;
};

/** Entities that can be minimized. */
export type Github_Minimizable = {
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars['Boolean'];
  /** Returns why the comment was minimized. */
  minimizedReason?: Maybe<Scalars['String']>;
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars['Boolean'];
};

/** Github_Minimizable mock concrete type. */
export type Github_Minimizable__Mock = Github_Minimizable & {
  __typename?: 'Github_Minimizable__Mock';
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars['Boolean'];
  /** Returns why the comment was minimized. */
  minimizedReason?: Maybe<Scalars['String']>;
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars['Boolean'];
};

/** Autogenerated input type of MinimizeComment */
export type Github_MinimizeCommentInput = {
  /** The classification of comment */
  classifier: Github_ReportedContentClassifiers;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID'];
};

/** Autogenerated return type of MinimizeComment */
export type Github_MinimizeCommentPayload = {
  __typename?: 'Github_MinimizeCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The comment that was minimized. */
  minimizedComment?: Maybe<Github_Minimizable>;
};

/** Autogenerated input type of MoveProjectCard */
export type Github_MoveProjectCardInput = {
  /** Place the new card after the card with this id. Pass null to place it at the top. */
  afterCardId?: InputMaybe<Scalars['ID']>;
  /** The id of the card to move. */
  cardId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The id of the column to move it into. */
  columnId: Scalars['ID'];
};

/** Autogenerated return type of MoveProjectCard */
export type Github_MoveProjectCardPayload = {
  __typename?: 'Github_MoveProjectCardPayload';
  /** The new edge of the moved card. */
  cardEdge?: Maybe<Github_ProjectCardEdge>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of MoveProjectColumn */
export type Github_MoveProjectColumnInput = {
  /** Place the new column after the column with this id. Pass null to place it at the front. */
  afterColumnId?: InputMaybe<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The id of the column to move. */
  columnId: Scalars['ID'];
};

/** Autogenerated return type of MoveProjectColumn */
export type Github_MoveProjectColumnPayload = {
  __typename?: 'Github_MoveProjectColumnPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The new edge of the moved column. */
  columnEdge?: Maybe<Github_ProjectColumnEdge>;
};

/** Represents a 'moved_columns_in_project' event on a given issue or pull request. */
export type Github_MovedColumnsInProjectEvent = Github_Node & {
  __typename?: 'Github_MovedColumnsInProjectEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** Column name the issue or pull request was moved from. */
  previousProjectColumnName: Scalars['String'];
  /** Project referenced by event. */
  project?: Maybe<Github_Project>;
  /** Project card referenced by this project event. */
  projectCard?: Maybe<Github_ProjectCard>;
  /** Column name the issue or pull request was moved to. */
  projectColumnName: Scalars['String'];
};

/** An object with an ID. */
export type Github_Node = {
  /** ID of the object. */
  id: Scalars['ID'];
};

/** Github_Node mock concrete type. */
export type Github_Node__Mock = Github_Node & {
  __typename?: 'Github_Node__Mock';
  /** ID of the object. */
  id: Scalars['ID'];
};

/** The possible values for the notification restriction setting. */
export enum Github_NotificationRestrictionSettingValue {
  /** The setting is disabled for the owner. */
  Disabled = 'DISABLED',
  /** The setting is enabled for the owner. */
  Enabled = 'ENABLED'
}

/** An OIDC identity provider configured to provision identities for an enterprise. */
export type Github_OidcProvider = Github_Node & {
  __typename?: 'Github_OIDCProvider';
  /** The enterprise this identity provider belongs to. */
  enterprise?: Maybe<Github_Enterprise>;
  /** ExternalIdentities provisioned by this identity provider. */
  externalIdentities: Github_ExternalIdentityConnection;
  id: Scalars['ID'];
  /** The OIDC identity provider type */
  providerType: Github_OidcProviderType;
  /** The id of the tenant this provider is attached to */
  tenantId: Scalars['String'];
};


/** An OIDC identity provider configured to provision identities for an enterprise. */
export type Github_OidcProviderExternalIdentitiesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  membersOnly?: InputMaybe<Scalars['Boolean']>;
};

/** The OIDC identity provider type */
export enum Github_OidcProviderType {
  /** Azure Active Directory */
  Aad = 'AAD'
}

/** Metadata for an audit entry with action oauth_application.* */
export type Github_OauthApplicationAuditEntryData = {
  /** The name of the OAuth Application. */
  oauthApplicationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the OAuth Application */
  oauthApplicationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the OAuth Application */
  oauthApplicationUrl?: Maybe<Scalars['Github_URI']>;
};

/** Github_OauthApplicationAuditEntryData mock concrete type. */
export type Github_OauthApplicationAuditEntryData__Mock = Github_OauthApplicationAuditEntryData & {
  __typename?: 'Github_OauthApplicationAuditEntryData__Mock';
  /** The name of the OAuth Application. */
  oauthApplicationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the OAuth Application */
  oauthApplicationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the OAuth Application */
  oauthApplicationUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a oauth_application.create event. */
export type Github_OauthApplicationCreateAuditEntry = Github_AuditEntry & Github_Node & Github_OauthApplicationAuditEntryData & Github_OrganizationAuditEntryData & {
  __typename?: 'Github_OauthApplicationCreateAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The application URL of the OAuth Application. */
  applicationUrl?: Maybe<Scalars['Github_URI']>;
  /** The callback URL of the OAuth Application. */
  callbackUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The name of the OAuth Application. */
  oauthApplicationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the OAuth Application */
  oauthApplicationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the OAuth Application */
  oauthApplicationUrl?: Maybe<Scalars['Github_URI']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The rate limit of the OAuth Application. */
  rateLimit?: Maybe<Scalars['Int']>;
  /** The state of the OAuth Application. */
  state?: Maybe<Github_OauthApplicationCreateAuditEntryState>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** The state of an OAuth Application when it was created. */
export enum Github_OauthApplicationCreateAuditEntryState {
  /** The OAuth Application was active and allowed to have OAuth Accesses. */
  Active = 'ACTIVE',
  /** The OAuth Application was in the process of being deleted. */
  PendingDeletion = 'PENDING_DELETION',
  /** The OAuth Application was suspended from generating OAuth Accesses due to abuse or security concerns. */
  Suspended = 'SUSPENDED'
}

/** The corresponding operation type for the action */
export enum Github_OperationType {
  /** An existing resource was accessed */
  Access = 'ACCESS',
  /** A resource performed an authentication event */
  Authentication = 'AUTHENTICATION',
  /** A new resource was created */
  Create = 'CREATE',
  /** An existing resource was modified */
  Modify = 'MODIFY',
  /** An existing resource was removed */
  Remove = 'REMOVE',
  /** An existing resource was restored */
  Restore = 'RESTORE',
  /** An existing resource was transferred between multiple resources */
  Transfer = 'TRANSFER'
}

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum Github_OrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = 'ASC',
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = 'DESC'
}

/** Audit log entry for a org.add_billing_manager */
export type Github_OrgAddBillingManagerAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  __typename?: 'Github_OrgAddBillingManagerAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The email address used to invite a billing manager for the organization. */
  invitationEmail?: Maybe<Scalars['String']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a org.add_member */
export type Github_OrgAddMemberAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  __typename?: 'Github_OrgAddMemberAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The permission level of the member added to the organization. */
  permission?: Maybe<Github_OrgAddMemberAuditEntryPermission>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** The permissions available to members on an Organization. */
export enum Github_OrgAddMemberAuditEntryPermission {
  /** Can read, clone, push, and add collaborators to repositories. */
  Admin = 'ADMIN',
  /** Can read and clone repositories. */
  Read = 'READ'
}

/** Audit log entry for a org.block_user */
export type Github_OrgBlockUserAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  __typename?: 'Github_OrgBlockUserAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The blocked user. */
  blockedUser?: Maybe<Github_User>;
  /** The username of the blocked user. */
  blockedUserName?: Maybe<Scalars['String']>;
  /** The HTTP path for the blocked user. */
  blockedUserResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the blocked user. */
  blockedUserUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a org.config.disable_collaborators_only event. */
export type Github_OrgConfigDisableCollaboratorsOnlyAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  __typename?: 'Github_OrgConfigDisableCollaboratorsOnlyAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a org.config.enable_collaborators_only event. */
export type Github_OrgConfigEnableCollaboratorsOnlyAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  __typename?: 'Github_OrgConfigEnableCollaboratorsOnlyAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a org.create event. */
export type Github_OrgCreateAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  __typename?: 'Github_OrgCreateAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The billing plan for the Organization. */
  billingPlan?: Maybe<Github_OrgCreateAuditEntryBillingPlan>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** The billing plans available for organizations. */
export enum Github_OrgCreateAuditEntryBillingPlan {
  /** Team Plan */
  Business = 'BUSINESS',
  /** Enterprise Cloud Plan */
  BusinessPlus = 'BUSINESS_PLUS',
  /** Free Plan */
  Free = 'FREE',
  /** Tiered Per Seat Plan */
  TieredPerSeat = 'TIERED_PER_SEAT',
  /** Legacy Unlimited Plan */
  Unlimited = 'UNLIMITED'
}

/** Audit log entry for a org.disable_oauth_app_restrictions event. */
export type Github_OrgDisableOauthAppRestrictionsAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  __typename?: 'Github_OrgDisableOauthAppRestrictionsAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a org.disable_saml event. */
export type Github_OrgDisableSamlAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  __typename?: 'Github_OrgDisableSamlAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  /** The SAML provider's digest algorithm URL. */
  digestMethodUrl?: Maybe<Scalars['Github_URI']>;
  id: Scalars['ID'];
  /** The SAML provider's issuer URL. */
  issuerUrl?: Maybe<Scalars['Github_URI']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The SAML provider's signature algorithm URL. */
  signatureMethodUrl?: Maybe<Scalars['Github_URI']>;
  /** The SAML provider's single sign-on URL. */
  singleSignOnUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a org.disable_two_factor_requirement event. */
export type Github_OrgDisableTwoFactorRequirementAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  __typename?: 'Github_OrgDisableTwoFactorRequirementAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a org.enable_oauth_app_restrictions event. */
export type Github_OrgEnableOauthAppRestrictionsAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  __typename?: 'Github_OrgEnableOauthAppRestrictionsAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a org.enable_saml event. */
export type Github_OrgEnableSamlAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  __typename?: 'Github_OrgEnableSamlAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  /** The SAML provider's digest algorithm URL. */
  digestMethodUrl?: Maybe<Scalars['Github_URI']>;
  id: Scalars['ID'];
  /** The SAML provider's issuer URL. */
  issuerUrl?: Maybe<Scalars['Github_URI']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The SAML provider's signature algorithm URL. */
  signatureMethodUrl?: Maybe<Scalars['Github_URI']>;
  /** The SAML provider's single sign-on URL. */
  singleSignOnUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a org.enable_two_factor_requirement event. */
export type Github_OrgEnableTwoFactorRequirementAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  __typename?: 'Github_OrgEnableTwoFactorRequirementAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a org.invite_member event. */
export type Github_OrgInviteMemberAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  __typename?: 'Github_OrgInviteMemberAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  /** The email address of the organization invitation. */
  email?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The organization invitation. */
  organizationInvitation?: Maybe<Github_OrganizationInvitation>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a org.invite_to_business event. */
export type Github_OrgInviteToBusinessAuditEntry = Github_AuditEntry & Github_EnterpriseAuditEntryData & Github_Node & Github_OrganizationAuditEntryData & {
  __typename?: 'Github_OrgInviteToBusinessAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['Github_URI']>;
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a org.oauth_app_access_approved event. */
export type Github_OrgOauthAppAccessApprovedAuditEntry = Github_AuditEntry & Github_Node & Github_OauthApplicationAuditEntryData & Github_OrganizationAuditEntryData & {
  __typename?: 'Github_OrgOauthAppAccessApprovedAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The name of the OAuth Application. */
  oauthApplicationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the OAuth Application */
  oauthApplicationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the OAuth Application */
  oauthApplicationUrl?: Maybe<Scalars['Github_URI']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a org.oauth_app_access_denied event. */
export type Github_OrgOauthAppAccessDeniedAuditEntry = Github_AuditEntry & Github_Node & Github_OauthApplicationAuditEntryData & Github_OrganizationAuditEntryData & {
  __typename?: 'Github_OrgOauthAppAccessDeniedAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The name of the OAuth Application. */
  oauthApplicationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the OAuth Application */
  oauthApplicationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the OAuth Application */
  oauthApplicationUrl?: Maybe<Scalars['Github_URI']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a org.oauth_app_access_requested event. */
export type Github_OrgOauthAppAccessRequestedAuditEntry = Github_AuditEntry & Github_Node & Github_OauthApplicationAuditEntryData & Github_OrganizationAuditEntryData & {
  __typename?: 'Github_OrgOauthAppAccessRequestedAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The name of the OAuth Application. */
  oauthApplicationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the OAuth Application */
  oauthApplicationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the OAuth Application */
  oauthApplicationUrl?: Maybe<Scalars['Github_URI']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a org.remove_billing_manager event. */
export type Github_OrgRemoveBillingManagerAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  __typename?: 'Github_OrgRemoveBillingManagerAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The reason for the billing manager being removed. */
  reason?: Maybe<Github_OrgRemoveBillingManagerAuditEntryReason>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** The reason a billing manager was removed from an Organization. */
export enum Github_OrgRemoveBillingManagerAuditEntryReason {
  /** SAML external identity missing */
  SamlExternalIdentityMissing = 'SAML_EXTERNAL_IDENTITY_MISSING',
  /** SAML SSO enforcement requires an external identity */
  SamlSsoEnforcementRequiresExternalIdentity = 'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY',
  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */
  TwoFactorRequirementNonCompliance = 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE'
}

/** Audit log entry for a org.remove_member event. */
export type Github_OrgRemoveMemberAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  __typename?: 'Github_OrgRemoveMemberAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The types of membership the member has with the organization. */
  membershipTypes?: Maybe<Array<Github_OrgRemoveMemberAuditEntryMembershipType>>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The reason for the member being removed. */
  reason?: Maybe<Github_OrgRemoveMemberAuditEntryReason>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** The type of membership a user has with an Organization. */
export enum Github_OrgRemoveMemberAuditEntryMembershipType {
  /**
   * Organization administrators have full access and can change several settings,
   * including the names of repositories that belong to the Organization and Owners
   * team membership. In addition, organization admins can delete the organization
   * and all of its repositories.
   */
  Admin = 'ADMIN',
  /** A billing manager is a user who manages the billing settings for the Organization, such as updating payment information. */
  BillingManager = 'BILLING_MANAGER',
  /** A direct member is a user that is a member of the Organization. */
  DirectMember = 'DIRECT_MEMBER',
  /**
   * An outside collaborator is a person who isn't explicitly a member of the
   * Organization, but who has Read, Write, or Admin permissions to one or more
   * repositories in the organization.
   */
  OutsideCollaborator = 'OUTSIDE_COLLABORATOR',
  /**
   * An unaffiliated collaborator is a person who is not a member of the
   * Organization and does not have access to any repositories in the Organization.
   */
  Unaffiliated = 'UNAFFILIATED'
}

/** The reason a member was removed from an Organization. */
export enum Github_OrgRemoveMemberAuditEntryReason {
  /** SAML external identity missing */
  SamlExternalIdentityMissing = 'SAML_EXTERNAL_IDENTITY_MISSING',
  /** SAML SSO enforcement requires an external identity */
  SamlSsoEnforcementRequiresExternalIdentity = 'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY',
  /** User was removed from organization during account recovery */
  TwoFactorAccountRecovery = 'TWO_FACTOR_ACCOUNT_RECOVERY',
  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */
  TwoFactorRequirementNonCompliance = 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE',
  /** User account has been deleted */
  UserAccountDeleted = 'USER_ACCOUNT_DELETED'
}

/** Audit log entry for a org.remove_outside_collaborator event. */
export type Github_OrgRemoveOutsideCollaboratorAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  __typename?: 'Github_OrgRemoveOutsideCollaboratorAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The types of membership the outside collaborator has with the organization. */
  membershipTypes?: Maybe<Array<Github_OrgRemoveOutsideCollaboratorAuditEntryMembershipType>>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The reason for the outside collaborator being removed from the Organization. */
  reason?: Maybe<Github_OrgRemoveOutsideCollaboratorAuditEntryReason>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** The type of membership a user has with an Organization. */
export enum Github_OrgRemoveOutsideCollaboratorAuditEntryMembershipType {
  /** A billing manager is a user who manages the billing settings for the Organization, such as updating payment information. */
  BillingManager = 'BILLING_MANAGER',
  /**
   * An outside collaborator is a person who isn't explicitly a member of the
   * Organization, but who has Read, Write, or Admin permissions to one or more
   * repositories in the organization.
   */
  OutsideCollaborator = 'OUTSIDE_COLLABORATOR',
  /**
   * An unaffiliated collaborator is a person who is not a member of the
   * Organization and does not have access to any repositories in the organization.
   */
  Unaffiliated = 'UNAFFILIATED'
}

/** The reason an outside collaborator was removed from an Organization. */
export enum Github_OrgRemoveOutsideCollaboratorAuditEntryReason {
  /** SAML external identity missing */
  SamlExternalIdentityMissing = 'SAML_EXTERNAL_IDENTITY_MISSING',
  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */
  TwoFactorRequirementNonCompliance = 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE'
}

/** Audit log entry for a org.restore_member event. */
export type Github_OrgRestoreMemberAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  __typename?: 'Github_OrgRestoreMemberAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The number of custom email routings for the restored member. */
  restoredCustomEmailRoutingsCount?: Maybe<Scalars['Int']>;
  /** The number of issue assignments for the restored member. */
  restoredIssueAssignmentsCount?: Maybe<Scalars['Int']>;
  /** Restored organization membership objects. */
  restoredMemberships?: Maybe<Array<Github_OrgRestoreMemberAuditEntryMembership>>;
  /** The number of restored memberships. */
  restoredMembershipsCount?: Maybe<Scalars['Int']>;
  /** The number of repositories of the restored member. */
  restoredRepositoriesCount?: Maybe<Scalars['Int']>;
  /** The number of starred repositories for the restored member. */
  restoredRepositoryStarsCount?: Maybe<Scalars['Int']>;
  /** The number of watched repositories for the restored member. */
  restoredRepositoryWatchesCount?: Maybe<Scalars['Int']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Types of memberships that can be restored for an Organization member. */
export type Github_OrgRestoreMemberAuditEntryMembership = Github_OrgRestoreMemberMembershipOrganizationAuditEntryData | Github_OrgRestoreMemberMembershipRepositoryAuditEntryData | Github_OrgRestoreMemberMembershipTeamAuditEntryData;

/** Metadata for an organization membership for org.restore_member actions */
export type Github_OrgRestoreMemberMembershipOrganizationAuditEntryData = Github_OrganizationAuditEntryData & {
  __typename?: 'Github_OrgRestoreMemberMembershipOrganizationAuditEntryData';
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
};

/** Metadata for a repository membership for org.restore_member actions */
export type Github_OrgRestoreMemberMembershipRepositoryAuditEntryData = Github_RepositoryAuditEntryData & {
  __typename?: 'Github_OrgRestoreMemberMembershipRepositoryAuditEntryData';
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
};

/** Metadata for a team membership for org.restore_member actions */
export type Github_OrgRestoreMemberMembershipTeamAuditEntryData = Github_TeamAuditEntryData & {
  __typename?: 'Github_OrgRestoreMemberMembershipTeamAuditEntryData';
  /** The team associated with the action */
  team?: Maybe<Github_Team>;
  /** The name of the team */
  teamName?: Maybe<Scalars['String']>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a org.unblock_user */
export type Github_OrgUnblockUserAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  __typename?: 'Github_OrgUnblockUserAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The user being unblocked by the organization. */
  blockedUser?: Maybe<Github_User>;
  /** The username of the blocked user. */
  blockedUserName?: Maybe<Scalars['String']>;
  /** The HTTP path for the blocked user. */
  blockedUserResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the blocked user. */
  blockedUserUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a org.update_default_repository_permission */
export type Github_OrgUpdateDefaultRepositoryPermissionAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  __typename?: 'Github_OrgUpdateDefaultRepositoryPermissionAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The new base repository permission level for the organization. */
  permission?: Maybe<Github_OrgUpdateDefaultRepositoryPermissionAuditEntryPermission>;
  /** The former base repository permission level for the organization. */
  permissionWas?: Maybe<Github_OrgUpdateDefaultRepositoryPermissionAuditEntryPermission>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** The default permission a repository can have in an Organization. */
export enum Github_OrgUpdateDefaultRepositoryPermissionAuditEntryPermission {
  /** Can read, clone, push, and add collaborators to repositories. */
  Admin = 'ADMIN',
  /** No default permission value. */
  None = 'NONE',
  /** Can read and clone repositories. */
  Read = 'READ',
  /** Can read, clone and push to repositories. */
  Write = 'WRITE'
}

/** Audit log entry for a org.update_member event. */
export type Github_OrgUpdateMemberAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  __typename?: 'Github_OrgUpdateMemberAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The new member permission level for the organization. */
  permission?: Maybe<Github_OrgUpdateMemberAuditEntryPermission>;
  /** The former member permission level for the organization. */
  permissionWas?: Maybe<Github_OrgUpdateMemberAuditEntryPermission>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** The permissions available to members on an Organization. */
export enum Github_OrgUpdateMemberAuditEntryPermission {
  /** Can read, clone, push, and add collaborators to repositories. */
  Admin = 'ADMIN',
  /** Can read and clone repositories. */
  Read = 'READ'
}

/** Audit log entry for a org.update_member_repository_creation_permission event. */
export type Github_OrgUpdateMemberRepositoryCreationPermissionAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  __typename?: 'Github_OrgUpdateMemberRepositoryCreationPermissionAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** Can members create repositories in the organization. */
  canCreateRepositories?: Maybe<Scalars['Boolean']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
  /** The permission for visibility level of repositories for this organization. */
  visibility?: Maybe<Github_OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility>;
};

/** The permissions available for repository creation on an Organization. */
export enum Github_OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility {
  /** All organization members are restricted from creating any repositories. */
  All = 'ALL',
  /** All organization members are restricted from creating internal repositories. */
  Internal = 'INTERNAL',
  /** All organization members are allowed to create any repositories. */
  None = 'NONE',
  /** All organization members are restricted from creating private repositories. */
  Private = 'PRIVATE',
  /** All organization members are restricted from creating private or internal repositories. */
  PrivateInternal = 'PRIVATE_INTERNAL',
  /** All organization members are restricted from creating public repositories. */
  Public = 'PUBLIC',
  /** All organization members are restricted from creating public or internal repositories. */
  PublicInternal = 'PUBLIC_INTERNAL',
  /** All organization members are restricted from creating public or private repositories. */
  PublicPrivate = 'PUBLIC_PRIVATE'
}

/** Audit log entry for a org.update_member_repository_invitation_permission event. */
export type Github_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & {
  __typename?: 'Github_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** Can outside collaborators be invited to repositories in the organization. */
  canInviteOutsideCollaboratorsToRepositories?: Maybe<Scalars['Boolean']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_Organization = Github_Actor & Github_MemberStatusable & Github_Node & Github_PackageOwner & Github_ProfileOwner & Github_ProjectNextOwner & Github_ProjectOwner & Github_RepositoryDiscussionAuthor & Github_RepositoryDiscussionCommentAuthor & Github_RepositoryOwner & Github_Sponsorable & Github_UniformResourceLocatable & {
  __typename?: 'Github_Organization';
  /** Determine if this repository owner has any items that can be pinned to their profile. */
  anyPinnableItems: Scalars['Boolean'];
  /** Audit log entries of the organization */
  auditLog: Github_OrganizationAuditEntryConnection;
  /** A URL pointing to the organization's public avatar. */
  avatarUrl: Scalars['Github_URI'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The organization's public profile description. */
  description?: Maybe<Scalars['String']>;
  /** The organization's public profile description rendered to HTML. */
  descriptionHTML?: Maybe<Scalars['String']>;
  /** A list of domains owned by the organization. */
  domains?: Maybe<Github_VerifiableDomainConnection>;
  /** The organization's public email. */
  email?: Maybe<Scalars['String']>;
  /** The estimated next GitHub Sponsors payout for this user/organization in cents (USD). */
  estimatedNextSponsorsPayoutInCents: Scalars['Int'];
  /** True if this user/organization has a GitHub Sponsors listing. */
  hasSponsorsListing: Scalars['Boolean'];
  id: Scalars['ID'];
  /** The interaction ability settings for this organization. */
  interactionAbility?: Maybe<Github_RepositoryInteractionAbility>;
  /** The setting value for whether the organization has an IP allow list enabled. */
  ipAllowListEnabledSetting: Github_IpAllowListEnabledSettingValue;
  /** The IP addresses that are allowed to access resources owned by the organization. */
  ipAllowListEntries: Github_IpAllowListEntryConnection;
  /** The setting value for whether the organization has IP allow list configuration for installed GitHub Apps enabled. */
  ipAllowListForInstalledAppsEnabledSetting: Github_IpAllowListForInstalledAppsEnabledSettingValue;
  /** Check if the given account is sponsoring this user/organization. */
  isSponsoredBy: Scalars['Boolean'];
  /** True if the viewer is sponsored by this user/organization. */
  isSponsoringViewer: Scalars['Boolean'];
  /** Whether the organization has verified its profile email and website. */
  isVerified: Scalars['Boolean'];
  /**
   * Showcases a selection of repositories and gists that the profile owner has
   * either curated or that have been selected automatically based on popularity.
   */
  itemShowcase: Github_ProfileItemShowcase;
  /** The organization's public profile location. */
  location?: Maybe<Scalars['String']>;
  /** The organization's login name. */
  login: Scalars['String'];
  /** Get the status messages members of this entity have set that are either public or visible only to the organization. */
  memberStatuses: Github_UserStatusConnection;
  /** Members can fork private repositories in this organization */
  membersCanForkPrivateRepositories: Scalars['Boolean'];
  /** A list of users who are members of this organization. */
  membersWithRole: Github_OrganizationMemberConnection;
  /** The estimated monthly GitHub Sponsors income for this user/organization in cents (USD). */
  monthlyEstimatedSponsorsIncomeInCents: Scalars['Int'];
  /** The organization's public profile name. */
  name?: Maybe<Scalars['String']>;
  /** The HTTP path creating a new team */
  newTeamResourcePath: Scalars['Github_URI'];
  /** The HTTP URL creating a new team */
  newTeamUrl: Scalars['Github_URI'];
  /** Indicates if email notification delivery for this organization is restricted to verified or approved domains. */
  notificationDeliveryRestrictionEnabledSetting: Github_NotificationRestrictionSettingValue;
  /** The billing email for the organization. */
  organizationBillingEmail?: Maybe<Scalars['String']>;
  /** A list of packages under the owner. */
  packages: Github_PackageConnection;
  /** A list of users who have been invited to join this organization. */
  pendingMembers: Github_UserConnection;
  /** A list of repositories and gists this profile owner can pin to their profile. */
  pinnableItems: Github_PinnableItemConnection;
  /** A list of repositories and gists this profile owner has pinned to their profile */
  pinnedItems: Github_PinnableItemConnection;
  /** Returns how many more items this profile owner can pin to their profile. */
  pinnedItemsRemaining: Scalars['Int'];
  /** Find project by number. */
  project?: Maybe<Github_Project>;
  /** Find a project by project (beta) number. */
  projectNext?: Maybe<Github_ProjectNext>;
  /** A list of projects under the owner. */
  projects: Github_ProjectConnection;
  /** A list of project (beta) items under the owner. */
  projectsNext: Github_ProjectNextConnection;
  /** The HTTP path listing organization's projects */
  projectsResourcePath: Scalars['Github_URI'];
  /** The HTTP URL listing organization's projects */
  projectsUrl: Scalars['Github_URI'];
  /** A list of repositories that the user owns. */
  repositories: Github_RepositoryConnection;
  /** Find Repository. */
  repository?: Maybe<Github_Repository>;
  /** Discussion comments this user has authored. */
  repositoryDiscussionComments: Github_DiscussionCommentConnection;
  /** Discussions this user has started. */
  repositoryDiscussions: Github_DiscussionConnection;
  /**
   * When true the organization requires all members, billing managers, and outside
   * collaborators to enable two-factor authentication.
   */
  requiresTwoFactorAuthentication?: Maybe<Scalars['Boolean']>;
  /** The HTTP path for this organization. */
  resourcePath: Scalars['Github_URI'];
  /** The Organization's SAML identity providers */
  samlIdentityProvider?: Maybe<Github_OrganizationIdentityProvider>;
  /** List of users and organizations this entity is sponsoring. */
  sponsoring: Github_SponsorConnection;
  /** List of sponsors for this user or organization. */
  sponsors: Github_SponsorConnection;
  /** Events involving this sponsorable, such as new sponsorships. */
  sponsorsActivities: Github_SponsorsActivityConnection;
  /** The GitHub Sponsors listing for this user or organization. */
  sponsorsListing?: Maybe<Github_SponsorsListing>;
  /**
   * The sponsorship from the viewer to this user/organization; that is, the
   * sponsorship where you're the sponsor. Only returns a sponsorship if it is active.
   */
  sponsorshipForViewerAsSponsor?: Maybe<Github_Sponsorship>;
  /**
   * The sponsorship from this user/organization to the viewer; that is, the
   * sponsorship you're receiving. Only returns a sponsorship if it is active.
   */
  sponsorshipForViewerAsSponsorable?: Maybe<Github_Sponsorship>;
  /** List of sponsorship updates sent from this sponsorable to sponsors. */
  sponsorshipNewsletters: Github_SponsorshipNewsletterConnection;
  /** This object's sponsorships as the maintainer. */
  sponsorshipsAsMaintainer: Github_SponsorshipConnection;
  /** This object's sponsorships as the sponsor. */
  sponsorshipsAsSponsor: Github_SponsorshipConnection;
  /** Find an organization's team by its slug. */
  team?: Maybe<Github_Team>;
  /** A list of teams in this organization. */
  teams: Github_TeamConnection;
  /** The HTTP path listing organization's teams */
  teamsResourcePath: Scalars['Github_URI'];
  /** The HTTP URL listing organization's teams */
  teamsUrl: Scalars['Github_URI'];
  /** The organization's Twitter username. */
  twitterUsername?: Maybe<Scalars['String']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this organization. */
  url: Scalars['Github_URI'];
  /** Organization is adminable by the viewer. */
  viewerCanAdminister: Scalars['Boolean'];
  /** Can the viewer pin repositories and gists to the profile? */
  viewerCanChangePinnedItems: Scalars['Boolean'];
  /** Can the current viewer create new projects on this owner. */
  viewerCanCreateProjects: Scalars['Boolean'];
  /** Viewer can create repositories on this organization */
  viewerCanCreateRepositories: Scalars['Boolean'];
  /** Viewer can create teams on this organization. */
  viewerCanCreateTeams: Scalars['Boolean'];
  /** Whether or not the viewer is able to sponsor this user/organization. */
  viewerCanSponsor: Scalars['Boolean'];
  /** Viewer is an active member of this organization. */
  viewerIsAMember: Scalars['Boolean'];
  /** True if the viewer is sponsoring this user/organization. */
  viewerIsSponsoring: Scalars['Boolean'];
  /** The organization's public profile URL. */
  websiteUrl?: Maybe<Scalars['Github_URI']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationAnyPinnableItemsArgs = {
  type?: InputMaybe<Github_PinnableItemType>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationAuditLogArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_AuditLogOrder>;
  query?: InputMaybe<Scalars['String']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationAvatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationDomainsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  isApproved?: InputMaybe<Scalars['Boolean']>;
  isVerified?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_VerifiableDomainOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationIpAllowListEntriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_IpAllowListEntryOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationIsSponsoredByArgs = {
  accountLogin: Scalars['String'];
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationMemberStatusesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_UserStatusOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationMembersWithRoleArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationPackagesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  names?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  orderBy?: InputMaybe<Github_PackageOrder>;
  packageType?: InputMaybe<Github_PackageType>;
  repositoryId?: InputMaybe<Scalars['ID']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationPendingMembersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationPinnableItemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  types?: InputMaybe<Array<Github_PinnableItemType>>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationPinnedItemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  types?: InputMaybe<Array<Github_PinnableItemType>>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationProjectArgs = {
  number: Scalars['Int'];
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationProjectNextArgs = {
  number: Scalars['Int'];
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationProjectsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ProjectOrder>;
  search?: InputMaybe<Scalars['String']>;
  states?: InputMaybe<Array<Github_ProjectState>>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationProjectsNextArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  query?: InputMaybe<Scalars['String']>;
  sortBy?: InputMaybe<Github_ProjectNextOrderField>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationRepositoriesArgs = {
  affiliations?: InputMaybe<Array<InputMaybe<Github_RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  isFork?: InputMaybe<Scalars['Boolean']>;
  isLocked?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_RepositoryOrder>;
  ownerAffiliations?: InputMaybe<Array<InputMaybe<Github_RepositoryAffiliation>>>;
  privacy?: InputMaybe<Github_RepositoryPrivacy>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationRepositoryArgs = {
  followRenames?: InputMaybe<Scalars['Boolean']>;
  name: Scalars['String'];
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationRepositoryDiscussionCommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  onlyAnswers?: InputMaybe<Scalars['Boolean']>;
  repositoryId?: InputMaybe<Scalars['ID']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationRepositoryDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  answered?: InputMaybe<Scalars['Boolean']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_DiscussionOrder>;
  repositoryId?: InputMaybe<Scalars['ID']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationSponsoringArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationSponsorsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorOrder>;
  tierId?: InputMaybe<Scalars['ID']>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationSponsorsActivitiesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorsActivityOrder>;
  period?: InputMaybe<Github_SponsorsActivityPeriod>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationSponsorshipNewslettersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorshipNewsletterOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationSponsorshipsAsMaintainerArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  includePrivate?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorshipOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationSponsorshipsAsSponsorArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorshipOrder>;
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationTeamArgs = {
  slug: Scalars['String'];
};


/** An account on GitHub, with one or more owners, that has repositories, members and teams. */
export type Github_OrganizationTeamsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  ldapMapped?: InputMaybe<Scalars['Boolean']>;
  orderBy?: InputMaybe<Github_TeamOrder>;
  privacy?: InputMaybe<Github_TeamPrivacy>;
  query?: InputMaybe<Scalars['String']>;
  role?: InputMaybe<Github_TeamRole>;
  rootTeamsOnly?: InputMaybe<Scalars['Boolean']>;
  userLogins?: InputMaybe<Array<Scalars['String']>>;
};

/** An audit entry in an organization audit log. */
export type Github_OrganizationAuditEntry = Github_MembersCanDeleteReposClearAuditEntry | Github_MembersCanDeleteReposDisableAuditEntry | Github_MembersCanDeleteReposEnableAuditEntry | Github_OauthApplicationCreateAuditEntry | Github_OrgAddBillingManagerAuditEntry | Github_OrgAddMemberAuditEntry | Github_OrgBlockUserAuditEntry | Github_OrgConfigDisableCollaboratorsOnlyAuditEntry | Github_OrgConfigEnableCollaboratorsOnlyAuditEntry | Github_OrgCreateAuditEntry | Github_OrgDisableOauthAppRestrictionsAuditEntry | Github_OrgDisableSamlAuditEntry | Github_OrgDisableTwoFactorRequirementAuditEntry | Github_OrgEnableOauthAppRestrictionsAuditEntry | Github_OrgEnableSamlAuditEntry | Github_OrgEnableTwoFactorRequirementAuditEntry | Github_OrgInviteMemberAuditEntry | Github_OrgInviteToBusinessAuditEntry | Github_OrgOauthAppAccessApprovedAuditEntry | Github_OrgOauthAppAccessDeniedAuditEntry | Github_OrgOauthAppAccessRequestedAuditEntry | Github_OrgRemoveBillingManagerAuditEntry | Github_OrgRemoveMemberAuditEntry | Github_OrgRemoveOutsideCollaboratorAuditEntry | Github_OrgRestoreMemberAuditEntry | Github_OrgUnblockUserAuditEntry | Github_OrgUpdateDefaultRepositoryPermissionAuditEntry | Github_OrgUpdateMemberAuditEntry | Github_OrgUpdateMemberRepositoryCreationPermissionAuditEntry | Github_OrgUpdateMemberRepositoryInvitationPermissionAuditEntry | Github_PrivateRepositoryForkingDisableAuditEntry | Github_PrivateRepositoryForkingEnableAuditEntry | Github_RepoAccessAuditEntry | Github_RepoAddMemberAuditEntry | Github_RepoAddTopicAuditEntry | Github_RepoArchivedAuditEntry | Github_RepoChangeMergeSettingAuditEntry | Github_RepoConfigDisableAnonymousGitAccessAuditEntry | Github_RepoConfigDisableCollaboratorsOnlyAuditEntry | Github_RepoConfigDisableContributorsOnlyAuditEntry | Github_RepoConfigDisableSockpuppetDisallowedAuditEntry | Github_RepoConfigEnableAnonymousGitAccessAuditEntry | Github_RepoConfigEnableCollaboratorsOnlyAuditEntry | Github_RepoConfigEnableContributorsOnlyAuditEntry | Github_RepoConfigEnableSockpuppetDisallowedAuditEntry | Github_RepoConfigLockAnonymousGitAccessAuditEntry | Github_RepoConfigUnlockAnonymousGitAccessAuditEntry | Github_RepoCreateAuditEntry | Github_RepoDestroyAuditEntry | Github_RepoRemoveMemberAuditEntry | Github_RepoRemoveTopicAuditEntry | Github_RepositoryVisibilityChangeDisableAuditEntry | Github_RepositoryVisibilityChangeEnableAuditEntry | Github_TeamAddMemberAuditEntry | Github_TeamAddRepositoryAuditEntry | Github_TeamChangeParentTeamAuditEntry | Github_TeamRemoveMemberAuditEntry | Github_TeamRemoveRepositoryAuditEntry;

/** The connection type for OrganizationAuditEntry. */
export type Github_OrganizationAuditEntryConnection = {
  __typename?: 'Github_OrganizationAuditEntryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_OrganizationAuditEntryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_OrganizationAuditEntry>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Metadata for an audit entry with action org.* */
export type Github_OrganizationAuditEntryData = {
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
};

/** Github_OrganizationAuditEntryData mock concrete type. */
export type Github_OrganizationAuditEntryData__Mock = Github_OrganizationAuditEntryData & {
  __typename?: 'Github_OrganizationAuditEntryData__Mock';
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
};

/** An edge in a connection. */
export type Github_OrganizationAuditEntryEdge = {
  __typename?: 'Github_OrganizationAuditEntryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_OrganizationAuditEntry>;
};

/** A list of organizations managed by an enterprise. */
export type Github_OrganizationConnection = {
  __typename?: 'Github_OrganizationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_OrganizationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Organization>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_OrganizationEdge = {
  __typename?: 'Github_OrganizationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Organization>;
};

/** An Identity Provider configured to provision SAML and SCIM identities for Organizations */
export type Github_OrganizationIdentityProvider = Github_Node & {
  __typename?: 'Github_OrganizationIdentityProvider';
  /** The digest algorithm used to sign SAML requests for the Identity Provider. */
  digestMethod?: Maybe<Scalars['Github_URI']>;
  /** External Identities provisioned by this Identity Provider */
  externalIdentities: Github_ExternalIdentityConnection;
  id: Scalars['ID'];
  /** The x509 certificate used by the Identity Provider to sign assertions and responses. */
  idpCertificate?: Maybe<Scalars['Github_X509Certificate']>;
  /** The Issuer Entity ID for the SAML Identity Provider */
  issuer?: Maybe<Scalars['String']>;
  /** Organization this Identity Provider belongs to */
  organization?: Maybe<Github_Organization>;
  /** The signature algorithm used to sign SAML requests for the Identity Provider. */
  signatureMethod?: Maybe<Scalars['Github_URI']>;
  /** The URL endpoint for the Identity Provider's SAML SSO. */
  ssoUrl?: Maybe<Scalars['Github_URI']>;
};


/** An Identity Provider configured to provision SAML and SCIM identities for Organizations */
export type Github_OrganizationIdentityProviderExternalIdentitiesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  membersOnly?: InputMaybe<Scalars['Boolean']>;
};

/** An Invitation for a user to an organization. */
export type Github_OrganizationInvitation = Github_Node & {
  __typename?: 'Github_OrganizationInvitation';
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The email address of the user invited to the organization. */
  email?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The type of invitation that was sent (e.g. email, user). */
  invitationType: Github_OrganizationInvitationType;
  /** The user who was invited to the organization. */
  invitee?: Maybe<Github_User>;
  /** The user who created the invitation. */
  inviter: Github_User;
  /** The organization the invite is for */
  organization: Github_Organization;
  /** The user's pending role in the organization (e.g. member, owner). */
  role: Github_OrganizationInvitationRole;
};

/** The connection type for OrganizationInvitation. */
export type Github_OrganizationInvitationConnection = {
  __typename?: 'Github_OrganizationInvitationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_OrganizationInvitationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_OrganizationInvitation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_OrganizationInvitationEdge = {
  __typename?: 'Github_OrganizationInvitationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_OrganizationInvitation>;
};

/** The possible organization invitation roles. */
export enum Github_OrganizationInvitationRole {
  /** The user is invited to be an admin of the organization. */
  Admin = 'ADMIN',
  /** The user is invited to be a billing manager of the organization. */
  BillingManager = 'BILLING_MANAGER',
  /** The user is invited to be a direct member of the organization. */
  DirectMember = 'DIRECT_MEMBER',
  /** The user's previous role will be reinstated. */
  Reinstate = 'REINSTATE'
}

/** The possible organization invitation types. */
export enum Github_OrganizationInvitationType {
  /** The invitation was to an email address. */
  Email = 'EMAIL',
  /** The invitation was to an existing user. */
  User = 'USER'
}

/** The connection type for User. */
export type Github_OrganizationMemberConnection = {
  __typename?: 'Github_OrganizationMemberConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_OrganizationMemberEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Represents a user within an organization. */
export type Github_OrganizationMemberEdge = {
  __typename?: 'Github_OrganizationMemberEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** Whether the organization member has two factor enabled or not. Returns null if information is not available to viewer. */
  hasTwoFactorEnabled?: Maybe<Scalars['Boolean']>;
  /** The item at the end of the edge. */
  node?: Maybe<Github_User>;
  /** The role this user has in the organization. */
  role?: Maybe<Github_OrganizationMemberRole>;
};

/** The possible roles within an organization for its members. */
export enum Github_OrganizationMemberRole {
  /** The user is an administrator of the organization. */
  Admin = 'ADMIN',
  /** The user is a member of the organization. */
  Member = 'MEMBER'
}

/** The possible values for the members can create repositories setting on an organization. */
export enum Github_OrganizationMembersCanCreateRepositoriesSettingValue {
  /** Members will be able to create public and private repositories. */
  All = 'ALL',
  /** Members will not be able to create public or private repositories. */
  Disabled = 'DISABLED',
  /** Members will be able to create only internal repositories. */
  Internal = 'INTERNAL',
  /** Members will be able to create only private repositories. */
  Private = 'PRIVATE'
}

/** Ordering options for organization connections. */
export type Github_OrganizationOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order organizations by. */
  field: Github_OrganizationOrderField;
};

/** Properties by which organization connections can be ordered. */
export enum Github_OrganizationOrderField {
  /** Order organizations by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order organizations by login */
  Login = 'LOGIN'
}

/** An organization teams hovercard context */
export type Github_OrganizationTeamsHovercardContext = Github_HovercardContext & {
  __typename?: 'Github_OrganizationTeamsHovercardContext';
  /** A string describing this context */
  message: Scalars['String'];
  /** An octicon to accompany this context */
  octicon: Scalars['String'];
  /** Teams in this organization the user is a member of that are relevant */
  relevantTeams: Github_TeamConnection;
  /** The path for the full team list for this user */
  teamsResourcePath: Scalars['Github_URI'];
  /** The URL for the full team list for this user */
  teamsUrl: Scalars['Github_URI'];
  /** The total number of teams the user is on in the organization */
  totalTeamCount: Scalars['Int'];
};


/** An organization teams hovercard context */
export type Github_OrganizationTeamsHovercardContextRelevantTeamsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** An organization list hovercard context */
export type Github_OrganizationsHovercardContext = Github_HovercardContext & {
  __typename?: 'Github_OrganizationsHovercardContext';
  /** A string describing this context */
  message: Scalars['String'];
  /** An octicon to accompany this context */
  octicon: Scalars['String'];
  /** Organizations this user is a member of that are relevant */
  relevantOrganizations: Github_OrganizationConnection;
  /** The total number of organizations this user is in */
  totalOrganizationCount: Scalars['Int'];
};


/** An organization list hovercard context */
export type Github_OrganizationsHovercardContextRelevantOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Information for an uploaded package. */
export type Github_Package = Github_Node & {
  __typename?: 'Github_Package';
  id: Scalars['ID'];
  /** Find the latest version for the package. */
  latestVersion?: Maybe<Github_PackageVersion>;
  /** Identifies the name of the package. */
  name: Scalars['String'];
  /** Identifies the type of the package. */
  packageType: Github_PackageType;
  /** The repository this package belongs to. */
  repository?: Maybe<Github_Repository>;
  /** Statistics about package activity. */
  statistics?: Maybe<Github_PackageStatistics>;
  /** Find package version by version string. */
  version?: Maybe<Github_PackageVersion>;
  /** list of versions for this package */
  versions: Github_PackageVersionConnection;
};


/** Information for an uploaded package. */
export type Github_PackageVersionArgs = {
  version: Scalars['String'];
};


/** Information for an uploaded package. */
export type Github_PackageVersionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_PackageVersionOrder>;
};

/** The connection type for Package. */
export type Github_PackageConnection = {
  __typename?: 'Github_PackageConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_PackageEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Package>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_PackageEdge = {
  __typename?: 'Github_PackageEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Package>;
};

/** A file in a package version. */
export type Github_PackageFile = Github_Node & {
  __typename?: 'Github_PackageFile';
  id: Scalars['ID'];
  /** MD5 hash of the file. */
  md5?: Maybe<Scalars['String']>;
  /** Name of the file. */
  name: Scalars['String'];
  /** The package version this file belongs to. */
  packageVersion?: Maybe<Github_PackageVersion>;
  /** SHA1 hash of the file. */
  sha1?: Maybe<Scalars['String']>;
  /** SHA256 hash of the file. */
  sha256?: Maybe<Scalars['String']>;
  /** Size of the file in bytes. */
  size?: Maybe<Scalars['Int']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** URL to download the asset. */
  url?: Maybe<Scalars['Github_URI']>;
};

/** The connection type for PackageFile. */
export type Github_PackageFileConnection = {
  __typename?: 'Github_PackageFileConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_PackageFileEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_PackageFile>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_PackageFileEdge = {
  __typename?: 'Github_PackageFileEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_PackageFile>;
};

/** Ways in which lists of package files can be ordered upon return. */
export type Github_PackageFileOrder = {
  /** The direction in which to order package files by the specified field. */
  direction?: InputMaybe<Github_OrderDirection>;
  /** The field in which to order package files by. */
  field?: InputMaybe<Github_PackageFileOrderField>;
};

/** Properties by which package file connections can be ordered. */
export enum Github_PackageFileOrderField {
  /** Order package files by creation time */
  CreatedAt = 'CREATED_AT'
}

/** Ways in which lists of packages can be ordered upon return. */
export type Github_PackageOrder = {
  /** The direction in which to order packages by the specified field. */
  direction?: InputMaybe<Github_OrderDirection>;
  /** The field in which to order packages by. */
  field?: InputMaybe<Github_PackageOrderField>;
};

/** Properties by which package connections can be ordered. */
export enum Github_PackageOrderField {
  /** Order packages by creation time */
  CreatedAt = 'CREATED_AT'
}

/** Represents an owner of a package. */
export type Github_PackageOwner = {
  id: Scalars['ID'];
  /** A list of packages under the owner. */
  packages: Github_PackageConnection;
};


/** Represents an owner of a package. */
export type Github_PackageOwnerPackagesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  names?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  orderBy?: InputMaybe<Github_PackageOrder>;
  packageType?: InputMaybe<Github_PackageType>;
  repositoryId?: InputMaybe<Scalars['ID']>;
};

/** Github_PackageOwner mock concrete type. */
export type Github_PackageOwner__Mock = Github_PackageOwner & {
  __typename?: 'Github_PackageOwner__Mock';
  id: Scalars['ID'];
  /** A list of packages under the owner. */
  packages: Github_PackageConnection;
};


/** Github_PackageOwner mock concrete type. */
export type Github_PackageOwner__MockPackagesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  names?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  orderBy?: InputMaybe<Github_PackageOrder>;
  packageType?: InputMaybe<Github_PackageType>;
  repositoryId?: InputMaybe<Scalars['ID']>;
};

/** Represents a object that contains package activity statistics such as downloads. */
export type Github_PackageStatistics = {
  __typename?: 'Github_PackageStatistics';
  /** Number of times the package was downloaded since it was created. */
  downloadsTotalCount: Scalars['Int'];
};

/** A version tag contains the mapping between a tag name and a version. */
export type Github_PackageTag = Github_Node & {
  __typename?: 'Github_PackageTag';
  id: Scalars['ID'];
  /** Identifies the tag name of the version. */
  name: Scalars['String'];
  /** Version that the tag is associated with. */
  version?: Maybe<Github_PackageVersion>;
};

/** The possible types of a package. */
export enum Github_PackageType {
  /** A debian package. */
  Debian = 'DEBIAN',
  /**
   * A docker image.
   * @deprecated DOCKER will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2021-06-21 UTC.
   */
  Docker = 'DOCKER',
  /** A maven package. */
  Maven = 'MAVEN',
  /** An npm package. */
  Npm = 'NPM',
  /** A nuget package. */
  Nuget = 'NUGET',
  /** A python package. */
  Pypi = 'PYPI',
  /** A rubygems package. */
  Rubygems = 'RUBYGEMS'
}

/** Information about a specific package version. */
export type Github_PackageVersion = Github_Node & {
  __typename?: 'Github_PackageVersion';
  /** List of files associated with this package version */
  files: Github_PackageFileConnection;
  id: Scalars['ID'];
  /** The package associated with this version. */
  package?: Maybe<Github_Package>;
  /** The platform this version was built for. */
  platform?: Maybe<Scalars['String']>;
  /** Whether or not this version is a pre-release. */
  preRelease: Scalars['Boolean'];
  /** The README of this package version. */
  readme?: Maybe<Scalars['String']>;
  /** The release associated with this package version. */
  release?: Maybe<Github_Release>;
  /** Statistics about package activity. */
  statistics?: Maybe<Github_PackageVersionStatistics>;
  /** The package version summary. */
  summary?: Maybe<Scalars['String']>;
  /** The version string. */
  version: Scalars['String'];
};


/** Information about a specific package version. */
export type Github_PackageVersionFilesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_PackageFileOrder>;
};

/** The connection type for PackageVersion. */
export type Github_PackageVersionConnection = {
  __typename?: 'Github_PackageVersionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_PackageVersionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_PackageVersion>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_PackageVersionEdge = {
  __typename?: 'Github_PackageVersionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_PackageVersion>;
};

/** Ways in which lists of package versions can be ordered upon return. */
export type Github_PackageVersionOrder = {
  /** The direction in which to order package versions by the specified field. */
  direction?: InputMaybe<Github_OrderDirection>;
  /** The field in which to order package versions by. */
  field?: InputMaybe<Github_PackageVersionOrderField>;
};

/** Properties by which package version connections can be ordered. */
export enum Github_PackageVersionOrderField {
  /** Order package versions by creation time */
  CreatedAt = 'CREATED_AT'
}

/** Represents a object that contains package version activity statistics such as downloads. */
export type Github_PackageVersionStatistics = {
  __typename?: 'Github_PackageVersionStatistics';
  /** Number of times the package was downloaded since it was created. */
  downloadsTotalCount: Scalars['Int'];
};

/** Types that can grant permissions on a repository to a user */
export type Github_PermissionGranter = Github_Organization | Github_Repository | Github_Team;

/** A level of permission and source for a user's access to a repository. */
export type Github_PermissionSource = {
  __typename?: 'Github_PermissionSource';
  /** The organization the repository belongs to. */
  organization: Github_Organization;
  /** The level of access this source has granted to the user. */
  permission: Github_DefaultRepositoryPermissionField;
  /** The source of this permission. */
  source: Github_PermissionGranter;
};

/** Autogenerated input type of PinIssue */
export type Github_PinIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the issue to be pinned */
  issueId: Scalars['ID'];
};

/** Autogenerated return type of PinIssue */
export type Github_PinIssuePayload = {
  __typename?: 'Github_PinIssuePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The issue that was pinned */
  issue?: Maybe<Github_Issue>;
};

/** Types that can be pinned to a profile page. */
export type Github_PinnableItem = Github_Gist | Github_Repository;

/** The connection type for PinnableItem. */
export type Github_PinnableItemConnection = {
  __typename?: 'Github_PinnableItemConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_PinnableItemEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_PinnableItem>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_PinnableItemEdge = {
  __typename?: 'Github_PinnableItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_PinnableItem>;
};

/** Represents items that can be pinned to a profile page or dashboard. */
export enum Github_PinnableItemType {
  /** A gist. */
  Gist = 'GIST',
  /** An issue. */
  Issue = 'ISSUE',
  /** An organization. */
  Organization = 'ORGANIZATION',
  /** A project. */
  Project = 'PROJECT',
  /** A pull request. */
  PullRequest = 'PULL_REQUEST',
  /** A repository. */
  Repository = 'REPOSITORY',
  /** A team. */
  Team = 'TEAM',
  /** A user. */
  User = 'USER'
}

/** A Pinned Discussion is a discussion pinned to a repository's index page. */
export type Github_PinnedDiscussion = Github_Node & Github_RepositoryNode & {
  __typename?: 'Github_PinnedDiscussion';
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The discussion that was pinned. */
  discussion: Github_Discussion;
  /** Color stops of the chosen gradient */
  gradientStopColors: Array<Scalars['String']>;
  id: Scalars['ID'];
  /** Background texture pattern */
  pattern: Github_PinnedDiscussionPattern;
  /** The actor that pinned this discussion. */
  pinnedBy: Github_Actor;
  /** Preconfigured background gradient option */
  preconfiguredGradient?: Maybe<Github_PinnedDiscussionGradient>;
  /** The repository associated with this node. */
  repository: Github_Repository;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** The connection type for PinnedDiscussion. */
export type Github_PinnedDiscussionConnection = {
  __typename?: 'Github_PinnedDiscussionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_PinnedDiscussionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_PinnedDiscussion>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_PinnedDiscussionEdge = {
  __typename?: 'Github_PinnedDiscussionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_PinnedDiscussion>;
};

/** Preconfigured gradients that may be used to style discussions pinned within a repository. */
export enum Github_PinnedDiscussionGradient {
  /** A gradient of blue to mint */
  BlueMint = 'BLUE_MINT',
  /** A gradient of blue to purple */
  BluePurple = 'BLUE_PURPLE',
  /** A gradient of pink to blue */
  PinkBlue = 'PINK_BLUE',
  /** A gradient of purple to coral */
  PurpleCoral = 'PURPLE_CORAL',
  /** A gradient of red to orange */
  RedOrange = 'RED_ORANGE'
}

/** Preconfigured background patterns that may be used to style discussions pinned within a repository. */
export enum Github_PinnedDiscussionPattern {
  /** An upward-facing chevron pattern */
  ChevronUp = 'CHEVRON_UP',
  /** A hollow dot pattern */
  Dot = 'DOT',
  /** A solid dot pattern */
  DotFill = 'DOT_FILL',
  /** A heart pattern */
  HeartFill = 'HEART_FILL',
  /** A plus sign pattern */
  Plus = 'PLUS',
  /** A lightning bolt pattern */
  Zap = 'ZAP'
}

/** Represents a 'pinned' event on a given issue or pull request. */
export type Github_PinnedEvent = Github_Node & {
  __typename?: 'Github_PinnedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Identifies the issue associated with the event. */
  issue: Github_Issue;
};

/** A Pinned Issue is a issue pinned to a repository's index page. */
export type Github_PinnedIssue = Github_Node & {
  __typename?: 'Github_PinnedIssue';
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** The issue that was pinned. */
  issue: Github_Issue;
  /** The actor that pinned this issue. */
  pinnedBy: Github_Actor;
  /** The repository that this issue was pinned to. */
  repository: Github_Repository;
};

/** The connection type for PinnedIssue. */
export type Github_PinnedIssueConnection = {
  __typename?: 'Github_PinnedIssueConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_PinnedIssueEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_PinnedIssue>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_PinnedIssueEdge = {
  __typename?: 'Github_PinnedIssueEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_PinnedIssue>;
};

/** Audit log entry for a private_repository_forking.disable event. */
export type Github_PrivateRepositoryForkingDisableAuditEntry = Github_AuditEntry & Github_EnterpriseAuditEntryData & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  __typename?: 'Github_PrivateRepositoryForkingDisableAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['Github_URI']>;
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a private_repository_forking.enable event. */
export type Github_PrivateRepositoryForkingEnableAuditEntry = Github_AuditEntry & Github_EnterpriseAuditEntryData & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  __typename?: 'Github_PrivateRepositoryForkingEnableAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['Github_URI']>;
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/**
 * A curatable list of repositories relating to a repository owner, which defaults
 * to showing the most popular repositories they own.
 */
export type Github_ProfileItemShowcase = {
  __typename?: 'Github_ProfileItemShowcase';
  /** Whether or not the owner has pinned any repositories or gists. */
  hasPinnedItems: Scalars['Boolean'];
  /**
   * The repositories and gists in the showcase. If the profile owner has any
   * pinned items, those will be returned. Otherwise, the profile owner's popular
   * repositories will be returned.
   */
  items: Github_PinnableItemConnection;
};


/**
 * A curatable list of repositories relating to a repository owner, which defaults
 * to showing the most popular repositories they own.
 */
export type Github_ProfileItemShowcaseItemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Represents any entity on GitHub that has a profile page. */
export type Github_ProfileOwner = {
  /** Determine if this repository owner has any items that can be pinned to their profile. */
  anyPinnableItems: Scalars['Boolean'];
  /** The public profile email. */
  email?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /**
   * Showcases a selection of repositories and gists that the profile owner has
   * either curated or that have been selected automatically based on popularity.
   */
  itemShowcase: Github_ProfileItemShowcase;
  /** The public profile location. */
  location?: Maybe<Scalars['String']>;
  /** The username used to login. */
  login: Scalars['String'];
  /** The public profile name. */
  name?: Maybe<Scalars['String']>;
  /** A list of repositories and gists this profile owner can pin to their profile. */
  pinnableItems: Github_PinnableItemConnection;
  /** A list of repositories and gists this profile owner has pinned to their profile */
  pinnedItems: Github_PinnableItemConnection;
  /** Returns how many more items this profile owner can pin to their profile. */
  pinnedItemsRemaining: Scalars['Int'];
  /** Can the viewer pin repositories and gists to the profile? */
  viewerCanChangePinnedItems: Scalars['Boolean'];
  /** The public profile website URL. */
  websiteUrl?: Maybe<Scalars['Github_URI']>;
};


/** Represents any entity on GitHub that has a profile page. */
export type Github_ProfileOwnerAnyPinnableItemsArgs = {
  type?: InputMaybe<Github_PinnableItemType>;
};


/** Represents any entity on GitHub that has a profile page. */
export type Github_ProfileOwnerPinnableItemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  types?: InputMaybe<Array<Github_PinnableItemType>>;
};


/** Represents any entity on GitHub that has a profile page. */
export type Github_ProfileOwnerPinnedItemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  types?: InputMaybe<Array<Github_PinnableItemType>>;
};

/** Github_ProfileOwner mock concrete type. */
export type Github_ProfileOwner__Mock = Github_ProfileOwner & {
  __typename?: 'Github_ProfileOwner__Mock';
  /** Determine if this repository owner has any items that can be pinned to their profile. */
  anyPinnableItems: Scalars['Boolean'];
  /** The public profile email. */
  email?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /**
   * Showcases a selection of repositories and gists that the profile owner has
   * either curated or that have been selected automatically based on popularity.
   */
  itemShowcase: Github_ProfileItemShowcase;
  /** The public profile location. */
  location?: Maybe<Scalars['String']>;
  /** The username used to login. */
  login: Scalars['String'];
  /** The public profile name. */
  name?: Maybe<Scalars['String']>;
  /** A list of repositories and gists this profile owner can pin to their profile. */
  pinnableItems: Github_PinnableItemConnection;
  /** A list of repositories and gists this profile owner has pinned to their profile */
  pinnedItems: Github_PinnableItemConnection;
  /** Returns how many more items this profile owner can pin to their profile. */
  pinnedItemsRemaining: Scalars['Int'];
  /** Can the viewer pin repositories and gists to the profile? */
  viewerCanChangePinnedItems: Scalars['Boolean'];
  /** The public profile website URL. */
  websiteUrl?: Maybe<Scalars['Github_URI']>;
};


/** Github_ProfileOwner mock concrete type. */
export type Github_ProfileOwner__MockAnyPinnableItemsArgs = {
  type?: InputMaybe<Github_PinnableItemType>;
};


/** Github_ProfileOwner mock concrete type. */
export type Github_ProfileOwner__MockPinnableItemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  types?: InputMaybe<Array<Github_PinnableItemType>>;
};


/** Github_ProfileOwner mock concrete type. */
export type Github_ProfileOwner__MockPinnedItemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  types?: InputMaybe<Array<Github_PinnableItemType>>;
};

/** Projects manage issues, pull requests and notes within a project owner. */
export type Github_Project = Github_Closable & Github_Node & Github_Updatable & {
  __typename?: 'Github_Project';
  /** The project's description body. */
  body?: Maybe<Scalars['String']>;
  /** The projects description body rendered to HTML. */
  bodyHTML: Scalars['Github_HTML'];
  /** `true` if the object is closed (definition of closed may depend on type) */
  closed: Scalars['Boolean'];
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']>;
  /** List of columns in the project */
  columns: Github_ProjectColumnConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The actor who originally created the project. */
  creator?: Maybe<Github_Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** The project's name. */
  name: Scalars['String'];
  /** The project's number. */
  number: Scalars['Int'];
  /** The project's owner. Currently limited to repositories, organizations, and users. */
  owner: Github_ProjectOwner;
  /** List of pending cards in this project */
  pendingCards: Github_ProjectCardConnection;
  /** Project progress details. */
  progress: Github_ProjectProgress;
  /** The HTTP path for this project */
  resourcePath: Scalars['Github_URI'];
  /** Whether the project is open or closed. */
  state: Github_ProjectState;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this project */
  url: Scalars['Github_URI'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
};


/** Projects manage issues, pull requests and notes within a project owner. */
export type Github_ProjectColumnsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Projects manage issues, pull requests and notes within a project owner. */
export type Github_ProjectPendingCardsArgs = {
  after?: InputMaybe<Scalars['String']>;
  archivedStates?: InputMaybe<Array<InputMaybe<Github_ProjectCardArchivedState>>>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** A card in a project. */
export type Github_ProjectCard = Github_Node & {
  __typename?: 'Github_ProjectCard';
  /**
   * The project column this card is associated under. A card may only belong to one
   * project column at a time. The column field will be null if the card is created
   * in a pending state and has yet to be associated with a column. Once cards are
   * associated with a column, they will not become pending in the future.
   */
  column?: Maybe<Github_ProjectColumn>;
  /** The card content item */
  content?: Maybe<Github_ProjectCardItem>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The actor who created this card */
  creator?: Maybe<Github_Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** Whether the card is archived */
  isArchived: Scalars['Boolean'];
  /** The card note */
  note?: Maybe<Scalars['String']>;
  /** The project that contains this card. */
  project: Github_Project;
  /** The HTTP path for this card */
  resourcePath: Scalars['Github_URI'];
  /** The state of ProjectCard */
  state?: Maybe<Github_ProjectCardState>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this card */
  url: Scalars['Github_URI'];
};

/** The possible archived states of a project card. */
export enum Github_ProjectCardArchivedState {
  /** A project card that is archived */
  Archived = 'ARCHIVED',
  /** A project card that is not archived */
  NotArchived = 'NOT_ARCHIVED'
}

/** The connection type for ProjectCard. */
export type Github_ProjectCardConnection = {
  __typename?: 'Github_ProjectCardConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_ProjectCardEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_ProjectCard>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_ProjectCardEdge = {
  __typename?: 'Github_ProjectCardEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_ProjectCard>;
};

/** An issue or PR and its owning repository to be used in a project card. */
export type Github_ProjectCardImport = {
  /** The issue or pull request number. */
  number: Scalars['Int'];
  /** Repository name with owner (owner/repository). */
  repository: Scalars['String'];
};

/** Types that can be inside Project Cards. */
export type Github_ProjectCardItem = Github_Issue | Github_PullRequest;

/** Various content states of a ProjectCard */
export enum Github_ProjectCardState {
  /** The card has content only. */
  ContentOnly = 'CONTENT_ONLY',
  /** The card has a note only. */
  NoteOnly = 'NOTE_ONLY',
  /** The card is redacted. */
  Redacted = 'REDACTED'
}

/** A column inside a project. */
export type Github_ProjectColumn = Github_Node & {
  __typename?: 'Github_ProjectColumn';
  /** List of cards in the column */
  cards: Github_ProjectCardConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** The project column's name. */
  name: Scalars['String'];
  /** The project that contains this column. */
  project: Github_Project;
  /** The semantic purpose of the column */
  purpose?: Maybe<Github_ProjectColumnPurpose>;
  /** The HTTP path for this project column */
  resourcePath: Scalars['Github_URI'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this project column */
  url: Scalars['Github_URI'];
};


/** A column inside a project. */
export type Github_ProjectColumnCardsArgs = {
  after?: InputMaybe<Scalars['String']>;
  archivedStates?: InputMaybe<Array<InputMaybe<Github_ProjectCardArchivedState>>>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for ProjectColumn. */
export type Github_ProjectColumnConnection = {
  __typename?: 'Github_ProjectColumnConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_ProjectColumnEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_ProjectColumn>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_ProjectColumnEdge = {
  __typename?: 'Github_ProjectColumnEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_ProjectColumn>;
};

/** A project column and a list of its issues and PRs. */
export type Github_ProjectColumnImport = {
  /** The name of the column. */
  columnName: Scalars['String'];
  /** A list of issues and pull requests in the column. */
  issues?: InputMaybe<Array<Github_ProjectCardImport>>;
  /** The position of the column, starting from 0. */
  position: Scalars['Int'];
};

/** The semantic purpose of the column - todo, in progress, or done. */
export enum Github_ProjectColumnPurpose {
  /** The column contains cards which are complete */
  Done = 'DONE',
  /** The column contains cards which are currently being worked on */
  InProgress = 'IN_PROGRESS',
  /** The column contains cards still to be worked on */
  Todo = 'TODO'
}

/** A list of projects associated with the owner. */
export type Github_ProjectConnection = {
  __typename?: 'Github_ProjectConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_ProjectEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Project>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_ProjectEdge = {
  __typename?: 'Github_ProjectEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Project>;
};

/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type Github_ProjectNext = Github_Closable & Github_Node & Github_Updatable & {
  __typename?: 'Github_ProjectNext';
  /** Returns true if the project is closed. */
  closed: Scalars['Boolean'];
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The actor who originally created the project. */
  creator?: Maybe<Github_Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The project's description. */
  description?: Maybe<Scalars['String']>;
  /** List of fields in the project */
  fields: Github_ProjectNextFieldConnection;
  id: Scalars['ID'];
  /** List of items in the project */
  items: Github_ProjectNextItemConnection;
  /** The project's number. */
  number: Scalars['Int'];
  /** The project's owner. Currently limited to organizations and users. */
  owner: Github_ProjectNextOwner;
  /** The HTTP path for this project */
  resourcePath: Scalars['Github_URI'];
  /** The project's name. */
  title?: Maybe<Scalars['String']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this project */
  url: Scalars['Github_URI'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type Github_ProjectNextFieldsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** New projects that manage issues, pull requests and drafts using tables and boards. */
export type Github_ProjectNextItemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for ProjectNext. */
export type Github_ProjectNextConnection = {
  __typename?: 'Github_ProjectNextConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_ProjectNextEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_ProjectNext>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_ProjectNextEdge = {
  __typename?: 'Github_ProjectNextEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_ProjectNext>;
};

/** A field inside a project. */
export type Github_ProjectNextField = {
  __typename?: 'Github_ProjectNextField';
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** The project field's name. */
  name: Scalars['String'];
  /** The project that contains this column. */
  project: Github_ProjectNext;
  /** The field's settings. */
  settings?: Maybe<Scalars['String']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** The connection type for ProjectNextField. */
export type Github_ProjectNextFieldConnection = {
  __typename?: 'Github_ProjectNextFieldConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_ProjectNextFieldEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_ProjectNextField>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_ProjectNextFieldEdge = {
  __typename?: 'Github_ProjectNextFieldEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_ProjectNextField>;
};

/** An item within a new Project. */
export type Github_ProjectNextItem = Github_Node & {
  __typename?: 'Github_ProjectNextItem';
  /** The content of the referenced issue or pull request */
  content?: Maybe<Github_ProjectNextItemContent>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The actor who created the item. */
  creator?: Maybe<Github_Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** List of field values */
  fieldValues: Github_ProjectNextItemFieldValueConnection;
  id: Scalars['ID'];
  /** The project that contains this item. */
  project: Github_ProjectNext;
  /** The title of the item */
  title?: Maybe<Scalars['String']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};


/** An item within a new Project. */
export type Github_ProjectNextItemFieldValuesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for ProjectNextItem. */
export type Github_ProjectNextItemConnection = {
  __typename?: 'Github_ProjectNextItemConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_ProjectNextItemEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_ProjectNextItem>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Types that can be inside Project Items. */
export type Github_ProjectNextItemContent = Github_Issue | Github_PullRequest;

/** An edge in a connection. */
export type Github_ProjectNextItemEdge = {
  __typename?: 'Github_ProjectNextItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_ProjectNextItem>;
};

/** An value of a field in an item of a new Project. */
export type Github_ProjectNextItemFieldValue = Github_Node & {
  __typename?: 'Github_ProjectNextItemFieldValue';
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The actor who created the item. */
  creator?: Maybe<Github_Actor>;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** The project field that contains this value. */
  projectField: Github_ProjectNextField;
  /** The project item that contains this value. */
  projectItem: Github_ProjectNextItem;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The value of a field */
  value?: Maybe<Scalars['String']>;
};

/** The connection type for ProjectNextItemFieldValue. */
export type Github_ProjectNextItemFieldValueConnection = {
  __typename?: 'Github_ProjectNextItemFieldValueConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_ProjectNextItemFieldValueEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_ProjectNextItemFieldValue>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_ProjectNextItemFieldValueEdge = {
  __typename?: 'Github_ProjectNextItemFieldValueEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_ProjectNextItemFieldValue>;
};

/** Properties by which the return project can be ordered. */
export enum Github_ProjectNextOrderField {
  /** The project's date and time of creation */
  CreatedAt = 'CREATED_AT',
  /** The project's number */
  Number = 'NUMBER',
  /** The project's title */
  Title = 'TITLE',
  /** The project's date and time of update */
  UpdatedAt = 'UPDATED_AT'
}

/** Represents an owner of a project (beta). */
export type Github_ProjectNextOwner = {
  id: Scalars['ID'];
  /** Find a project by project (beta) number. */
  projectNext?: Maybe<Github_ProjectNext>;
  /** A list of project (beta) items under the owner. */
  projectsNext: Github_ProjectNextConnection;
};


/** Represents an owner of a project (beta). */
export type Github_ProjectNextOwnerProjectNextArgs = {
  number: Scalars['Int'];
};


/** Represents an owner of a project (beta). */
export type Github_ProjectNextOwnerProjectsNextArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  query?: InputMaybe<Scalars['String']>;
  sortBy?: InputMaybe<Github_ProjectNextOrderField>;
};

/** Github_ProjectNextOwner mock concrete type. */
export type Github_ProjectNextOwner__Mock = Github_ProjectNextOwner & {
  __typename?: 'Github_ProjectNextOwner__Mock';
  id: Scalars['ID'];
  /** Find a project by project (beta) number. */
  projectNext?: Maybe<Github_ProjectNext>;
  /** A list of project (beta) items under the owner. */
  projectsNext: Github_ProjectNextConnection;
};


/** Github_ProjectNextOwner mock concrete type. */
export type Github_ProjectNextOwner__MockProjectNextArgs = {
  number: Scalars['Int'];
};


/** Github_ProjectNextOwner mock concrete type. */
export type Github_ProjectNextOwner__MockProjectsNextArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  query?: InputMaybe<Scalars['String']>;
  sortBy?: InputMaybe<Github_ProjectNextOrderField>;
};

/** Ways in which lists of projects can be ordered upon return. */
export type Github_ProjectOrder = {
  /** The direction in which to order projects by the specified field. */
  direction: Github_OrderDirection;
  /** The field in which to order projects by. */
  field: Github_ProjectOrderField;
};

/** Properties by which project connections can be ordered. */
export enum Github_ProjectOrderField {
  /** Order projects by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order projects by name */
  Name = 'NAME',
  /** Order projects by update time */
  UpdatedAt = 'UPDATED_AT'
}

/** Represents an owner of a Project. */
export type Github_ProjectOwner = {
  id: Scalars['ID'];
  /** Find project by number. */
  project?: Maybe<Github_Project>;
  /** A list of projects under the owner. */
  projects: Github_ProjectConnection;
  /** The HTTP path listing owners projects */
  projectsResourcePath: Scalars['Github_URI'];
  /** The HTTP URL listing owners projects */
  projectsUrl: Scalars['Github_URI'];
  /** Can the current viewer create new projects on this owner. */
  viewerCanCreateProjects: Scalars['Boolean'];
};


/** Represents an owner of a Project. */
export type Github_ProjectOwnerProjectArgs = {
  number: Scalars['Int'];
};


/** Represents an owner of a Project. */
export type Github_ProjectOwnerProjectsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ProjectOrder>;
  search?: InputMaybe<Scalars['String']>;
  states?: InputMaybe<Array<Github_ProjectState>>;
};

/** Github_ProjectOwner mock concrete type. */
export type Github_ProjectOwner__Mock = Github_ProjectOwner & {
  __typename?: 'Github_ProjectOwner__Mock';
  id: Scalars['ID'];
  /** Find project by number. */
  project?: Maybe<Github_Project>;
  /** A list of projects under the owner. */
  projects: Github_ProjectConnection;
  /** The HTTP path listing owners projects */
  projectsResourcePath: Scalars['Github_URI'];
  /** The HTTP URL listing owners projects */
  projectsUrl: Scalars['Github_URI'];
  /** Can the current viewer create new projects on this owner. */
  viewerCanCreateProjects: Scalars['Boolean'];
};


/** Github_ProjectOwner mock concrete type. */
export type Github_ProjectOwner__MockProjectArgs = {
  number: Scalars['Int'];
};


/** Github_ProjectOwner mock concrete type. */
export type Github_ProjectOwner__MockProjectsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ProjectOrder>;
  search?: InputMaybe<Scalars['String']>;
  states?: InputMaybe<Array<Github_ProjectState>>;
};

/** Project progress stats. */
export type Github_ProjectProgress = {
  __typename?: 'Github_ProjectProgress';
  /** The number of done cards. */
  doneCount: Scalars['Int'];
  /** The percentage of done cards. */
  donePercentage: Scalars['Float'];
  /** Whether progress tracking is enabled and cards with purpose exist for this project */
  enabled: Scalars['Boolean'];
  /** The number of in-progress cards. */
  inProgressCount: Scalars['Int'];
  /** The percentage of in-progress cards. */
  inProgressPercentage: Scalars['Float'];
  /** The number of to do cards. */
  todoCount: Scalars['Int'];
  /** The percentage of to do cards. */
  todoPercentage: Scalars['Float'];
};

/** State of the project; either 'open' or 'closed' */
export enum Github_ProjectState {
  /** The project is closed. */
  Closed = 'CLOSED',
  /** The project is open. */
  Open = 'OPEN'
}

/** GitHub-provided templates for Projects */
export enum Github_ProjectTemplate {
  /** Create a board with v2 triggers to automatically move cards across To do, In progress and Done columns. */
  AutomatedKanbanV2 = 'AUTOMATED_KANBAN_V2',
  /** Create a board with triggers to automatically move cards across columns with review automation. */
  AutomatedReviewsKanban = 'AUTOMATED_REVIEWS_KANBAN',
  /** Create a board with columns for To do, In progress and Done. */
  BasicKanban = 'BASIC_KANBAN',
  /** Create a board to triage and prioritize bugs with To do, priority, and Done columns. */
  BugTriage = 'BUG_TRIAGE'
}

/** A user's public key. */
export type Github_PublicKey = Github_Node & {
  __typename?: 'Github_PublicKey';
  /** The last time this authorization was used to perform an action. Values will be null for keys not owned by the user. */
  accessedAt?: Maybe<Scalars['DateTime']>;
  /**
   * Identifies the date and time when the key was created. Keys created before
   * March 5th, 2014 have inaccurate values. Values will be null for keys not owned by the user.
   */
  createdAt?: Maybe<Scalars['DateTime']>;
  /** The fingerprint for this PublicKey. */
  fingerprint: Scalars['String'];
  id: Scalars['ID'];
  /** Whether this PublicKey is read-only or not. Values will be null for keys not owned by the user. */
  isReadOnly?: Maybe<Scalars['Boolean']>;
  /** The public key string. */
  key: Scalars['String'];
  /**
   * Identifies the date and time when the key was updated. Keys created before
   * March 5th, 2014 may have inaccurate values. Values will be null for keys not
   * owned by the user.
   */
  updatedAt?: Maybe<Scalars['DateTime']>;
};

/** The connection type for PublicKey. */
export type Github_PublicKeyConnection = {
  __typename?: 'Github_PublicKeyConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_PublicKeyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_PublicKey>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_PublicKeyEdge = {
  __typename?: 'Github_PublicKeyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_PublicKey>;
};

/** A repository pull request. */
export type Github_PullRequest = Github_Assignable & Github_Closable & Github_Comment & Github_Labelable & Github_Lockable & Github_Node & Github_ProjectNextOwner & Github_Reactable & Github_RepositoryNode & Github_Subscribable & Github_UniformResourceLocatable & Github_Updatable & Github_UpdatableComment & {
  __typename?: 'Github_PullRequest';
  /** Reason that the conversation was locked. */
  activeLockReason?: Maybe<Github_LockReason>;
  /** The number of additions in this pull request. */
  additions: Scalars['Int'];
  /** A list of Users assigned to this object. */
  assignees: Github_UserConnection;
  /** The actor who authored the comment. */
  author?: Maybe<Github_Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: Github_CommentAuthorAssociation;
  /** Returns the auto-merge request object if one exists for this pull request. */
  autoMergeRequest?: Maybe<Github_AutoMergeRequest>;
  /** Identifies the base Ref associated with the pull request. */
  baseRef?: Maybe<Github_Ref>;
  /** Identifies the name of the base Ref associated with the pull request, even if the ref has been deleted. */
  baseRefName: Scalars['String'];
  /** Identifies the oid of the base ref associated with the pull request, even if the ref has been deleted. */
  baseRefOid: Scalars['Github_GitObjectID'];
  /** The repository associated with this pull request's base Ref. */
  baseRepository?: Maybe<Github_Repository>;
  /** The body as Markdown. */
  body: Scalars['String'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['Github_HTML'];
  /** The body rendered to text. */
  bodyText: Scalars['String'];
  /** Whether or not the pull request is rebaseable. */
  canBeRebased: Scalars['Boolean'];
  /** The number of changed files in this pull request. */
  changedFiles: Scalars['Int'];
  /** The HTTP path for the checks of this pull request. */
  checksResourcePath: Scalars['Github_URI'];
  /** The HTTP URL for the checks of this pull request. */
  checksUrl: Scalars['Github_URI'];
  /** `true` if the pull request is closed */
  closed: Scalars['Boolean'];
  /** Identifies the date and time when the object was closed. */
  closedAt?: Maybe<Scalars['DateTime']>;
  /** List of issues that were may be closed by this pull request */
  closingIssuesReferences?: Maybe<Github_IssueConnection>;
  /** A list of comments associated with the pull request. */
  comments: Github_IssueCommentConnection;
  /** A list of commits present in this pull request's head branch not present in the base branch. */
  commits: Github_PullRequestCommitConnection;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The number of deletions in this pull request. */
  deletions: Scalars['Int'];
  /** The actor who edited this pull request's body. */
  editor?: Maybe<Github_Actor>;
  /** Lists the files changed within this pull request. */
  files?: Maybe<Github_PullRequestChangedFileConnection>;
  /** Identifies the head Ref associated with the pull request. */
  headRef?: Maybe<Github_Ref>;
  /** Identifies the name of the head Ref associated with the pull request, even if the ref has been deleted. */
  headRefName: Scalars['String'];
  /** Identifies the oid of the head ref associated with the pull request, even if the ref has been deleted. */
  headRefOid: Scalars['Github_GitObjectID'];
  /** The repository associated with this pull request's head Ref. */
  headRepository?: Maybe<Github_Repository>;
  /** The owner of the repository associated with this pull request's head Ref. */
  headRepositoryOwner?: Maybe<Github_RepositoryOwner>;
  /** The hovercard information for this issue */
  hovercard: Github_Hovercard;
  id: Scalars['ID'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'];
  /** The head and base repositories are different. */
  isCrossRepository: Scalars['Boolean'];
  /** Identifies if the pull request is a draft. */
  isDraft: Scalars['Boolean'];
  /** Is this pull request read by the viewer */
  isReadByViewer?: Maybe<Scalars['Boolean']>;
  /** A list of labels associated with the object. */
  labels?: Maybe<Github_LabelConnection>;
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>;
  /** A list of latest reviews per user associated with the pull request. */
  latestOpinionatedReviews?: Maybe<Github_PullRequestReviewConnection>;
  /** A list of latest reviews per user associated with the pull request that are not also pending review. */
  latestReviews?: Maybe<Github_PullRequestReviewConnection>;
  /** `true` if the pull request is locked */
  locked: Scalars['Boolean'];
  /** Indicates whether maintainers can modify the pull request. */
  maintainerCanModify: Scalars['Boolean'];
  /** The commit that was created when this pull request was merged. */
  mergeCommit?: Maybe<Github_Commit>;
  /** Detailed information about the current pull request merge state status. */
  mergeStateStatus: Github_MergeStateStatus;
  /** Whether or not the pull request can be merged based on the existence of merge conflicts. */
  mergeable: Github_MergeableState;
  /** Whether or not the pull request was merged. */
  merged: Scalars['Boolean'];
  /** The date and time that the pull request was merged. */
  mergedAt?: Maybe<Scalars['DateTime']>;
  /** The actor who merged the pull request. */
  mergedBy?: Maybe<Github_Actor>;
  /** Identifies the milestone associated with the pull request. */
  milestone?: Maybe<Github_Milestone>;
  /** Identifies the pull request number. */
  number: Scalars['Int'];
  /** A list of Users that are participating in the Pull Request conversation. */
  participants: Github_UserConnection;
  /** The permalink to the pull request. */
  permalink: Scalars['Github_URI'];
  /**
   * The commit that GitHub automatically generated to test if this pull request
   * could be merged. This field will not return a value if the pull request is
   * merged, or if the test merge commit is still being generated. See the
   * `mergeable` field for more details on the mergeability of the pull request.
   */
  potentialMergeCommit?: Maybe<Github_Commit>;
  /** List of project cards associated with this pull request. */
  projectCards: Github_ProjectCardConnection;
  /** Find a project by project (beta) number. */
  projectNext?: Maybe<Github_ProjectNext>;
  /** A list of project (beta) items under the owner. */
  projectsNext: Github_ProjectNextConnection;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<Github_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: Github_ReactionConnection;
  /** The repository associated with this node. */
  repository: Github_Repository;
  /** The HTTP path for this pull request. */
  resourcePath: Scalars['Github_URI'];
  /** The HTTP path for reverting this pull request. */
  revertResourcePath: Scalars['Github_URI'];
  /** The HTTP URL for reverting this pull request. */
  revertUrl: Scalars['Github_URI'];
  /** The current status of this pull request with respect to code review. */
  reviewDecision?: Maybe<Github_PullRequestReviewDecision>;
  /** A list of review requests associated with the pull request. */
  reviewRequests?: Maybe<Github_ReviewRequestConnection>;
  /** The list of all review threads for this pull request. */
  reviewThreads: Github_PullRequestReviewThreadConnection;
  /** A list of reviews associated with the pull request. */
  reviews?: Maybe<Github_PullRequestReviewConnection>;
  /** Identifies the state of the pull request. */
  state: Github_PullRequestState;
  /** A list of reviewer suggestions based on commit history and past review comments. */
  suggestedReviewers: Array<Maybe<Github_SuggestedReviewer>>;
  /**
   * A list of events, comments, commits, etc. associated with the pull request.
   * @deprecated `timeline` will be removed Use PullRequest.timelineItems instead. Removal on 2020-10-01 UTC.
   */
  timeline: Github_PullRequestTimelineConnection;
  /** A list of events, comments, commits, etc. associated with the pull request. */
  timelineItems: Github_PullRequestTimelineItemsConnection;
  /** Identifies the pull request title. */
  title: Scalars['String'];
  /** Identifies the pull request title rendered to HTML. */
  titleHTML: Scalars['Github_HTML'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this pull request. */
  url: Scalars['Github_URI'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<Github_UserContentEditConnection>;
  /** Whether or not the viewer can apply suggestion. */
  viewerCanApplySuggestion: Scalars['Boolean'];
  /** Check if the viewer can restore the deleted head ref. */
  viewerCanDeleteHeadRef: Scalars['Boolean'];
  /** Whether or not the viewer can disable auto-merge */
  viewerCanDisableAutoMerge: Scalars['Boolean'];
  /** Whether or not the viewer can enable auto-merge */
  viewerCanEnableAutoMerge: Scalars['Boolean'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<Github_CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'];
  /** The latest review given from the viewer. */
  viewerLatestReview?: Maybe<Github_PullRequestReview>;
  /** The person who has requested the viewer for review on this pull request. */
  viewerLatestReviewRequest?: Maybe<Github_ReviewRequest>;
  /** The merge body text for the viewer and method. */
  viewerMergeBodyText: Scalars['String'];
  /** The merge headline text for the viewer and method. */
  viewerMergeHeadlineText: Scalars['String'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<Github_SubscriptionState>;
};


/** A repository pull request. */
export type Github_PullRequestAssigneesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository pull request. */
export type Github_PullRequestClosingIssuesReferencesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_IssueOrder>;
};


/** A repository pull request. */
export type Github_PullRequestCommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_IssueCommentOrder>;
};


/** A repository pull request. */
export type Github_PullRequestCommitsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository pull request. */
export type Github_PullRequestFilesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository pull request. */
export type Github_PullRequestHovercardArgs = {
  includeNotificationContexts?: InputMaybe<Scalars['Boolean']>;
};


/** A repository pull request. */
export type Github_PullRequestLabelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_LabelOrder>;
};


/** A repository pull request. */
export type Github_PullRequestLatestOpinionatedReviewsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  writersOnly?: InputMaybe<Scalars['Boolean']>;
};


/** A repository pull request. */
export type Github_PullRequestLatestReviewsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository pull request. */
export type Github_PullRequestParticipantsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository pull request. */
export type Github_PullRequestProjectCardsArgs = {
  after?: InputMaybe<Scalars['String']>;
  archivedStates?: InputMaybe<Array<InputMaybe<Github_ProjectCardArchivedState>>>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository pull request. */
export type Github_PullRequestProjectNextArgs = {
  number: Scalars['Int'];
};


/** A repository pull request. */
export type Github_PullRequestProjectsNextArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  query?: InputMaybe<Scalars['String']>;
  sortBy?: InputMaybe<Github_ProjectNextOrderField>;
};


/** A repository pull request. */
export type Github_PullRequestReactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Github_ReactionContent>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ReactionOrder>;
};


/** A repository pull request. */
export type Github_PullRequestReviewRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository pull request. */
export type Github_PullRequestReviewThreadsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository pull request. */
export type Github_PullRequestReviewsArgs = {
  after?: InputMaybe<Scalars['String']>;
  author?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  states?: InputMaybe<Array<Github_PullRequestReviewState>>;
};


/** A repository pull request. */
export type Github_PullRequestTimelineArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  since?: InputMaybe<Scalars['DateTime']>;
};


/** A repository pull request. */
export type Github_PullRequestTimelineItemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  itemTypes?: InputMaybe<Array<Github_PullRequestTimelineItemsItemType>>;
  last?: InputMaybe<Scalars['Int']>;
  since?: InputMaybe<Scalars['DateTime']>;
  skip?: InputMaybe<Scalars['Int']>;
};


/** A repository pull request. */
export type Github_PullRequestUserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository pull request. */
export type Github_PullRequestViewerMergeBodyTextArgs = {
  mergeType?: InputMaybe<Github_PullRequestMergeMethod>;
};


/** A repository pull request. */
export type Github_PullRequestViewerMergeHeadlineTextArgs = {
  mergeType?: InputMaybe<Github_PullRequestMergeMethod>;
};

/** A file changed in a pull request. */
export type Github_PullRequestChangedFile = {
  __typename?: 'Github_PullRequestChangedFile';
  /** The number of additions to the file. */
  additions: Scalars['Int'];
  /** The number of deletions to the file. */
  deletions: Scalars['Int'];
  /** The path of the file. */
  path: Scalars['String'];
  /** The state of the file for the viewer. */
  viewerViewedState: Github_FileViewedState;
};

/** The connection type for PullRequestChangedFile. */
export type Github_PullRequestChangedFileConnection = {
  __typename?: 'Github_PullRequestChangedFileConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_PullRequestChangedFileEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_PullRequestChangedFile>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_PullRequestChangedFileEdge = {
  __typename?: 'Github_PullRequestChangedFileEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_PullRequestChangedFile>;
};

/** Represents a Git commit part of a pull request. */
export type Github_PullRequestCommit = Github_Node & Github_UniformResourceLocatable & {
  __typename?: 'Github_PullRequestCommit';
  /** The Git commit object */
  commit: Github_Commit;
  id: Scalars['ID'];
  /** The pull request this commit belongs to */
  pullRequest: Github_PullRequest;
  /** The HTTP path for this pull request commit */
  resourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this pull request commit */
  url: Scalars['Github_URI'];
};

/** Represents a commit comment thread part of a pull request. */
export type Github_PullRequestCommitCommentThread = Github_Node & Github_RepositoryNode & {
  __typename?: 'Github_PullRequestCommitCommentThread';
  /** The comments that exist in this thread. */
  comments: Github_CommitCommentConnection;
  /** The commit the comments were made on. */
  commit: Github_Commit;
  id: Scalars['ID'];
  /** The file the comments were made on. */
  path?: Maybe<Scalars['String']>;
  /** The position in the diff for the commit that the comment was made on. */
  position?: Maybe<Scalars['Int']>;
  /** The pull request this commit comment thread belongs to */
  pullRequest: Github_PullRequest;
  /** The repository associated with this node. */
  repository: Github_Repository;
};


/** Represents a commit comment thread part of a pull request. */
export type Github_PullRequestCommitCommentThreadCommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for PullRequestCommit. */
export type Github_PullRequestCommitConnection = {
  __typename?: 'Github_PullRequestCommitConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_PullRequestCommitEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_PullRequestCommit>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_PullRequestCommitEdge = {
  __typename?: 'Github_PullRequestCommitEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_PullRequestCommit>;
};

/** The connection type for PullRequest. */
export type Github_PullRequestConnection = {
  __typename?: 'Github_PullRequestConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_PullRequestEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_PullRequest>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** This aggregates pull requests opened by a user within one repository. */
export type Github_PullRequestContributionsByRepository = {
  __typename?: 'Github_PullRequestContributionsByRepository';
  /** The pull request contributions. */
  contributions: Github_CreatedPullRequestContributionConnection;
  /** The repository in which the pull requests were opened. */
  repository: Github_Repository;
};


/** This aggregates pull requests opened by a user within one repository. */
export type Github_PullRequestContributionsByRepositoryContributionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ContributionOrder>;
};

/** An edge in a connection. */
export type Github_PullRequestEdge = {
  __typename?: 'Github_PullRequestEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_PullRequest>;
};

/** Represents available types of methods to use when merging a pull request. */
export enum Github_PullRequestMergeMethod {
  /** Add all commits from the head branch to the base branch with a merge commit. */
  Merge = 'MERGE',
  /** Add all commits from the head branch onto the base branch individually. */
  Rebase = 'REBASE',
  /** Combine all commits from the head branch into a single commit in the base branch. */
  Squash = 'SQUASH'
}

/** Ways in which lists of issues can be ordered upon return. */
export type Github_PullRequestOrder = {
  /** The direction in which to order pull requests by the specified field. */
  direction: Github_OrderDirection;
  /** The field in which to order pull requests by. */
  field: Github_PullRequestOrderField;
};

/** Properties by which pull_requests connections can be ordered. */
export enum Github_PullRequestOrderField {
  /** Order pull_requests by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order pull_requests by update time */
  UpdatedAt = 'UPDATED_AT'
}

/** A review object for a given pull request. */
export type Github_PullRequestReview = Github_Comment & Github_Deletable & Github_Node & Github_Reactable & Github_RepositoryNode & Github_Updatable & Github_UpdatableComment & {
  __typename?: 'Github_PullRequestReview';
  /** The actor who authored the comment. */
  author?: Maybe<Github_Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: Github_CommentAuthorAssociation;
  /** Indicates whether the author of this review has push access to the repository. */
  authorCanPushToRepository: Scalars['Boolean'];
  /** Identifies the pull request review body. */
  body: Scalars['String'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['Github_HTML'];
  /** The body of this review rendered as plain text. */
  bodyText: Scalars['String'];
  /** A list of review comments for the current pull request review. */
  comments: Github_PullRequestReviewCommentConnection;
  /** Identifies the commit associated with this pull request review. */
  commit?: Maybe<Github_Commit>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The actor who edited the comment. */
  editor?: Maybe<Github_Actor>;
  id: Scalars['ID'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>;
  /** A list of teams that this review was made on behalf of. */
  onBehalfOf: Github_TeamConnection;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** Identifies the pull request associated with this pull request review. */
  pullRequest: Github_PullRequest;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<Github_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: Github_ReactionConnection;
  /** The repository associated with this node. */
  repository: Github_Repository;
  /** The HTTP path permalink for this PullRequestReview. */
  resourcePath: Scalars['Github_URI'];
  /** Identifies the current state of the pull request review. */
  state: Github_PullRequestReviewState;
  /** Identifies when the Pull Request Review was submitted */
  submittedAt?: Maybe<Scalars['DateTime']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL permalink for this PullRequestReview. */
  url: Scalars['Github_URI'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<Github_UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<Github_CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'];
};


/** A review object for a given pull request. */
export type Github_PullRequestReviewCommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A review object for a given pull request. */
export type Github_PullRequestReviewOnBehalfOfArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A review object for a given pull request. */
export type Github_PullRequestReviewReactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Github_ReactionContent>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ReactionOrder>;
};


/** A review object for a given pull request. */
export type Github_PullRequestReviewUserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** A review comment associated with a given repository pull request. */
export type Github_PullRequestReviewComment = Github_Comment & Github_Deletable & Github_Minimizable & Github_Node & Github_Reactable & Github_RepositoryNode & Github_Updatable & Github_UpdatableComment & {
  __typename?: 'Github_PullRequestReviewComment';
  /** The actor who authored the comment. */
  author?: Maybe<Github_Actor>;
  /** Author's association with the subject of the comment. */
  authorAssociation: Github_CommentAuthorAssociation;
  /** The comment body of this review comment. */
  body: Scalars['String'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['Github_HTML'];
  /** The comment body of this review comment rendered as plain text. */
  bodyText: Scalars['String'];
  /** Identifies the commit associated with the comment. */
  commit?: Maybe<Github_Commit>;
  /** Identifies when the comment was created. */
  createdAt: Scalars['DateTime'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The diff hunk to which the comment applies. */
  diffHunk: Scalars['String'];
  /** Identifies when the comment was created in a draft state. */
  draftedAt: Scalars['DateTime'];
  /** The actor who edited the comment. */
  editor?: Maybe<Github_Actor>;
  id: Scalars['ID'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'];
  /** Returns whether or not a comment has been minimized. */
  isMinimized: Scalars['Boolean'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>;
  /** Returns why the comment was minimized. */
  minimizedReason?: Maybe<Scalars['String']>;
  /** Identifies the original commit associated with the comment. */
  originalCommit?: Maybe<Github_Commit>;
  /** The original line index in the diff to which the comment applies. */
  originalPosition: Scalars['Int'];
  /** Identifies when the comment body is outdated */
  outdated: Scalars['Boolean'];
  /** The path to which the comment applies. */
  path: Scalars['String'];
  /** The line index in the diff to which the comment applies. */
  position?: Maybe<Scalars['Int']>;
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** The pull request associated with this review comment. */
  pullRequest: Github_PullRequest;
  /** The pull request review associated with this review comment. */
  pullRequestReview?: Maybe<Github_PullRequestReview>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<Github_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: Github_ReactionConnection;
  /** The comment this is a reply to. */
  replyTo?: Maybe<Github_PullRequestReviewComment>;
  /** The repository associated with this node. */
  repository: Github_Repository;
  /** The HTTP path permalink for this review comment. */
  resourcePath: Scalars['Github_URI'];
  /** Identifies the state of the comment. */
  state: Github_PullRequestReviewCommentState;
  /** Identifies when the comment was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL permalink for this review comment. */
  url: Scalars['Github_URI'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<Github_UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'];
  /** Check if the current viewer can minimize this object. */
  viewerCanMinimize: Scalars['Boolean'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<Github_CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'];
};


/** A review comment associated with a given repository pull request. */
export type Github_PullRequestReviewCommentReactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Github_ReactionContent>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ReactionOrder>;
};


/** A review comment associated with a given repository pull request. */
export type Github_PullRequestReviewCommentUserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for PullRequestReviewComment. */
export type Github_PullRequestReviewCommentConnection = {
  __typename?: 'Github_PullRequestReviewCommentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_PullRequestReviewCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_PullRequestReviewComment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_PullRequestReviewCommentEdge = {
  __typename?: 'Github_PullRequestReviewCommentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_PullRequestReviewComment>;
};

/** The possible states of a pull request review comment. */
export enum Github_PullRequestReviewCommentState {
  /** A comment that is part of a pending review */
  Pending = 'PENDING',
  /** A comment that is part of a submitted review */
  Submitted = 'SUBMITTED'
}

/** The connection type for PullRequestReview. */
export type Github_PullRequestReviewConnection = {
  __typename?: 'Github_PullRequestReviewConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_PullRequestReviewEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_PullRequestReview>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** This aggregates pull request reviews made by a user within one repository. */
export type Github_PullRequestReviewContributionsByRepository = {
  __typename?: 'Github_PullRequestReviewContributionsByRepository';
  /** The pull request review contributions. */
  contributions: Github_CreatedPullRequestReviewContributionConnection;
  /** The repository in which the pull request reviews were made. */
  repository: Github_Repository;
};


/** This aggregates pull request reviews made by a user within one repository. */
export type Github_PullRequestReviewContributionsByRepositoryContributionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ContributionOrder>;
};

/** The review status of a pull request. */
export enum Github_PullRequestReviewDecision {
  /** The pull request has received an approving review. */
  Approved = 'APPROVED',
  /** Changes have been requested on the pull request. */
  ChangesRequested = 'CHANGES_REQUESTED',
  /** A review is required before the pull request can be merged. */
  ReviewRequired = 'REVIEW_REQUIRED'
}

/** An edge in a connection. */
export type Github_PullRequestReviewEdge = {
  __typename?: 'Github_PullRequestReviewEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_PullRequestReview>;
};

/** The possible events to perform on a pull request review. */
export enum Github_PullRequestReviewEvent {
  /** Submit feedback and approve merging these changes. */
  Approve = 'APPROVE',
  /** Submit general feedback without explicit approval. */
  Comment = 'COMMENT',
  /** Dismiss review so it now longer effects merging. */
  Dismiss = 'DISMISS',
  /** Submit feedback that must be addressed before merging. */
  RequestChanges = 'REQUEST_CHANGES'
}

/** The possible states of a pull request review. */
export enum Github_PullRequestReviewState {
  /** A review allowing the pull request to merge. */
  Approved = 'APPROVED',
  /** A review blocking the pull request from merging. */
  ChangesRequested = 'CHANGES_REQUESTED',
  /** An informational review. */
  Commented = 'COMMENTED',
  /** A review that has been dismissed. */
  Dismissed = 'DISMISSED',
  /** A review that has not yet been submitted. */
  Pending = 'PENDING'
}

/** A threaded list of comments for a given pull request. */
export type Github_PullRequestReviewThread = Github_Node & {
  __typename?: 'Github_PullRequestReviewThread';
  /** A list of pull request comments associated with the thread. */
  comments: Github_PullRequestReviewCommentConnection;
  /** The side of the diff on which this thread was placed. */
  diffSide: Github_DiffSide;
  id: Scalars['ID'];
  /** Whether or not the thread has been collapsed (resolved) */
  isCollapsed: Scalars['Boolean'];
  /** Indicates whether this thread was outdated by newer changes. */
  isOutdated: Scalars['Boolean'];
  /** Whether this thread has been resolved */
  isResolved: Scalars['Boolean'];
  /** The line in the file to which this thread refers */
  line?: Maybe<Scalars['Int']>;
  /** The original line in the file to which this thread refers. */
  originalLine?: Maybe<Scalars['Int']>;
  /** The original start line in the file to which this thread refers (multi-line only). */
  originalStartLine?: Maybe<Scalars['Int']>;
  /** Identifies the file path of this thread. */
  path: Scalars['String'];
  /** Identifies the pull request associated with this thread. */
  pullRequest: Github_PullRequest;
  /** Identifies the repository associated with this thread. */
  repository: Github_Repository;
  /** The user who resolved this thread */
  resolvedBy?: Maybe<Github_User>;
  /** The side of the diff that the first line of the thread starts on (multi-line only) */
  startDiffSide?: Maybe<Github_DiffSide>;
  /** The start line in the file to which this thread refers (multi-line only) */
  startLine?: Maybe<Scalars['Int']>;
  /** Indicates whether the current viewer can reply to this thread. */
  viewerCanReply: Scalars['Boolean'];
  /** Whether or not the viewer can resolve this thread */
  viewerCanResolve: Scalars['Boolean'];
  /** Whether or not the viewer can unresolve this thread */
  viewerCanUnresolve: Scalars['Boolean'];
};


/** A threaded list of comments for a given pull request. */
export type Github_PullRequestReviewThreadCommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
};

/** Review comment threads for a pull request review. */
export type Github_PullRequestReviewThreadConnection = {
  __typename?: 'Github_PullRequestReviewThreadConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_PullRequestReviewThreadEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_PullRequestReviewThread>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_PullRequestReviewThreadEdge = {
  __typename?: 'Github_PullRequestReviewThreadEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_PullRequestReviewThread>;
};

/** Represents the latest point in the pull request timeline for which the viewer has seen the pull request's commits. */
export type Github_PullRequestRevisionMarker = {
  __typename?: 'Github_PullRequestRevisionMarker';
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The last commit the viewer has seen. */
  lastSeenCommit: Github_Commit;
  /** The pull request to which the marker belongs. */
  pullRequest: Github_PullRequest;
};

/** The possible states of a pull request. */
export enum Github_PullRequestState {
  /** A pull request that has been closed without being merged. */
  Closed = 'CLOSED',
  /** A pull request that has been closed by being merged. */
  Merged = 'MERGED',
  /** A pull request that is still open. */
  Open = 'OPEN'
}

/** A repository pull request template. */
export type Github_PullRequestTemplate = {
  __typename?: 'Github_PullRequestTemplate';
  /** The body of the template */
  body?: Maybe<Scalars['String']>;
  /** The filename of the template */
  filename?: Maybe<Scalars['String']>;
  /** The repository the template belongs to */
  repository: Github_Repository;
};

/** The connection type for PullRequestTimelineItem. */
export type Github_PullRequestTimelineConnection = {
  __typename?: 'Github_PullRequestTimelineConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_PullRequestTimelineItemEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_PullRequestTimelineItem>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An item in a pull request timeline */
export type Github_PullRequestTimelineItem = Github_AssignedEvent | Github_BaseRefDeletedEvent | Github_BaseRefForcePushedEvent | Github_ClosedEvent | Github_Commit | Github_CommitCommentThread | Github_CrossReferencedEvent | Github_DemilestonedEvent | Github_DeployedEvent | Github_DeploymentEnvironmentChangedEvent | Github_HeadRefDeletedEvent | Github_HeadRefForcePushedEvent | Github_HeadRefRestoredEvent | Github_IssueComment | Github_LabeledEvent | Github_LockedEvent | Github_MergedEvent | Github_MilestonedEvent | Github_PullRequestReview | Github_PullRequestReviewComment | Github_PullRequestReviewThread | Github_ReferencedEvent | Github_RenamedTitleEvent | Github_ReopenedEvent | Github_ReviewDismissedEvent | Github_ReviewRequestRemovedEvent | Github_ReviewRequestedEvent | Github_SubscribedEvent | Github_UnassignedEvent | Github_UnlabeledEvent | Github_UnlockedEvent | Github_UnsubscribedEvent | Github_UserBlockedEvent;

/** An edge in a connection. */
export type Github_PullRequestTimelineItemEdge = {
  __typename?: 'Github_PullRequestTimelineItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_PullRequestTimelineItem>;
};

/** An item in a pull request timeline */
export type Github_PullRequestTimelineItems = Github_AddedToProjectEvent | Github_AssignedEvent | Github_AutoMergeDisabledEvent | Github_AutoMergeEnabledEvent | Github_AutoRebaseEnabledEvent | Github_AutoSquashEnabledEvent | Github_AutomaticBaseChangeFailedEvent | Github_AutomaticBaseChangeSucceededEvent | Github_BaseRefChangedEvent | Github_BaseRefDeletedEvent | Github_BaseRefForcePushedEvent | Github_ClosedEvent | Github_CommentDeletedEvent | Github_ConnectedEvent | Github_ConvertToDraftEvent | Github_ConvertedNoteToIssueEvent | Github_ConvertedToDiscussionEvent | Github_CrossReferencedEvent | Github_DemilestonedEvent | Github_DeployedEvent | Github_DeploymentEnvironmentChangedEvent | Github_DisconnectedEvent | Github_HeadRefDeletedEvent | Github_HeadRefForcePushedEvent | Github_HeadRefRestoredEvent | Github_IssueComment | Github_LabeledEvent | Github_LockedEvent | Github_MarkedAsDuplicateEvent | Github_MentionedEvent | Github_MergedEvent | Github_MilestonedEvent | Github_MovedColumnsInProjectEvent | Github_PinnedEvent | Github_PullRequestCommit | Github_PullRequestCommitCommentThread | Github_PullRequestReview | Github_PullRequestReviewThread | Github_PullRequestRevisionMarker | Github_ReadyForReviewEvent | Github_ReferencedEvent | Github_RemovedFromProjectEvent | Github_RenamedTitleEvent | Github_ReopenedEvent | Github_ReviewDismissedEvent | Github_ReviewRequestRemovedEvent | Github_ReviewRequestedEvent | Github_SubscribedEvent | Github_TransferredEvent | Github_UnassignedEvent | Github_UnlabeledEvent | Github_UnlockedEvent | Github_UnmarkedAsDuplicateEvent | Github_UnpinnedEvent | Github_UnsubscribedEvent | Github_UserBlockedEvent;

/** The connection type for PullRequestTimelineItems. */
export type Github_PullRequestTimelineItemsConnection = {
  __typename?: 'Github_PullRequestTimelineItemsConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_PullRequestTimelineItemsEdge>>>;
  /** Identifies the count of items after applying `before` and `after` filters. */
  filteredCount: Scalars['Int'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_PullRequestTimelineItems>>>;
  /** Identifies the count of items after applying `before`/`after` filters and `first`/`last`/`skip` slicing. */
  pageCount: Scalars['Int'];
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
  /** Identifies the date and time when the timeline was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** An edge in a connection. */
export type Github_PullRequestTimelineItemsEdge = {
  __typename?: 'Github_PullRequestTimelineItemsEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_PullRequestTimelineItems>;
};

/** The possible item types found in a timeline. */
export enum Github_PullRequestTimelineItemsItemType {
  /** Represents a 'added_to_project' event on a given issue or pull request. */
  AddedToProjectEvent = 'ADDED_TO_PROJECT_EVENT',
  /** Represents an 'assigned' event on any assignable object. */
  AssignedEvent = 'ASSIGNED_EVENT',
  /** Represents a 'automatic_base_change_failed' event on a given pull request. */
  AutomaticBaseChangeFailedEvent = 'AUTOMATIC_BASE_CHANGE_FAILED_EVENT',
  /** Represents a 'automatic_base_change_succeeded' event on a given pull request. */
  AutomaticBaseChangeSucceededEvent = 'AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT',
  /** Represents a 'auto_merge_disabled' event on a given pull request. */
  AutoMergeDisabledEvent = 'AUTO_MERGE_DISABLED_EVENT',
  /** Represents a 'auto_merge_enabled' event on a given pull request. */
  AutoMergeEnabledEvent = 'AUTO_MERGE_ENABLED_EVENT',
  /** Represents a 'auto_rebase_enabled' event on a given pull request. */
  AutoRebaseEnabledEvent = 'AUTO_REBASE_ENABLED_EVENT',
  /** Represents a 'auto_squash_enabled' event on a given pull request. */
  AutoSquashEnabledEvent = 'AUTO_SQUASH_ENABLED_EVENT',
  /** Represents a 'base_ref_changed' event on a given issue or pull request. */
  BaseRefChangedEvent = 'BASE_REF_CHANGED_EVENT',
  /** Represents a 'base_ref_deleted' event on a given pull request. */
  BaseRefDeletedEvent = 'BASE_REF_DELETED_EVENT',
  /** Represents a 'base_ref_force_pushed' event on a given pull request. */
  BaseRefForcePushedEvent = 'BASE_REF_FORCE_PUSHED_EVENT',
  /** Represents a 'closed' event on any `Closable`. */
  ClosedEvent = 'CLOSED_EVENT',
  /** Represents a 'comment_deleted' event on a given issue or pull request. */
  CommentDeletedEvent = 'COMMENT_DELETED_EVENT',
  /** Represents a 'connected' event on a given issue or pull request. */
  ConnectedEvent = 'CONNECTED_EVENT',
  /** Represents a 'converted_note_to_issue' event on a given issue or pull request. */
  ConvertedNoteToIssueEvent = 'CONVERTED_NOTE_TO_ISSUE_EVENT',
  /** Represents a 'converted_to_discussion' event on a given issue. */
  ConvertedToDiscussionEvent = 'CONVERTED_TO_DISCUSSION_EVENT',
  /** Represents a 'convert_to_draft' event on a given pull request. */
  ConvertToDraftEvent = 'CONVERT_TO_DRAFT_EVENT',
  /** Represents a mention made by one issue or pull request to another. */
  CrossReferencedEvent = 'CROSS_REFERENCED_EVENT',
  /** Represents a 'demilestoned' event on a given issue or pull request. */
  DemilestonedEvent = 'DEMILESTONED_EVENT',
  /** Represents a 'deployed' event on a given pull request. */
  DeployedEvent = 'DEPLOYED_EVENT',
  /** Represents a 'deployment_environment_changed' event on a given pull request. */
  DeploymentEnvironmentChangedEvent = 'DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT',
  /** Represents a 'disconnected' event on a given issue or pull request. */
  DisconnectedEvent = 'DISCONNECTED_EVENT',
  /** Represents a 'head_ref_deleted' event on a given pull request. */
  HeadRefDeletedEvent = 'HEAD_REF_DELETED_EVENT',
  /** Represents a 'head_ref_force_pushed' event on a given pull request. */
  HeadRefForcePushedEvent = 'HEAD_REF_FORCE_PUSHED_EVENT',
  /** Represents a 'head_ref_restored' event on a given pull request. */
  HeadRefRestoredEvent = 'HEAD_REF_RESTORED_EVENT',
  /** Represents a comment on an Issue. */
  IssueComment = 'ISSUE_COMMENT',
  /** Represents a 'labeled' event on a given issue or pull request. */
  LabeledEvent = 'LABELED_EVENT',
  /** Represents a 'locked' event on a given issue or pull request. */
  LockedEvent = 'LOCKED_EVENT',
  /** Represents a 'marked_as_duplicate' event on a given issue or pull request. */
  MarkedAsDuplicateEvent = 'MARKED_AS_DUPLICATE_EVENT',
  /** Represents a 'mentioned' event on a given issue or pull request. */
  MentionedEvent = 'MENTIONED_EVENT',
  /** Represents a 'merged' event on a given pull request. */
  MergedEvent = 'MERGED_EVENT',
  /** Represents a 'milestoned' event on a given issue or pull request. */
  MilestonedEvent = 'MILESTONED_EVENT',
  /** Represents a 'moved_columns_in_project' event on a given issue or pull request. */
  MovedColumnsInProjectEvent = 'MOVED_COLUMNS_IN_PROJECT_EVENT',
  /** Represents a 'pinned' event on a given issue or pull request. */
  PinnedEvent = 'PINNED_EVENT',
  /** Represents a Git commit part of a pull request. */
  PullRequestCommit = 'PULL_REQUEST_COMMIT',
  /** Represents a commit comment thread part of a pull request. */
  PullRequestCommitCommentThread = 'PULL_REQUEST_COMMIT_COMMENT_THREAD',
  /** A review object for a given pull request. */
  PullRequestReview = 'PULL_REQUEST_REVIEW',
  /** A threaded list of comments for a given pull request. */
  PullRequestReviewThread = 'PULL_REQUEST_REVIEW_THREAD',
  /** Represents the latest point in the pull request timeline for which the viewer has seen the pull request's commits. */
  PullRequestRevisionMarker = 'PULL_REQUEST_REVISION_MARKER',
  /** Represents a 'ready_for_review' event on a given pull request. */
  ReadyForReviewEvent = 'READY_FOR_REVIEW_EVENT',
  /** Represents a 'referenced' event on a given `ReferencedSubject`. */
  ReferencedEvent = 'REFERENCED_EVENT',
  /** Represents a 'removed_from_project' event on a given issue or pull request. */
  RemovedFromProjectEvent = 'REMOVED_FROM_PROJECT_EVENT',
  /** Represents a 'renamed' event on a given issue or pull request */
  RenamedTitleEvent = 'RENAMED_TITLE_EVENT',
  /** Represents a 'reopened' event on any `Closable`. */
  ReopenedEvent = 'REOPENED_EVENT',
  /** Represents a 'review_dismissed' event on a given issue or pull request. */
  ReviewDismissedEvent = 'REVIEW_DISMISSED_EVENT',
  /** Represents an 'review_requested' event on a given pull request. */
  ReviewRequestedEvent = 'REVIEW_REQUESTED_EVENT',
  /** Represents an 'review_request_removed' event on a given pull request. */
  ReviewRequestRemovedEvent = 'REVIEW_REQUEST_REMOVED_EVENT',
  /** Represents a 'subscribed' event on a given `Subscribable`. */
  SubscribedEvent = 'SUBSCRIBED_EVENT',
  /** Represents a 'transferred' event on a given issue or pull request. */
  TransferredEvent = 'TRANSFERRED_EVENT',
  /** Represents an 'unassigned' event on any assignable object. */
  UnassignedEvent = 'UNASSIGNED_EVENT',
  /** Represents an 'unlabeled' event on a given issue or pull request. */
  UnlabeledEvent = 'UNLABELED_EVENT',
  /** Represents an 'unlocked' event on a given issue or pull request. */
  UnlockedEvent = 'UNLOCKED_EVENT',
  /** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */
  UnmarkedAsDuplicateEvent = 'UNMARKED_AS_DUPLICATE_EVENT',
  /** Represents an 'unpinned' event on a given issue or pull request. */
  UnpinnedEvent = 'UNPINNED_EVENT',
  /** Represents an 'unsubscribed' event on a given `Subscribable`. */
  UnsubscribedEvent = 'UNSUBSCRIBED_EVENT',
  /** Represents a 'user_blocked' event on a given user. */
  UserBlockedEvent = 'USER_BLOCKED_EVENT'
}

/** The possible target states when updating a pull request. */
export enum Github_PullRequestUpdateState {
  /** A pull request that has been closed without being merged. */
  Closed = 'CLOSED',
  /** A pull request that is still open. */
  Open = 'OPEN'
}

/** A Git push. */
export type Github_Push = Github_Node & {
  __typename?: 'Github_Push';
  id: Scalars['ID'];
  /** The SHA after the push */
  nextSha?: Maybe<Scalars['Github_GitObjectID']>;
  /** The permalink for this push. */
  permalink: Scalars['Github_URI'];
  /** The SHA before the push */
  previousSha?: Maybe<Scalars['Github_GitObjectID']>;
  /** The actor who pushed */
  pusher: Github_Actor;
  /** The repository that was pushed to */
  repository: Github_Repository;
};

/** A team, user or app who has the ability to push to a protected branch. */
export type Github_PushAllowance = Github_Node & {
  __typename?: 'Github_PushAllowance';
  /** The actor that can push. */
  actor?: Maybe<Github_PushAllowanceActor>;
  /** Identifies the branch protection rule associated with the allowed user or team. */
  branchProtectionRule?: Maybe<Github_BranchProtectionRule>;
  id: Scalars['ID'];
};

/** Types that can be an actor. */
export type Github_PushAllowanceActor = Github_App | Github_Team | Github_User;

/** The connection type for PushAllowance. */
export type Github_PushAllowanceConnection = {
  __typename?: 'Github_PushAllowanceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_PushAllowanceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_PushAllowance>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_PushAllowanceEdge = {
  __typename?: 'Github_PushAllowanceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_PushAllowance>;
};

/** Represents the client's rate limit. */
export type Github_RateLimit = {
  __typename?: 'Github_RateLimit';
  /** The point cost for the current query counting against the rate limit. */
  cost: Scalars['Int'];
  /** The maximum number of points the client is permitted to consume in a 60 minute window. */
  limit: Scalars['Int'];
  /** The maximum number of nodes this query may return */
  nodeCount: Scalars['Int'];
  /** The number of points remaining in the current rate limit window. */
  remaining: Scalars['Int'];
  /** The time at which the current rate limit window resets in UTC epoch seconds. */
  resetAt: Scalars['DateTime'];
  /** The number of points used in the current rate limit window. */
  used: Scalars['Int'];
};

/** Represents a subject that can be reacted on. */
export type Github_Reactable = {
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<Github_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: Github_ReactionConnection;
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'];
};


/** Represents a subject that can be reacted on. */
export type Github_ReactableReactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Github_ReactionContent>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ReactionOrder>;
};

/** Github_Reactable mock concrete type. */
export type Github_Reactable__Mock = Github_Reactable & {
  __typename?: 'Github_Reactable__Mock';
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<Github_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: Github_ReactionConnection;
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'];
};


/** Github_Reactable mock concrete type. */
export type Github_Reactable__MockReactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Github_ReactionContent>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ReactionOrder>;
};

/** The connection type for User. */
export type Github_ReactingUserConnection = {
  __typename?: 'Github_ReactingUserConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_ReactingUserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Represents a user that's made a reaction. */
export type Github_ReactingUserEdge = {
  __typename?: 'Github_ReactingUserEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  node: Github_User;
  /** The moment when the user made the reaction. */
  reactedAt: Scalars['DateTime'];
};

/** An emoji reaction to a particular piece of content. */
export type Github_Reaction = Github_Node & {
  __typename?: 'Github_Reaction';
  /** Identifies the emoji reaction. */
  content: Github_ReactionContent;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** The reactable piece of content */
  reactable: Github_Reactable;
  /** Identifies the user who created this reaction. */
  user?: Maybe<Github_User>;
};

/** A list of reactions that have been left on the subject. */
export type Github_ReactionConnection = {
  __typename?: 'Github_ReactionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_ReactionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Reaction>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
  /** Whether or not the authenticated user has left a reaction on the subject. */
  viewerHasReacted: Scalars['Boolean'];
};

/** Emojis that can be attached to Issues, Pull Requests and Comments. */
export enum Github_ReactionContent {
  /** Represents the `:confused:` emoji. */
  Confused = 'CONFUSED',
  /** Represents the `:eyes:` emoji. */
  Eyes = 'EYES',
  /** Represents the `:heart:` emoji. */
  Heart = 'HEART',
  /** Represents the `:hooray:` emoji. */
  Hooray = 'HOORAY',
  /** Represents the `:laugh:` emoji. */
  Laugh = 'LAUGH',
  /** Represents the `:rocket:` emoji. */
  Rocket = 'ROCKET',
  /** Represents the `:-1:` emoji. */
  ThumbsDown = 'THUMBS_DOWN',
  /** Represents the `:+1:` emoji. */
  ThumbsUp = 'THUMBS_UP'
}

/** An edge in a connection. */
export type Github_ReactionEdge = {
  __typename?: 'Github_ReactionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Reaction>;
};

/** A group of emoji reactions to a particular piece of content. */
export type Github_ReactionGroup = {
  __typename?: 'Github_ReactionGroup';
  /** Identifies the emoji reaction. */
  content: Github_ReactionContent;
  /** Identifies when the reaction was created. */
  createdAt?: Maybe<Scalars['DateTime']>;
  /** Reactors to the reaction subject with the emotion represented by this reaction group. */
  reactors: Github_ReactorConnection;
  /** The subject that was reacted to. */
  subject: Github_Reactable;
  /**
   * Users who have reacted to the reaction subject with the emotion represented by this reaction group
   * @deprecated Reactors can now be mannequins, bots, and organizations. Use the `reactors` field instead. Removal on 2021-10-01 UTC.
   */
  users: Github_ReactingUserConnection;
  /** Whether or not the authenticated user has left a reaction on the subject. */
  viewerHasReacted: Scalars['Boolean'];
};


/** A group of emoji reactions to a particular piece of content. */
export type Github_ReactionGroupReactorsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A group of emoji reactions to a particular piece of content. */
export type Github_ReactionGroupUsersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Ways in which lists of reactions can be ordered upon return. */
export type Github_ReactionOrder = {
  /** The direction in which to order reactions by the specified field. */
  direction: Github_OrderDirection;
  /** The field in which to order reactions by. */
  field: Github_ReactionOrderField;
};

/** A list of fields that reactions can be ordered by. */
export enum Github_ReactionOrderField {
  /** Allows ordering a list of reactions by when they were created. */
  CreatedAt = 'CREATED_AT'
}

/** Types that can be assigned to reactions. */
export type Github_Reactor = Github_Bot | Github_Mannequin | Github_Organization | Github_User;

/** The connection type for Reactor. */
export type Github_ReactorConnection = {
  __typename?: 'Github_ReactorConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_ReactorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Reactor>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Represents an author of a reaction. */
export type Github_ReactorEdge = {
  __typename?: 'Github_ReactorEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The author of the reaction. */
  node: Github_Reactor;
  /** The moment when the user made the reaction. */
  reactedAt: Scalars['DateTime'];
};

/** Represents a 'ready_for_review' event on a given pull request. */
export type Github_ReadyForReviewEvent = Github_Node & Github_UniformResourceLocatable & {
  __typename?: 'Github_ReadyForReviewEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest: Github_PullRequest;
  /** The HTTP path for this ready for review event. */
  resourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this ready for review event. */
  url: Scalars['Github_URI'];
};

/** Represents a Git reference. */
export type Github_Ref = Github_Node & {
  __typename?: 'Github_Ref';
  /** A list of pull requests with this ref as the head ref. */
  associatedPullRequests: Github_PullRequestConnection;
  /** Branch protection rules for this ref */
  branchProtectionRule?: Maybe<Github_BranchProtectionRule>;
  id: Scalars['ID'];
  /** The ref name. */
  name: Scalars['String'];
  /** The ref's prefix, such as `refs/heads/` or `refs/tags/`. */
  prefix: Scalars['String'];
  /** Branch protection rules that are viewable by non-admins */
  refUpdateRule?: Maybe<Github_RefUpdateRule>;
  /** The repository the ref belongs to. */
  repository: Github_Repository;
  /** The object the ref points to. Returns null when object does not exist. */
  target?: Maybe<Github_GitObject>;
};


/** Represents a Git reference. */
export type Github_RefAssociatedPullRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  baseRefName?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  headRefName?: InputMaybe<Scalars['String']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_IssueOrder>;
  states?: InputMaybe<Array<Github_PullRequestState>>;
};

/** The connection type for Ref. */
export type Github_RefConnection = {
  __typename?: 'Github_RefConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_RefEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Ref>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_RefEdge = {
  __typename?: 'Github_RefEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Ref>;
};

/** Ways in which lists of git refs can be ordered upon return. */
export type Github_RefOrder = {
  /** The direction in which to order refs by the specified field. */
  direction: Github_OrderDirection;
  /** The field in which to order refs by. */
  field: Github_RefOrderField;
};

/** Properties by which ref connections can be ordered. */
export enum Github_RefOrderField {
  /** Order refs by their alphanumeric name */
  Alphabetical = 'ALPHABETICAL',
  /** Order refs by underlying commit date if the ref prefix is refs/tags/ */
  TagCommitDate = 'TAG_COMMIT_DATE'
}

/** A ref update */
export type Github_RefUpdate = {
  /** The value this ref should be updated to. */
  afterOid: Scalars['Github_GitObjectID'];
  /** The value this ref needs to point to before the update. */
  beforeOid?: InputMaybe<Scalars['Github_GitObjectID']>;
  /** Force a non fast-forward update. */
  force?: InputMaybe<Scalars['Boolean']>;
  /** The fully qualified name of the ref to be update. For example `refs/heads/branch-name` */
  name: Scalars['Github_GitRefname'];
};

/** A ref update rules for a viewer. */
export type Github_RefUpdateRule = {
  __typename?: 'Github_RefUpdateRule';
  /** Can this branch be deleted. */
  allowsDeletions: Scalars['Boolean'];
  /** Are force pushes allowed on this branch. */
  allowsForcePushes: Scalars['Boolean'];
  /** Identifies the protection rule pattern. */
  pattern: Scalars['String'];
  /** Number of approving reviews required to update matching branches. */
  requiredApprovingReviewCount?: Maybe<Scalars['Int']>;
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  requiredStatusCheckContexts?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Are reviews from code owners required to update matching branches. */
  requiresCodeOwnerReviews: Scalars['Boolean'];
  /** Are conversations required to be resolved before merging. */
  requiresConversationResolution: Scalars['Boolean'];
  /** Are merge commits prohibited from being pushed to this branch. */
  requiresLinearHistory: Scalars['Boolean'];
  /** Are commits required to be signed. */
  requiresSignatures: Scalars['Boolean'];
  /** Is the viewer allowed to dismiss reviews. */
  viewerAllowedToDismissReviews: Scalars['Boolean'];
  /** Can the viewer push to the branch */
  viewerCanPush: Scalars['Boolean'];
};

/** Represents a 'referenced' event on a given `ReferencedSubject`. */
export type Github_ReferencedEvent = Github_Node & {
  __typename?: 'Github_ReferencedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the commit associated with the 'referenced' event. */
  commit?: Maybe<Github_Commit>;
  /** Identifies the repository associated with the 'referenced' event. */
  commitRepository: Github_Repository;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Reference originated in a different repository. */
  isCrossRepository: Scalars['Boolean'];
  /** Checks if the commit message itself references the subject. Can be false in the case of a commit comment reference. */
  isDirectReference: Scalars['Boolean'];
  /** Object referenced by event. */
  subject: Github_ReferencedSubject;
};

/** Any referencable object */
export type Github_ReferencedSubject = Github_Issue | Github_PullRequest;

/** Autogenerated input type of RegenerateEnterpriseIdentityProviderRecoveryCodes */
export type Github_RegenerateEnterpriseIdentityProviderRecoveryCodesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise on which to set an identity provider. */
  enterpriseId: Scalars['ID'];
};

/** Autogenerated return type of RegenerateEnterpriseIdentityProviderRecoveryCodes */
export type Github_RegenerateEnterpriseIdentityProviderRecoveryCodesPayload = {
  __typename?: 'Github_RegenerateEnterpriseIdentityProviderRecoveryCodesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The identity provider for the enterprise. */
  identityProvider?: Maybe<Github_EnterpriseIdentityProvider>;
};

/** Autogenerated input type of RegenerateVerifiableDomainToken */
export type Github_RegenerateVerifiableDomainTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the verifiable domain to regenerate the verification token of. */
  id: Scalars['ID'];
};

/** Autogenerated return type of RegenerateVerifiableDomainToken */
export type Github_RegenerateVerifiableDomainTokenPayload = {
  __typename?: 'Github_RegenerateVerifiableDomainTokenPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The verification token that was generated. */
  verificationToken?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of RejectDeployments */
export type Github_RejectDeploymentsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Optional comment for rejecting deployments */
  comment?: InputMaybe<Scalars['String']>;
  /** The ids of environments to reject deployments */
  environmentIds: Array<Scalars['ID']>;
  /** The node ID of the workflow run containing the pending deployments. */
  workflowRunId: Scalars['ID'];
};

/** Autogenerated return type of RejectDeployments */
export type Github_RejectDeploymentsPayload = {
  __typename?: 'Github_RejectDeploymentsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The affected deployments. */
  deployments?: Maybe<Array<Github_Deployment>>;
};

/** A release contains the content for a release. */
export type Github_Release = Github_Node & Github_Reactable & Github_UniformResourceLocatable & {
  __typename?: 'Github_Release';
  /** The author of the release */
  author?: Maybe<Github_User>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The description of the release. */
  description?: Maybe<Scalars['String']>;
  /** The description of this release rendered to HTML. */
  descriptionHTML?: Maybe<Scalars['Github_HTML']>;
  id: Scalars['ID'];
  /** Whether or not the release is a draft */
  isDraft: Scalars['Boolean'];
  /** Whether or not the release is the latest releast */
  isLatest: Scalars['Boolean'];
  /** Whether or not the release is a prerelease */
  isPrerelease: Scalars['Boolean'];
  /** A list of users mentioned in the release description */
  mentions?: Maybe<Github_UserConnection>;
  /** The title of the release. */
  name?: Maybe<Scalars['String']>;
  /** Identifies the date and time when the release was created. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<Github_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: Github_ReactionConnection;
  /** List of releases assets which are dependent on this release. */
  releaseAssets: Github_ReleaseAssetConnection;
  /** The repository that the release belongs to. */
  repository: Github_Repository;
  /** The HTTP path for this issue */
  resourcePath: Scalars['Github_URI'];
  /** A description of the release, rendered to HTML without any links in it. */
  shortDescriptionHTML?: Maybe<Scalars['Github_HTML']>;
  /** The Git tag the release points to */
  tag?: Maybe<Github_Ref>;
  /** The tag commit for this release. */
  tagCommit?: Maybe<Github_Commit>;
  /** The name of the release's Git tag */
  tagName: Scalars['String'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this issue */
  url: Scalars['Github_URI'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'];
};


/** A release contains the content for a release. */
export type Github_ReleaseMentionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A release contains the content for a release. */
export type Github_ReleaseReactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Github_ReactionContent>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ReactionOrder>;
};


/** A release contains the content for a release. */
export type Github_ReleaseReleaseAssetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
};


/** A release contains the content for a release. */
export type Github_ReleaseShortDescriptionHtmlArgs = {
  limit?: InputMaybe<Scalars['Int']>;
};

/** A release asset contains the content for a release asset. */
export type Github_ReleaseAsset = Github_Node & {
  __typename?: 'Github_ReleaseAsset';
  /** The asset's content-type */
  contentType: Scalars['String'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The number of times this asset was downloaded */
  downloadCount: Scalars['Int'];
  /** Identifies the URL where you can download the release asset via the browser. */
  downloadUrl: Scalars['Github_URI'];
  id: Scalars['ID'];
  /** Identifies the title of the release asset. */
  name: Scalars['String'];
  /** Release that the asset is associated with */
  release?: Maybe<Github_Release>;
  /** The size (in bytes) of the asset */
  size: Scalars['Int'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The user that performed the upload */
  uploadedBy: Github_User;
  /** Identifies the URL of the release asset. */
  url: Scalars['Github_URI'];
};

/** The connection type for ReleaseAsset. */
export type Github_ReleaseAssetConnection = {
  __typename?: 'Github_ReleaseAssetConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_ReleaseAssetEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_ReleaseAsset>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_ReleaseAssetEdge = {
  __typename?: 'Github_ReleaseAssetEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_ReleaseAsset>;
};

/** The connection type for Release. */
export type Github_ReleaseConnection = {
  __typename?: 'Github_ReleaseConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_ReleaseEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Release>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_ReleaseEdge = {
  __typename?: 'Github_ReleaseEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Release>;
};

/** Ways in which lists of releases can be ordered upon return. */
export type Github_ReleaseOrder = {
  /** The direction in which to order releases by the specified field. */
  direction: Github_OrderDirection;
  /** The field in which to order releases by. */
  field: Github_ReleaseOrderField;
};

/** Properties by which release connections can be ordered. */
export enum Github_ReleaseOrderField {
  /** Order releases by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order releases alphabetically by name */
  Name = 'NAME'
}

/** Autogenerated input type of RemoveAssigneesFromAssignable */
export type Github_RemoveAssigneesFromAssignableInput = {
  /** The id of the assignable object to remove assignees from. */
  assignableId: Scalars['ID'];
  /** The id of users to remove as assignees. */
  assigneeIds: Array<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of RemoveAssigneesFromAssignable */
export type Github_RemoveAssigneesFromAssignablePayload = {
  __typename?: 'Github_RemoveAssigneesFromAssignablePayload';
  /** The item that was unassigned. */
  assignable?: Maybe<Github_Assignable>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of RemoveEnterpriseAdmin */
export type Github_RemoveEnterpriseAdminInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Enterprise ID from which to remove the administrator. */
  enterpriseId: Scalars['ID'];
  /** The login of the user to remove as an administrator. */
  login: Scalars['String'];
};

/** Autogenerated return type of RemoveEnterpriseAdmin */
export type Github_RemoveEnterpriseAdminPayload = {
  __typename?: 'Github_RemoveEnterpriseAdminPayload';
  /** The user who was removed as an administrator. */
  admin?: Maybe<Github_User>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated enterprise. */
  enterprise?: Maybe<Github_Enterprise>;
  /** A message confirming the result of removing an administrator. */
  message?: Maybe<Scalars['String']>;
  /** The viewer performing the mutation. */
  viewer?: Maybe<Github_User>;
};

/** Autogenerated input type of RemoveEnterpriseIdentityProvider */
export type Github_RemoveEnterpriseIdentityProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise from which to remove the identity provider. */
  enterpriseId: Scalars['ID'];
};

/** Autogenerated return type of RemoveEnterpriseIdentityProvider */
export type Github_RemoveEnterpriseIdentityProviderPayload = {
  __typename?: 'Github_RemoveEnterpriseIdentityProviderPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The identity provider that was removed from the enterprise. */
  identityProvider?: Maybe<Github_EnterpriseIdentityProvider>;
};

/** Autogenerated input type of RemoveEnterpriseOrganization */
export type Github_RemoveEnterpriseOrganizationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise from which the organization should be removed. */
  enterpriseId: Scalars['ID'];
  /** The ID of the organization to remove from the enterprise. */
  organizationId: Scalars['ID'];
};

/** Autogenerated return type of RemoveEnterpriseOrganization */
export type Github_RemoveEnterpriseOrganizationPayload = {
  __typename?: 'Github_RemoveEnterpriseOrganizationPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated enterprise. */
  enterprise?: Maybe<Github_Enterprise>;
  /** The organization that was removed from the enterprise. */
  organization?: Maybe<Github_Organization>;
  /** The viewer performing the mutation. */
  viewer?: Maybe<Github_User>;
};

/** Autogenerated input type of RemoveEnterpriseSupportEntitlement */
export type Github_RemoveEnterpriseSupportEntitlementInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the Enterprise which the admin belongs to. */
  enterpriseId: Scalars['ID'];
  /** The login of a member who will lose the support entitlement. */
  login: Scalars['String'];
};

/** Autogenerated return type of RemoveEnterpriseSupportEntitlement */
export type Github_RemoveEnterpriseSupportEntitlementPayload = {
  __typename?: 'Github_RemoveEnterpriseSupportEntitlementPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A message confirming the result of removing the support entitlement. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of RemoveLabelsFromLabelable */
export type Github_RemoveLabelsFromLabelableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ids of labels to remove. */
  labelIds: Array<Scalars['ID']>;
  /** The id of the Labelable to remove labels from. */
  labelableId: Scalars['ID'];
};

/** Autogenerated return type of RemoveLabelsFromLabelable */
export type Github_RemoveLabelsFromLabelablePayload = {
  __typename?: 'Github_RemoveLabelsFromLabelablePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Labelable the labels were removed from. */
  labelable?: Maybe<Github_Labelable>;
};

/** Autogenerated input type of RemoveOutsideCollaborator */
export type Github_RemoveOutsideCollaboratorInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the organization to remove the outside collaborator from. */
  organizationId: Scalars['ID'];
  /** The ID of the outside collaborator to remove. */
  userId: Scalars['ID'];
};

/** Autogenerated return type of RemoveOutsideCollaborator */
export type Github_RemoveOutsideCollaboratorPayload = {
  __typename?: 'Github_RemoveOutsideCollaboratorPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The user that was removed as an outside collaborator. */
  removedUser?: Maybe<Github_User>;
};

/** Autogenerated input type of RemoveReaction */
export type Github_RemoveReactionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The name of the emoji reaction to remove. */
  content: Github_ReactionContent;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID'];
};

/** Autogenerated return type of RemoveReaction */
export type Github_RemoveReactionPayload = {
  __typename?: 'Github_RemoveReactionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The reaction object. */
  reaction?: Maybe<Github_Reaction>;
  /** The reactable subject. */
  subject?: Maybe<Github_Reactable>;
};

/** Autogenerated input type of RemoveStar */
export type Github_RemoveStarInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Starrable ID to unstar. */
  starrableId: Scalars['ID'];
};

/** Autogenerated return type of RemoveStar */
export type Github_RemoveStarPayload = {
  __typename?: 'Github_RemoveStarPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The starrable. */
  starrable?: Maybe<Github_Starrable>;
};

/** Autogenerated input type of RemoveUpvote */
export type Github_RemoveUpvoteInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the discussion or comment to remove upvote. */
  subjectId: Scalars['ID'];
};

/** Autogenerated return type of RemoveUpvote */
export type Github_RemoveUpvotePayload = {
  __typename?: 'Github_RemoveUpvotePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The votable subject. */
  subject?: Maybe<Github_Votable>;
};

/** Represents a 'removed_from_project' event on a given issue or pull request. */
export type Github_RemovedFromProjectEvent = Github_Node & {
  __typename?: 'Github_RemovedFromProjectEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** Project referenced by event. */
  project?: Maybe<Github_Project>;
  /** Column name referenced by this project event. */
  projectColumnName: Scalars['String'];
};

/** Represents a 'renamed' event on a given issue or pull request */
export type Github_RenamedTitleEvent = Github_Node & {
  __typename?: 'Github_RenamedTitleEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the current title of the issue or pull request. */
  currentTitle: Scalars['String'];
  id: Scalars['ID'];
  /** Identifies the previous title of the issue or pull request. */
  previousTitle: Scalars['String'];
  /** Subject that was renamed. */
  subject: Github_RenamedTitleSubject;
};

/** An object which has a renamable title */
export type Github_RenamedTitleSubject = Github_Issue | Github_PullRequest;

/** Autogenerated input type of ReopenIssue */
export type Github_ReopenIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the issue to be opened. */
  issueId: Scalars['ID'];
};

/** Autogenerated return type of ReopenIssue */
export type Github_ReopenIssuePayload = {
  __typename?: 'Github_ReopenIssuePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The issue that was opened. */
  issue?: Maybe<Github_Issue>;
};

/** Autogenerated input type of ReopenPullRequest */
export type Github_ReopenPullRequestInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the pull request to be reopened. */
  pullRequestId: Scalars['ID'];
};

/** Autogenerated return type of ReopenPullRequest */
export type Github_ReopenPullRequestPayload = {
  __typename?: 'Github_ReopenPullRequestPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The pull request that was reopened. */
  pullRequest?: Maybe<Github_PullRequest>;
};

/** Represents a 'reopened' event on any `Closable`. */
export type Github_ReopenedEvent = Github_Node & {
  __typename?: 'Github_ReopenedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Object that was reopened. */
  closable: Github_Closable;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
};

/** Audit log entry for a repo.access event. */
export type Github_RepoAccessAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  __typename?: 'Github_RepoAccessAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
  /** The visibility of the repository */
  visibility?: Maybe<Github_RepoAccessAuditEntryVisibility>;
};

/** The privacy of a repository */
export enum Github_RepoAccessAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC'
}

/** Audit log entry for a repo.add_member event. */
export type Github_RepoAddMemberAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  __typename?: 'Github_RepoAddMemberAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
  /** The visibility of the repository */
  visibility?: Maybe<Github_RepoAddMemberAuditEntryVisibility>;
};

/** The privacy of a repository */
export enum Github_RepoAddMemberAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC'
}

/** Audit log entry for a repo.add_topic event. */
export type Github_RepoAddTopicAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & Github_TopicAuditEntryData & {
  __typename?: 'Github_RepoAddTopicAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The name of the topic added to the repository */
  topic?: Maybe<Github_Topic>;
  /** The name of the topic added to the repository */
  topicName?: Maybe<Scalars['String']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a repo.archived event. */
export type Github_RepoArchivedAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  __typename?: 'Github_RepoArchivedAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
  /** The visibility of the repository */
  visibility?: Maybe<Github_RepoArchivedAuditEntryVisibility>;
};

/** The privacy of a repository */
export enum Github_RepoArchivedAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC'
}

/** Audit log entry for a repo.change_merge_setting event. */
export type Github_RepoChangeMergeSettingAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  __typename?: 'Github_RepoChangeMergeSettingAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** Whether the change was to enable (true) or disable (false) the merge type */
  isEnabled?: Maybe<Scalars['Boolean']>;
  /** The merge method affected by the change */
  mergeType?: Maybe<Github_RepoChangeMergeSettingAuditEntryMergeType>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** The merge options available for pull requests to this repository. */
export enum Github_RepoChangeMergeSettingAuditEntryMergeType {
  /** The pull request is added to the base branch in a merge commit. */
  Merge = 'MERGE',
  /** Commits from the pull request are added onto the base branch individually without a merge commit. */
  Rebase = 'REBASE',
  /** The pull request's commits are squashed into a single commit before they are merged to the base branch. */
  Squash = 'SQUASH'
}

/** Audit log entry for a repo.config.disable_anonymous_git_access event. */
export type Github_RepoConfigDisableAnonymousGitAccessAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  __typename?: 'Github_RepoConfigDisableAnonymousGitAccessAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a repo.config.disable_collaborators_only event. */
export type Github_RepoConfigDisableCollaboratorsOnlyAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  __typename?: 'Github_RepoConfigDisableCollaboratorsOnlyAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a repo.config.disable_contributors_only event. */
export type Github_RepoConfigDisableContributorsOnlyAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  __typename?: 'Github_RepoConfigDisableContributorsOnlyAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a repo.config.disable_sockpuppet_disallowed event. */
export type Github_RepoConfigDisableSockpuppetDisallowedAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  __typename?: 'Github_RepoConfigDisableSockpuppetDisallowedAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a repo.config.enable_anonymous_git_access event. */
export type Github_RepoConfigEnableAnonymousGitAccessAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  __typename?: 'Github_RepoConfigEnableAnonymousGitAccessAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a repo.config.enable_collaborators_only event. */
export type Github_RepoConfigEnableCollaboratorsOnlyAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  __typename?: 'Github_RepoConfigEnableCollaboratorsOnlyAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a repo.config.enable_contributors_only event. */
export type Github_RepoConfigEnableContributorsOnlyAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  __typename?: 'Github_RepoConfigEnableContributorsOnlyAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a repo.config.enable_sockpuppet_disallowed event. */
export type Github_RepoConfigEnableSockpuppetDisallowedAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  __typename?: 'Github_RepoConfigEnableSockpuppetDisallowedAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a repo.config.lock_anonymous_git_access event. */
export type Github_RepoConfigLockAnonymousGitAccessAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  __typename?: 'Github_RepoConfigLockAnonymousGitAccessAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a repo.config.unlock_anonymous_git_access event. */
export type Github_RepoConfigUnlockAnonymousGitAccessAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  __typename?: 'Github_RepoConfigUnlockAnonymousGitAccessAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a repo.create event. */
export type Github_RepoCreateAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  __typename?: 'Github_RepoCreateAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  /** The name of the parent repository for this forked repository. */
  forkParentName?: Maybe<Scalars['String']>;
  /** The name of the root repository for this network. */
  forkSourceName?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
  /** The visibility of the repository */
  visibility?: Maybe<Github_RepoCreateAuditEntryVisibility>;
};

/** The privacy of a repository */
export enum Github_RepoCreateAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC'
}

/** Audit log entry for a repo.destroy event. */
export type Github_RepoDestroyAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  __typename?: 'Github_RepoDestroyAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
  /** The visibility of the repository */
  visibility?: Maybe<Github_RepoDestroyAuditEntryVisibility>;
};

/** The privacy of a repository */
export enum Github_RepoDestroyAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC'
}

/** Audit log entry for a repo.remove_member event. */
export type Github_RepoRemoveMemberAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & {
  __typename?: 'Github_RepoRemoveMemberAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
  /** The visibility of the repository */
  visibility?: Maybe<Github_RepoRemoveMemberAuditEntryVisibility>;
};

/** The privacy of a repository */
export enum Github_RepoRemoveMemberAuditEntryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC'
}

/** Audit log entry for a repo.remove_topic event. */
export type Github_RepoRemoveTopicAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & Github_TopicAuditEntryData & {
  __typename?: 'Github_RepoRemoveTopicAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The name of the topic added to the repository */
  topic?: Maybe<Github_Topic>;
  /** The name of the topic added to the repository */
  topicName?: Maybe<Scalars['String']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** The reasons a piece of content can be reported or minimized. */
export enum Github_ReportedContentClassifiers {
  /** An abusive or harassing piece of content */
  Abuse = 'ABUSE',
  /** A duplicated piece of content */
  Duplicate = 'DUPLICATE',
  /** An irrelevant piece of content */
  OffTopic = 'OFF_TOPIC',
  /** An outdated piece of content */
  Outdated = 'OUTDATED',
  /** The content has been resolved */
  Resolved = 'RESOLVED',
  /** A spammy piece of content */
  Spam = 'SPAM'
}

/** A repository contains the content for a project. */
export type Github_Repository = Github_Node & Github_PackageOwner & Github_ProjectOwner & Github_RepositoryInfo & Github_Starrable & Github_Subscribable & Github_UniformResourceLocatable & {
  __typename?: 'Github_Repository';
  /** A list of users that can be assigned to issues in this repository. */
  assignableUsers: Github_UserConnection;
  /** Whether or not Auto-merge can be enabled on pull requests in this repository. */
  autoMergeAllowed: Scalars['Boolean'];
  /** A list of branch protection rules for this repository. */
  branchProtectionRules: Github_BranchProtectionRuleConnection;
  /** Returns the code of conduct for this repository */
  codeOfConduct?: Maybe<Github_CodeOfConduct>;
  /** A list of collaborators associated with the repository. */
  collaborators?: Maybe<Github_RepositoryCollaboratorConnection>;
  /** A list of commit comments associated with the repository. */
  commitComments: Github_CommitCommentConnection;
  /** Returns a list of contact links associated to the repository */
  contactLinks?: Maybe<Array<Github_RepositoryContactLink>>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The Ref associated with the repository's default branch. */
  defaultBranchRef?: Maybe<Github_Ref>;
  /** Whether or not branches are automatically deleted when merged in this repository. */
  deleteBranchOnMerge: Scalars['Boolean'];
  /** A list of dependency manifests contained in the repository */
  dependencyGraphManifests?: Maybe<Github_DependencyGraphManifestConnection>;
  /** A list of deploy keys that are on this repository. */
  deployKeys: Github_DeployKeyConnection;
  /** Deployments associated with the repository */
  deployments: Github_DeploymentConnection;
  /** The description of the repository. */
  description?: Maybe<Scalars['String']>;
  /** The description of the repository rendered to HTML. */
  descriptionHTML: Scalars['Github_HTML'];
  /** Returns a single discussion from the current repository by number. */
  discussion?: Maybe<Github_Discussion>;
  /** A list of discussion categories that are available in the repository. */
  discussionCategories: Github_DiscussionCategoryConnection;
  /** A list of discussions that have been opened in the repository. */
  discussions: Github_DiscussionConnection;
  /** The number of kilobytes this repository occupies on disk. */
  diskUsage?: Maybe<Scalars['Int']>;
  /** Returns a single active environment from the current repository by name. */
  environment?: Maybe<Github_Environment>;
  /** A list of environments that are in this repository. */
  environments: Github_EnvironmentConnection;
  /** Returns how many forks there are of this repository in the whole network. */
  forkCount: Scalars['Int'];
  /** Whether this repository allows forks. */
  forkingAllowed: Scalars['Boolean'];
  /** A list of direct forked repositories. */
  forks: Github_RepositoryConnection;
  /** The funding links for this repository */
  fundingLinks: Array<Github_FundingLink>;
  /** Indicates if the repository has issues feature enabled. */
  hasIssuesEnabled: Scalars['Boolean'];
  /** Indicates if the repository has the Projects feature enabled. */
  hasProjectsEnabled: Scalars['Boolean'];
  /** Indicates if the repository has wiki feature enabled. */
  hasWikiEnabled: Scalars['Boolean'];
  /** The repository's URL. */
  homepageUrl?: Maybe<Scalars['Github_URI']>;
  id: Scalars['ID'];
  /** The interaction ability settings for this repository. */
  interactionAbility?: Maybe<Github_RepositoryInteractionAbility>;
  /** Indicates if the repository is unmaintained. */
  isArchived: Scalars['Boolean'];
  /** Returns true if blank issue creation is allowed */
  isBlankIssuesEnabled: Scalars['Boolean'];
  /** Returns whether or not this repository disabled. */
  isDisabled: Scalars['Boolean'];
  /** Returns whether or not this repository is empty. */
  isEmpty: Scalars['Boolean'];
  /** Identifies if the repository is a fork. */
  isFork: Scalars['Boolean'];
  /** Indicates if a repository is either owned by an organization, or is a private fork of an organization repository. */
  isInOrganization: Scalars['Boolean'];
  /** Indicates if the repository has been locked or not. */
  isLocked: Scalars['Boolean'];
  /** Identifies if the repository is a mirror. */
  isMirror: Scalars['Boolean'];
  /** Identifies if the repository is private or internal. */
  isPrivate: Scalars['Boolean'];
  /** Returns true if this repository has a security policy */
  isSecurityPolicyEnabled?: Maybe<Scalars['Boolean']>;
  /** Identifies if the repository is a template that can be used to generate new repositories. */
  isTemplate: Scalars['Boolean'];
  /** Is this repository a user configuration repository? */
  isUserConfigurationRepository: Scalars['Boolean'];
  /** Returns a single issue from the current repository by number. */
  issue?: Maybe<Github_Issue>;
  /** Returns a single issue-like object from the current repository by number. */
  issueOrPullRequest?: Maybe<Github_IssueOrPullRequest>;
  /** Returns a list of issue templates associated to the repository */
  issueTemplates?: Maybe<Array<Github_IssueTemplate>>;
  /** A list of issues that have been opened in the repository. */
  issues: Github_IssueConnection;
  /** Returns a single label by name */
  label?: Maybe<Github_Label>;
  /** A list of labels associated with the repository. */
  labels?: Maybe<Github_LabelConnection>;
  /** A list containing a breakdown of the language composition of the repository. */
  languages?: Maybe<Github_LanguageConnection>;
  /** Get the latest release for the repository if one exists. */
  latestRelease?: Maybe<Github_Release>;
  /** The license associated with the repository */
  licenseInfo?: Maybe<Github_License>;
  /** The reason the repository has been locked. */
  lockReason?: Maybe<Github_RepositoryLockReason>;
  /** A list of Users that can be mentioned in the context of the repository. */
  mentionableUsers: Github_UserConnection;
  /** Whether or not PRs are merged with a merge commit on this repository. */
  mergeCommitAllowed: Scalars['Boolean'];
  /** Returns a single milestone from the current repository by number. */
  milestone?: Maybe<Github_Milestone>;
  /** A list of milestones associated with the repository. */
  milestones?: Maybe<Github_MilestoneConnection>;
  /** The repository's original mirror URL. */
  mirrorUrl?: Maybe<Scalars['Github_URI']>;
  /** The name of the repository. */
  name: Scalars['String'];
  /** The repository's name with owner. */
  nameWithOwner: Scalars['String'];
  /** A Git object in the repository */
  object?: Maybe<Github_GitObject>;
  /** The image used to represent this repository in Open Graph data. */
  openGraphImageUrl: Scalars['Github_URI'];
  /** The User owner of the repository. */
  owner: Github_RepositoryOwner;
  /** A list of packages under the owner. */
  packages: Github_PackageConnection;
  /** The repository parent, if this is a fork. */
  parent?: Maybe<Github_Repository>;
  /** A list of discussions that have been pinned in this repository. */
  pinnedDiscussions: Github_PinnedDiscussionConnection;
  /** A list of pinned issues for this repository. */
  pinnedIssues?: Maybe<Github_PinnedIssueConnection>;
  /** The primary language of the repository's code. */
  primaryLanguage?: Maybe<Github_Language>;
  /** Find project by number. */
  project?: Maybe<Github_Project>;
  /** A list of projects under the owner. */
  projects: Github_ProjectConnection;
  /** The HTTP path listing the repository's projects */
  projectsResourcePath: Scalars['Github_URI'];
  /** The HTTP URL listing the repository's projects */
  projectsUrl: Scalars['Github_URI'];
  /** Returns a single pull request from the current repository by number. */
  pullRequest?: Maybe<Github_PullRequest>;
  /** Returns a list of pull request templates associated to the repository */
  pullRequestTemplates?: Maybe<Array<Github_PullRequestTemplate>>;
  /** A list of pull requests that have been opened in the repository. */
  pullRequests: Github_PullRequestConnection;
  /** Identifies when the repository was last pushed to. */
  pushedAt?: Maybe<Scalars['DateTime']>;
  /** Whether or not rebase-merging is enabled on this repository. */
  rebaseMergeAllowed: Scalars['Boolean'];
  /** Fetch a given ref from the repository */
  ref?: Maybe<Github_Ref>;
  /** Fetch a list of refs from the repository */
  refs?: Maybe<Github_RefConnection>;
  /** Lookup a single release given various criteria. */
  release?: Maybe<Github_Release>;
  /** List of releases which are dependent on this repository. */
  releases: Github_ReleaseConnection;
  /** A list of applied repository-topic associations for this repository. */
  repositoryTopics: Github_RepositoryTopicConnection;
  /** The HTTP path for this repository */
  resourcePath: Scalars['Github_URI'];
  /** The security policy URL. */
  securityPolicyUrl?: Maybe<Scalars['Github_URI']>;
  /** A description of the repository, rendered to HTML without any links in it. */
  shortDescriptionHTML: Scalars['Github_HTML'];
  /** Whether or not squash-merging is enabled on this repository. */
  squashMergeAllowed: Scalars['Boolean'];
  /** The SSH URL to clone this repository */
  sshUrl: Scalars['Github_GitSSHRemote'];
  /** Returns a count of how many stargazers there are on this object */
  stargazerCount: Scalars['Int'];
  /** A list of users who have starred this starrable. */
  stargazers: Github_StargazerConnection;
  /**
   * Returns a list of all submodules in this repository parsed from the
   * .gitmodules file as of the default branch's HEAD commit.
   */
  submodules: Github_SubmoduleConnection;
  /** Temporary authentication token for cloning this repository. */
  tempCloneToken?: Maybe<Scalars['String']>;
  /** The repository from which this repository was generated, if any. */
  templateRepository?: Maybe<Github_Repository>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this repository */
  url: Scalars['Github_URI'];
  /** Whether this repository has a custom image to use with Open Graph as opposed to being represented by the owner's avatar. */
  usesCustomOpenGraphImage: Scalars['Boolean'];
  /** Indicates whether the viewer has admin permissions on this repository. */
  viewerCanAdminister: Scalars['Boolean'];
  /** Can the current viewer create new projects on this owner. */
  viewerCanCreateProjects: Scalars['Boolean'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean'];
  /** Indicates whether the viewer can update the topics of this repository. */
  viewerCanUpdateTopics: Scalars['Boolean'];
  /** The last commit email for the viewer. */
  viewerDefaultCommitEmail?: Maybe<Scalars['String']>;
  /** The last used merge method by the viewer or the default for the repository. */
  viewerDefaultMergeMethod: Github_PullRequestMergeMethod;
  /** Returns a boolean indicating whether the viewing user has starred this starrable. */
  viewerHasStarred: Scalars['Boolean'];
  /** The users permission level on the repository. Will return null if authenticated as an GitHub App. */
  viewerPermission?: Maybe<Github_RepositoryPermission>;
  /** A list of emails this viewer can commit with. */
  viewerPossibleCommitEmails?: Maybe<Array<Scalars['String']>>;
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<Github_SubscriptionState>;
  /** Indicates the repository's visibility level. */
  visibility: Github_RepositoryVisibility;
  /** A list of vulnerability alerts that are on this repository. */
  vulnerabilityAlerts?: Maybe<Github_RepositoryVulnerabilityAlertConnection>;
  /** A list of users watching the repository. */
  watchers: Github_UserConnection;
};


/** A repository contains the content for a project. */
export type Github_RepositoryAssignableUsersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  query?: InputMaybe<Scalars['String']>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryBranchProtectionRulesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryCollaboratorsArgs = {
  affiliation?: InputMaybe<Github_CollaboratorAffiliation>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  query?: InputMaybe<Scalars['String']>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryCommitCommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryDependencyGraphManifestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  dependenciesAfter?: InputMaybe<Scalars['String']>;
  dependenciesFirst?: InputMaybe<Scalars['Int']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  withDependencies?: InputMaybe<Scalars['Boolean']>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryDeployKeysArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryDeploymentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  environments?: InputMaybe<Array<Scalars['String']>>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_DeploymentOrder>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryDiscussionArgs = {
  number: Scalars['Int'];
};


/** A repository contains the content for a project. */
export type Github_RepositoryDiscussionCategoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filterByAssignable?: InputMaybe<Scalars['Boolean']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  categoryId?: InputMaybe<Scalars['ID']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_DiscussionOrder>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryEnvironmentArgs = {
  name: Scalars['String'];
};


/** A repository contains the content for a project. */
export type Github_RepositoryEnvironmentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryForksArgs = {
  affiliations?: InputMaybe<Array<InputMaybe<Github_RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  isLocked?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_RepositoryOrder>;
  ownerAffiliations?: InputMaybe<Array<InputMaybe<Github_RepositoryAffiliation>>>;
  privacy?: InputMaybe<Github_RepositoryPrivacy>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryIssueArgs = {
  number: Scalars['Int'];
};


/** A repository contains the content for a project. */
export type Github_RepositoryIssueOrPullRequestArgs = {
  number: Scalars['Int'];
};


/** A repository contains the content for a project. */
export type Github_RepositoryIssuesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filterBy?: InputMaybe<Github_IssueFilters>;
  first?: InputMaybe<Scalars['Int']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_IssueOrder>;
  states?: InputMaybe<Array<Github_IssueState>>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryLabelArgs = {
  name: Scalars['String'];
};


/** A repository contains the content for a project. */
export type Github_RepositoryLabelsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_LabelOrder>;
  query?: InputMaybe<Scalars['String']>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryLanguagesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_LanguageOrder>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryMentionableUsersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  query?: InputMaybe<Scalars['String']>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryMilestoneArgs = {
  number: Scalars['Int'];
};


/** A repository contains the content for a project. */
export type Github_RepositoryMilestonesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_MilestoneOrder>;
  query?: InputMaybe<Scalars['String']>;
  states?: InputMaybe<Array<Github_MilestoneState>>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryObjectArgs = {
  expression?: InputMaybe<Scalars['String']>;
  oid?: InputMaybe<Scalars['Github_GitObjectID']>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryPackagesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  names?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  orderBy?: InputMaybe<Github_PackageOrder>;
  packageType?: InputMaybe<Github_PackageType>;
  repositoryId?: InputMaybe<Scalars['ID']>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryPinnedDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryPinnedIssuesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryProjectArgs = {
  number: Scalars['Int'];
};


/** A repository contains the content for a project. */
export type Github_RepositoryProjectsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ProjectOrder>;
  search?: InputMaybe<Scalars['String']>;
  states?: InputMaybe<Array<Github_ProjectState>>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryPullRequestArgs = {
  number: Scalars['Int'];
};


/** A repository contains the content for a project. */
export type Github_RepositoryPullRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  baseRefName?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  headRefName?: InputMaybe<Scalars['String']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_IssueOrder>;
  states?: InputMaybe<Array<Github_PullRequestState>>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryRefArgs = {
  qualifiedName: Scalars['String'];
};


/** A repository contains the content for a project. */
export type Github_RepositoryRefsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  direction?: InputMaybe<Github_OrderDirection>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_RefOrder>;
  query?: InputMaybe<Scalars['String']>;
  refPrefix: Scalars['String'];
};


/** A repository contains the content for a project. */
export type Github_RepositoryReleaseArgs = {
  tagName: Scalars['String'];
};


/** A repository contains the content for a project. */
export type Github_RepositoryReleasesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ReleaseOrder>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryRepositoryTopicsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryShortDescriptionHtmlArgs = {
  limit?: InputMaybe<Scalars['Int']>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryStargazersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_StarOrder>;
};


/** A repository contains the content for a project. */
export type Github_RepositorySubmodulesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryVulnerabilityAlertsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A repository contains the content for a project. */
export type Github_RepositoryWatchersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The affiliation of a user to a repository */
export enum Github_RepositoryAffiliation {
  /** Repositories that the user has been added to as a collaborator. */
  Collaborator = 'COLLABORATOR',
  /**
   * Repositories that the user has access to through being a member of an
   * organization. This includes every repository on every team that the user is on.
   */
  OrganizationMember = 'ORGANIZATION_MEMBER',
  /** Repositories that are owned by the authenticated user. */
  Owner = 'OWNER'
}

/** Metadata for an audit entry with action repo.* */
export type Github_RepositoryAuditEntryData = {
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
};

/** Github_RepositoryAuditEntryData mock concrete type. */
export type Github_RepositoryAuditEntryData__Mock = Github_RepositoryAuditEntryData & {
  __typename?: 'Github_RepositoryAuditEntryData__Mock';
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
};

/** The connection type for User. */
export type Github_RepositoryCollaboratorConnection = {
  __typename?: 'Github_RepositoryCollaboratorConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_RepositoryCollaboratorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Represents a user who is a collaborator of a repository. */
export type Github_RepositoryCollaboratorEdge = {
  __typename?: 'Github_RepositoryCollaboratorEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  node: Github_User;
  /** The permission the user has on the repository. */
  permission: Github_RepositoryPermission;
  /** A list of sources for the user's access to the repository. */
  permissionSources?: Maybe<Array<Github_PermissionSource>>;
};

/** A list of repositories owned by the subject. */
export type Github_RepositoryConnection = {
  __typename?: 'Github_RepositoryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_RepositoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Repository>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
  /** The total size in kilobytes of all repositories in the connection. */
  totalDiskUsage: Scalars['Int'];
};

/** A repository contact link. */
export type Github_RepositoryContactLink = {
  __typename?: 'Github_RepositoryContactLink';
  /** The contact link purpose. */
  about: Scalars['String'];
  /** The contact link name. */
  name: Scalars['String'];
  /** The contact link URL. */
  url: Scalars['Github_URI'];
};

/** The reason a repository is listed as 'contributed'. */
export enum Github_RepositoryContributionType {
  /** Created a commit */
  Commit = 'COMMIT',
  /** Created an issue */
  Issue = 'ISSUE',
  /** Created a pull request */
  PullRequest = 'PULL_REQUEST',
  /** Reviewed a pull request */
  PullRequestReview = 'PULL_REQUEST_REVIEW',
  /** Created the repository */
  Repository = 'REPOSITORY'
}

/** Represents an author of discussions in repositories. */
export type Github_RepositoryDiscussionAuthor = {
  /** Discussions this user has started. */
  repositoryDiscussions: Github_DiscussionConnection;
};


/** Represents an author of discussions in repositories. */
export type Github_RepositoryDiscussionAuthorRepositoryDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  answered?: InputMaybe<Scalars['Boolean']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_DiscussionOrder>;
  repositoryId?: InputMaybe<Scalars['ID']>;
};

/** Github_RepositoryDiscussionAuthor mock concrete type. */
export type Github_RepositoryDiscussionAuthor__Mock = Github_RepositoryDiscussionAuthor & {
  __typename?: 'Github_RepositoryDiscussionAuthor__Mock';
  /** Discussions this user has started. */
  repositoryDiscussions: Github_DiscussionConnection;
};


/** Github_RepositoryDiscussionAuthor mock concrete type. */
export type Github_RepositoryDiscussionAuthor__MockRepositoryDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  answered?: InputMaybe<Scalars['Boolean']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_DiscussionOrder>;
  repositoryId?: InputMaybe<Scalars['ID']>;
};

/** Represents an author of discussion comments in repositories. */
export type Github_RepositoryDiscussionCommentAuthor = {
  /** Discussion comments this user has authored. */
  repositoryDiscussionComments: Github_DiscussionCommentConnection;
};


/** Represents an author of discussion comments in repositories. */
export type Github_RepositoryDiscussionCommentAuthorRepositoryDiscussionCommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  onlyAnswers?: InputMaybe<Scalars['Boolean']>;
  repositoryId?: InputMaybe<Scalars['ID']>;
};

/** Github_RepositoryDiscussionCommentAuthor mock concrete type. */
export type Github_RepositoryDiscussionCommentAuthor__Mock = Github_RepositoryDiscussionCommentAuthor & {
  __typename?: 'Github_RepositoryDiscussionCommentAuthor__Mock';
  /** Discussion comments this user has authored. */
  repositoryDiscussionComments: Github_DiscussionCommentConnection;
};


/** Github_RepositoryDiscussionCommentAuthor mock concrete type. */
export type Github_RepositoryDiscussionCommentAuthor__MockRepositoryDiscussionCommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  onlyAnswers?: InputMaybe<Scalars['Boolean']>;
  repositoryId?: InputMaybe<Scalars['ID']>;
};

/** An edge in a connection. */
export type Github_RepositoryEdge = {
  __typename?: 'Github_RepositoryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Repository>;
};

/** A subset of repository info. */
export type Github_RepositoryInfo = {
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The description of the repository. */
  description?: Maybe<Scalars['String']>;
  /** The description of the repository rendered to HTML. */
  descriptionHTML: Scalars['Github_HTML'];
  /** Returns how many forks there are of this repository in the whole network. */
  forkCount: Scalars['Int'];
  /** Indicates if the repository has issues feature enabled. */
  hasIssuesEnabled: Scalars['Boolean'];
  /** Indicates if the repository has the Projects feature enabled. */
  hasProjectsEnabled: Scalars['Boolean'];
  /** Indicates if the repository has wiki feature enabled. */
  hasWikiEnabled: Scalars['Boolean'];
  /** The repository's URL. */
  homepageUrl?: Maybe<Scalars['Github_URI']>;
  /** Indicates if the repository is unmaintained. */
  isArchived: Scalars['Boolean'];
  /** Identifies if the repository is a fork. */
  isFork: Scalars['Boolean'];
  /** Indicates if a repository is either owned by an organization, or is a private fork of an organization repository. */
  isInOrganization: Scalars['Boolean'];
  /** Indicates if the repository has been locked or not. */
  isLocked: Scalars['Boolean'];
  /** Identifies if the repository is a mirror. */
  isMirror: Scalars['Boolean'];
  /** Identifies if the repository is private or internal. */
  isPrivate: Scalars['Boolean'];
  /** Identifies if the repository is a template that can be used to generate new repositories. */
  isTemplate: Scalars['Boolean'];
  /** The license associated with the repository */
  licenseInfo?: Maybe<Github_License>;
  /** The reason the repository has been locked. */
  lockReason?: Maybe<Github_RepositoryLockReason>;
  /** The repository's original mirror URL. */
  mirrorUrl?: Maybe<Scalars['Github_URI']>;
  /** The name of the repository. */
  name: Scalars['String'];
  /** The repository's name with owner. */
  nameWithOwner: Scalars['String'];
  /** The image used to represent this repository in Open Graph data. */
  openGraphImageUrl: Scalars['Github_URI'];
  /** The User owner of the repository. */
  owner: Github_RepositoryOwner;
  /** Identifies when the repository was last pushed to. */
  pushedAt?: Maybe<Scalars['DateTime']>;
  /** The HTTP path for this repository */
  resourcePath: Scalars['Github_URI'];
  /** A description of the repository, rendered to HTML without any links in it. */
  shortDescriptionHTML: Scalars['Github_HTML'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this repository */
  url: Scalars['Github_URI'];
  /** Whether this repository has a custom image to use with Open Graph as opposed to being represented by the owner's avatar. */
  usesCustomOpenGraphImage: Scalars['Boolean'];
  /** Indicates the repository's visibility level. */
  visibility: Github_RepositoryVisibility;
};


/** A subset of repository info. */
export type Github_RepositoryInfoShortDescriptionHtmlArgs = {
  limit?: InputMaybe<Scalars['Int']>;
};

/** Github_RepositoryInfo mock concrete type. */
export type Github_RepositoryInfo__Mock = Github_RepositoryInfo & {
  __typename?: 'Github_RepositoryInfo__Mock';
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The description of the repository. */
  description?: Maybe<Scalars['String']>;
  /** The description of the repository rendered to HTML. */
  descriptionHTML: Scalars['Github_HTML'];
  /** Returns how many forks there are of this repository in the whole network. */
  forkCount: Scalars['Int'];
  /** Indicates if the repository has issues feature enabled. */
  hasIssuesEnabled: Scalars['Boolean'];
  /** Indicates if the repository has the Projects feature enabled. */
  hasProjectsEnabled: Scalars['Boolean'];
  /** Indicates if the repository has wiki feature enabled. */
  hasWikiEnabled: Scalars['Boolean'];
  /** The repository's URL. */
  homepageUrl?: Maybe<Scalars['Github_URI']>;
  /** Indicates if the repository is unmaintained. */
  isArchived: Scalars['Boolean'];
  /** Identifies if the repository is a fork. */
  isFork: Scalars['Boolean'];
  /** Indicates if a repository is either owned by an organization, or is a private fork of an organization repository. */
  isInOrganization: Scalars['Boolean'];
  /** Indicates if the repository has been locked or not. */
  isLocked: Scalars['Boolean'];
  /** Identifies if the repository is a mirror. */
  isMirror: Scalars['Boolean'];
  /** Identifies if the repository is private or internal. */
  isPrivate: Scalars['Boolean'];
  /** Identifies if the repository is a template that can be used to generate new repositories. */
  isTemplate: Scalars['Boolean'];
  /** The license associated with the repository */
  licenseInfo?: Maybe<Github_License>;
  /** The reason the repository has been locked. */
  lockReason?: Maybe<Github_RepositoryLockReason>;
  /** The repository's original mirror URL. */
  mirrorUrl?: Maybe<Scalars['Github_URI']>;
  /** The name of the repository. */
  name: Scalars['String'];
  /** The repository's name with owner. */
  nameWithOwner: Scalars['String'];
  /** The image used to represent this repository in Open Graph data. */
  openGraphImageUrl: Scalars['Github_URI'];
  /** The User owner of the repository. */
  owner: Github_RepositoryOwner;
  /** Identifies when the repository was last pushed to. */
  pushedAt?: Maybe<Scalars['DateTime']>;
  /** The HTTP path for this repository */
  resourcePath: Scalars['Github_URI'];
  /** A description of the repository, rendered to HTML without any links in it. */
  shortDescriptionHTML: Scalars['Github_HTML'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this repository */
  url: Scalars['Github_URI'];
  /** Whether this repository has a custom image to use with Open Graph as opposed to being represented by the owner's avatar. */
  usesCustomOpenGraphImage: Scalars['Boolean'];
  /** Indicates the repository's visibility level. */
  visibility: Github_RepositoryVisibility;
};


/** Github_RepositoryInfo mock concrete type. */
export type Github_RepositoryInfo__MockShortDescriptionHtmlArgs = {
  limit?: InputMaybe<Scalars['Int']>;
};

/** Repository interaction limit that applies to this object. */
export type Github_RepositoryInteractionAbility = {
  __typename?: 'Github_RepositoryInteractionAbility';
  /** The time the currently active limit expires. */
  expiresAt?: Maybe<Scalars['DateTime']>;
  /** The current limit that is enabled on this object. */
  limit: Github_RepositoryInteractionLimit;
  /** The origin of the currently active interaction limit. */
  origin: Github_RepositoryInteractionLimitOrigin;
};

/** A repository interaction limit. */
export enum Github_RepositoryInteractionLimit {
  /** Users that are not collaborators will not be able to interact with the repository. */
  CollaboratorsOnly = 'COLLABORATORS_ONLY',
  /** Users that have not previously committed to a repositorys default branch will be unable to interact with the repository. */
  ContributorsOnly = 'CONTRIBUTORS_ONLY',
  /** Users that have recently created their account will be unable to interact with the repository. */
  ExistingUsers = 'EXISTING_USERS',
  /** No interaction limits are enabled. */
  NoLimit = 'NO_LIMIT'
}

/** The length for a repository interaction limit to be enabled for. */
export enum Github_RepositoryInteractionLimitExpiry {
  /** The interaction limit will expire after 1 day. */
  OneDay = 'ONE_DAY',
  /** The interaction limit will expire after 1 month. */
  OneMonth = 'ONE_MONTH',
  /** The interaction limit will expire after 1 week. */
  OneWeek = 'ONE_WEEK',
  /** The interaction limit will expire after 6 months. */
  SixMonths = 'SIX_MONTHS',
  /** The interaction limit will expire after 3 days. */
  ThreeDays = 'THREE_DAYS'
}

/** Indicates where an interaction limit is configured. */
export enum Github_RepositoryInteractionLimitOrigin {
  /** A limit that is configured at the organization level. */
  Organization = 'ORGANIZATION',
  /** A limit that is configured at the repository level. */
  Repository = 'REPOSITORY',
  /** A limit that is configured at the user-wide level. */
  User = 'USER'
}

/** An invitation for a user to be added to a repository. */
export type Github_RepositoryInvitation = Github_Node & {
  __typename?: 'Github_RepositoryInvitation';
  /** The email address that received the invitation. */
  email?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** The user who received the invitation. */
  invitee?: Maybe<Github_User>;
  /** The user who created the invitation. */
  inviter: Github_User;
  /** The permalink for this repository invitation. */
  permalink: Scalars['Github_URI'];
  /** The permission granted on this repository by this invitation. */
  permission: Github_RepositoryPermission;
  /** The Repository the user is invited to. */
  repository?: Maybe<Github_RepositoryInfo>;
};

/** The connection type for RepositoryInvitation. */
export type Github_RepositoryInvitationConnection = {
  __typename?: 'Github_RepositoryInvitationConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_RepositoryInvitationEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_RepositoryInvitation>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_RepositoryInvitationEdge = {
  __typename?: 'Github_RepositoryInvitationEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_RepositoryInvitation>;
};

/** Ordering options for repository invitation connections. */
export type Github_RepositoryInvitationOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order repository invitations by. */
  field: Github_RepositoryInvitationOrderField;
};

/** Properties by which repository invitation connections can be ordered. */
export enum Github_RepositoryInvitationOrderField {
  /** Order repository invitations by creation time */
  CreatedAt = 'CREATED_AT',
  /**
   * Order repository invitations by invitee login
   * @deprecated `INVITEE_LOGIN` is no longer a valid field value. Repository invitations can now be associated with an email, not only an invitee. Removal on 2020-10-01 UTC.
   */
  InviteeLogin = 'INVITEE_LOGIN'
}

/** The possible reasons a given repository could be in a locked state. */
export enum Github_RepositoryLockReason {
  /** The repository is locked due to a billing related reason. */
  Billing = 'BILLING',
  /** The repository is locked due to a migration. */
  Migrating = 'MIGRATING',
  /** The repository is locked due to a move. */
  Moving = 'MOVING',
  /** The repository is locked due to a rename. */
  Rename = 'RENAME'
}

/** Represents a object that belongs to a repository. */
export type Github_RepositoryNode = {
  /** The repository associated with this node. */
  repository: Github_Repository;
};

/** Github_RepositoryNode mock concrete type. */
export type Github_RepositoryNode__Mock = Github_RepositoryNode & {
  __typename?: 'Github_RepositoryNode__Mock';
  /** The repository associated with this node. */
  repository: Github_Repository;
};

/** Ordering options for repository connections */
export type Github_RepositoryOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order repositories by. */
  field: Github_RepositoryOrderField;
};

/** Properties by which repository connections can be ordered. */
export enum Github_RepositoryOrderField {
  /** Order repositories by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order repositories by name */
  Name = 'NAME',
  /** Order repositories by push time */
  PushedAt = 'PUSHED_AT',
  /** Order repositories by number of stargazers */
  Stargazers = 'STARGAZERS',
  /** Order repositories by update time */
  UpdatedAt = 'UPDATED_AT'
}

/** Represents an owner of a Repository. */
export type Github_RepositoryOwner = {
  /** A URL pointing to the owner's public avatar. */
  avatarUrl: Scalars['Github_URI'];
  id: Scalars['ID'];
  /** The username used to login. */
  login: Scalars['String'];
  /** A list of repositories that the user owns. */
  repositories: Github_RepositoryConnection;
  /** Find Repository. */
  repository?: Maybe<Github_Repository>;
  /** The HTTP URL for the owner. */
  resourcePath: Scalars['Github_URI'];
  /** The HTTP URL for the owner. */
  url: Scalars['Github_URI'];
};


/** Represents an owner of a Repository. */
export type Github_RepositoryOwnerAvatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']>;
};


/** Represents an owner of a Repository. */
export type Github_RepositoryOwnerRepositoriesArgs = {
  affiliations?: InputMaybe<Array<InputMaybe<Github_RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  isFork?: InputMaybe<Scalars['Boolean']>;
  isLocked?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_RepositoryOrder>;
  ownerAffiliations?: InputMaybe<Array<InputMaybe<Github_RepositoryAffiliation>>>;
  privacy?: InputMaybe<Github_RepositoryPrivacy>;
};


/** Represents an owner of a Repository. */
export type Github_RepositoryOwnerRepositoryArgs = {
  followRenames?: InputMaybe<Scalars['Boolean']>;
  name: Scalars['String'];
};

/** Github_RepositoryOwner mock concrete type. */
export type Github_RepositoryOwner__Mock = Github_RepositoryOwner & {
  __typename?: 'Github_RepositoryOwner__Mock';
  /** A URL pointing to the owner's public avatar. */
  avatarUrl: Scalars['Github_URI'];
  id: Scalars['ID'];
  /** The username used to login. */
  login: Scalars['String'];
  /** A list of repositories that the user owns. */
  repositories: Github_RepositoryConnection;
  /** Find Repository. */
  repository?: Maybe<Github_Repository>;
  /** The HTTP URL for the owner. */
  resourcePath: Scalars['Github_URI'];
  /** The HTTP URL for the owner. */
  url: Scalars['Github_URI'];
};


/** Github_RepositoryOwner mock concrete type. */
export type Github_RepositoryOwner__MockAvatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']>;
};


/** Github_RepositoryOwner mock concrete type. */
export type Github_RepositoryOwner__MockRepositoriesArgs = {
  affiliations?: InputMaybe<Array<InputMaybe<Github_RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  isFork?: InputMaybe<Scalars['Boolean']>;
  isLocked?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_RepositoryOrder>;
  ownerAffiliations?: InputMaybe<Array<InputMaybe<Github_RepositoryAffiliation>>>;
  privacy?: InputMaybe<Github_RepositoryPrivacy>;
};


/** Github_RepositoryOwner mock concrete type. */
export type Github_RepositoryOwner__MockRepositoryArgs = {
  followRenames?: InputMaybe<Scalars['Boolean']>;
  name: Scalars['String'];
};

/** The access level to a repository */
export enum Github_RepositoryPermission {
  /**
   * Can read, clone, and push to this repository. Can also manage issues, pull
   * requests, and repository settings, including adding collaborators
   */
  Admin = 'ADMIN',
  /** Can read, clone, and push to this repository. They can also manage issues, pull requests, and some repository settings */
  Maintain = 'MAINTAIN',
  /** Can read and clone this repository. Can also open and comment on issues and pull requests */
  Read = 'READ',
  /** Can read and clone this repository. Can also manage issues and pull requests */
  Triage = 'TRIAGE',
  /** Can read, clone, and push to this repository. Can also manage issues and pull requests */
  Write = 'WRITE'
}

/** The privacy of a repository */
export enum Github_RepositoryPrivacy {
  /** Private */
  Private = 'PRIVATE',
  /** Public */
  Public = 'PUBLIC'
}

/** A repository-topic connects a repository to a topic. */
export type Github_RepositoryTopic = Github_Node & Github_UniformResourceLocatable & {
  __typename?: 'Github_RepositoryTopic';
  id: Scalars['ID'];
  /** The HTTP path for this repository-topic. */
  resourcePath: Scalars['Github_URI'];
  /** The topic. */
  topic: Github_Topic;
  /** The HTTP URL for this repository-topic. */
  url: Scalars['Github_URI'];
};

/** The connection type for RepositoryTopic. */
export type Github_RepositoryTopicConnection = {
  __typename?: 'Github_RepositoryTopicConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_RepositoryTopicEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_RepositoryTopic>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_RepositoryTopicEdge = {
  __typename?: 'Github_RepositoryTopicEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_RepositoryTopic>;
};

/** The repository's visibility level. */
export enum Github_RepositoryVisibility {
  /** The repository is visible only to users in the same business. */
  Internal = 'INTERNAL',
  /** The repository is visible only to those with explicit access. */
  Private = 'PRIVATE',
  /** The repository is visible to everyone. */
  Public = 'PUBLIC'
}

/** Audit log entry for a repository_visibility_change.disable event. */
export type Github_RepositoryVisibilityChangeDisableAuditEntry = Github_AuditEntry & Github_EnterpriseAuditEntryData & Github_Node & Github_OrganizationAuditEntryData & {
  __typename?: 'Github_RepositoryVisibilityChangeDisableAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['Github_URI']>;
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a repository_visibility_change.enable event. */
export type Github_RepositoryVisibilityChangeEnableAuditEntry = Github_AuditEntry & Github_EnterpriseAuditEntryData & Github_Node & Github_OrganizationAuditEntryData & {
  __typename?: 'Github_RepositoryVisibilityChangeEnableAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  /** The HTTP path for this enterprise. */
  enterpriseResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The slug of the enterprise. */
  enterpriseSlug?: Maybe<Scalars['String']>;
  /** The HTTP URL for this enterprise. */
  enterpriseUrl?: Maybe<Scalars['Github_URI']>;
  id: Scalars['ID'];
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** A Dependabot alert for a repository with a dependency affected by a security vulnerability. */
export type Github_RepositoryVulnerabilityAlert = Github_Node & Github_RepositoryNode & {
  __typename?: 'Github_RepositoryVulnerabilityAlert';
  /** When was the alert created? */
  createdAt: Scalars['DateTime'];
  /** The reason the alert was dismissed */
  dismissReason?: Maybe<Scalars['String']>;
  /** When was the alert dismissed? */
  dismissedAt?: Maybe<Scalars['DateTime']>;
  /** The user who dismissed the alert */
  dismisser?: Maybe<Github_User>;
  id: Scalars['ID'];
  /** The associated repository */
  repository: Github_Repository;
  /** The associated security advisory */
  securityAdvisory?: Maybe<Github_SecurityAdvisory>;
  /** The associated security vulnerability */
  securityVulnerability?: Maybe<Github_SecurityVulnerability>;
  /** The vulnerable manifest filename */
  vulnerableManifestFilename: Scalars['String'];
  /** The vulnerable manifest path */
  vulnerableManifestPath: Scalars['String'];
  /** The vulnerable requirements */
  vulnerableRequirements?: Maybe<Scalars['String']>;
};

/** The connection type for RepositoryVulnerabilityAlert. */
export type Github_RepositoryVulnerabilityAlertConnection = {
  __typename?: 'Github_RepositoryVulnerabilityAlertConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_RepositoryVulnerabilityAlertEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_RepositoryVulnerabilityAlert>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_RepositoryVulnerabilityAlertEdge = {
  __typename?: 'Github_RepositoryVulnerabilityAlertEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_RepositoryVulnerabilityAlert>;
};

/** Autogenerated input type of RequestReviews */
export type Github_RequestReviewsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the pull request to modify. */
  pullRequestId: Scalars['ID'];
  /** The Node IDs of the team to request. */
  teamIds?: InputMaybe<Array<Scalars['ID']>>;
  /** Add users to the set rather than replace. */
  union?: InputMaybe<Scalars['Boolean']>;
  /** The Node IDs of the user to request. */
  userIds?: InputMaybe<Array<Scalars['ID']>>;
};

/** Autogenerated return type of RequestReviews */
export type Github_RequestReviewsPayload = {
  __typename?: 'Github_RequestReviewsPayload';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The pull request that is getting requests. */
  pullRequest?: Maybe<Github_PullRequest>;
  /** The edge from the pull request to the requested reviewers. */
  requestedReviewersEdge?: Maybe<Github_UserEdge>;
};

/** The possible states that can be requested when creating a check run. */
export enum Github_RequestableCheckStatusState {
  /** The check suite or run has been completed. */
  Completed = 'COMPLETED',
  /** The check suite or run is in progress. */
  InProgress = 'IN_PROGRESS',
  /** The check suite or run is in pending state. */
  Pending = 'PENDING',
  /** The check suite or run has been queued. */
  Queued = 'QUEUED',
  /** The check suite or run is in waiting state. */
  Waiting = 'WAITING'
}

/** Types that can be requested reviewers. */
export type Github_RequestedReviewer = Github_Mannequin | Github_Team | Github_User;

/** Represents a type that can be required by a pull request for merging. */
export type Github_RequirableByPullRequest = {
  /** Whether this is required to pass before merging for a specific pull request. */
  isRequired: Scalars['Boolean'];
};


/** Represents a type that can be required by a pull request for merging. */
export type Github_RequirableByPullRequestIsRequiredArgs = {
  pullRequestId?: InputMaybe<Scalars['ID']>;
  pullRequestNumber?: InputMaybe<Scalars['Int']>;
};

/** Github_RequirableByPullRequest mock concrete type. */
export type Github_RequirableByPullRequest__Mock = Github_RequirableByPullRequest & {
  __typename?: 'Github_RequirableByPullRequest__Mock';
  /** Whether this is required to pass before merging for a specific pull request. */
  isRequired: Scalars['Boolean'];
};


/** Github_RequirableByPullRequest mock concrete type. */
export type Github_RequirableByPullRequest__MockIsRequiredArgs = {
  pullRequestId?: InputMaybe<Scalars['ID']>;
  pullRequestNumber?: InputMaybe<Scalars['Int']>;
};

/** Represents a required status check for a protected branch, but not any specific run of that check. */
export type Github_RequiredStatusCheckDescription = {
  __typename?: 'Github_RequiredStatusCheckDescription';
  /** The App that must provide this status in order for it to be accepted. */
  app?: Maybe<Github_App>;
  /** The name of this status. */
  context: Scalars['String'];
};

/** Specifies the attributes for a new or updated required status check. */
export type Github_RequiredStatusCheckInput = {
  /**
   * The ID of the App that must set the status in order for it to be accepted.
   * Omit this value to use whichever app has recently been setting this status, or
   * use "any" to allow any app to set the status.
   */
  appId?: InputMaybe<Scalars['ID']>;
  /** Status check context that must pass for commits to be accepted to the matching branch. */
  context: Scalars['String'];
};

/** Autogenerated input type of RerequestCheckSuite */
export type Github_RerequestCheckSuiteInput = {
  /** The Node ID of the check suite. */
  checkSuiteId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of RerequestCheckSuite */
export type Github_RerequestCheckSuitePayload = {
  __typename?: 'Github_RerequestCheckSuitePayload';
  /** The requested check suite. */
  checkSuite?: Maybe<Github_CheckSuite>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of ResolveReviewThread */
export type Github_ResolveReviewThreadInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the thread to resolve */
  threadId: Scalars['ID'];
};

/** Autogenerated return type of ResolveReviewThread */
export type Github_ResolveReviewThreadPayload = {
  __typename?: 'Github_ResolveReviewThreadPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The thread to resolve. */
  thread?: Maybe<Github_PullRequestReviewThread>;
};

/** Represents a private contribution a user made on GitHub. */
export type Github_RestrictedContribution = Github_Contribution & {
  __typename?: 'Github_RestrictedContribution';
  /**
   * Whether this contribution is associated with a record you do not have access to. For
   * example, your own 'first issue' contribution may have been made on a repository you can no
   * longer access.
   */
  isRestricted: Scalars['Boolean'];
  /** When this contribution was made. */
  occurredAt: Scalars['DateTime'];
  /** The HTTP path for this contribution. */
  resourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this contribution. */
  url: Scalars['Github_URI'];
  /** The user who made this contribution. */
  user: Github_User;
};

/** A team or user who has the ability to dismiss a review on a protected branch. */
export type Github_ReviewDismissalAllowance = Github_Node & {
  __typename?: 'Github_ReviewDismissalAllowance';
  /** The actor that can dismiss. */
  actor?: Maybe<Github_ReviewDismissalAllowanceActor>;
  /** Identifies the branch protection rule associated with the allowed user or team. */
  branchProtectionRule?: Maybe<Github_BranchProtectionRule>;
  id: Scalars['ID'];
};

/** Types that can be an actor. */
export type Github_ReviewDismissalAllowanceActor = Github_Team | Github_User;

/** The connection type for ReviewDismissalAllowance. */
export type Github_ReviewDismissalAllowanceConnection = {
  __typename?: 'Github_ReviewDismissalAllowanceConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_ReviewDismissalAllowanceEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_ReviewDismissalAllowance>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_ReviewDismissalAllowanceEdge = {
  __typename?: 'Github_ReviewDismissalAllowanceEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_ReviewDismissalAllowance>;
};

/** Represents a 'review_dismissed' event on a given issue or pull request. */
export type Github_ReviewDismissedEvent = Github_Node & Github_UniformResourceLocatable & {
  __typename?: 'Github_ReviewDismissedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** Identifies the optional message associated with the 'review_dismissed' event. */
  dismissalMessage?: Maybe<Scalars['String']>;
  /** Identifies the optional message associated with the event, rendered to HTML. */
  dismissalMessageHTML?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** Identifies the previous state of the review with the 'review_dismissed' event. */
  previousReviewState: Github_PullRequestReviewState;
  /** PullRequest referenced by event. */
  pullRequest: Github_PullRequest;
  /** Identifies the commit which caused the review to become stale. */
  pullRequestCommit?: Maybe<Github_PullRequestCommit>;
  /** The HTTP path for this review dismissed event. */
  resourcePath: Scalars['Github_URI'];
  /** Identifies the review associated with the 'review_dismissed' event. */
  review?: Maybe<Github_PullRequestReview>;
  /** The HTTP URL for this review dismissed event. */
  url: Scalars['Github_URI'];
};

/** A request for a user to review a pull request. */
export type Github_ReviewRequest = Github_Node & {
  __typename?: 'Github_ReviewRequest';
  /** Whether this request was created for a code owner */
  asCodeOwner: Scalars['Boolean'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** Identifies the pull request associated with this review request. */
  pullRequest: Github_PullRequest;
  /** The reviewer that is requested. */
  requestedReviewer?: Maybe<Github_RequestedReviewer>;
};

/** The connection type for ReviewRequest. */
export type Github_ReviewRequestConnection = {
  __typename?: 'Github_ReviewRequestConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_ReviewRequestEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_ReviewRequest>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_ReviewRequestEdge = {
  __typename?: 'Github_ReviewRequestEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_ReviewRequest>;
};

/** Represents an 'review_request_removed' event on a given pull request. */
export type Github_ReviewRequestRemovedEvent = Github_Node & {
  __typename?: 'Github_ReviewRequestRemovedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest: Github_PullRequest;
  /** Identifies the reviewer whose review request was removed. */
  requestedReviewer?: Maybe<Github_RequestedReviewer>;
};

/** Represents an 'review_requested' event on a given pull request. */
export type Github_ReviewRequestedEvent = Github_Node & {
  __typename?: 'Github_ReviewRequestedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** PullRequest referenced by event. */
  pullRequest: Github_PullRequest;
  /** Identifies the reviewer whose review was requested. */
  requestedReviewer?: Maybe<Github_RequestedReviewer>;
};

/**
 * A hovercard context with a message describing the current code review state of the pull
 * request.
 */
export type Github_ReviewStatusHovercardContext = Github_HovercardContext & {
  __typename?: 'Github_ReviewStatusHovercardContext';
  /** A string describing this context */
  message: Scalars['String'];
  /** An octicon to accompany this context */
  octicon: Scalars['String'];
  /** The current status of the pull request with respect to code review. */
  reviewDecision?: Maybe<Github_PullRequestReviewDecision>;
};

/** Possible roles a user may have in relation to an organization. */
export enum Github_RoleInOrganization {
  /** A user who is a direct member of the organization. */
  DirectMember = 'DIRECT_MEMBER',
  /** A user with full administrative access to the organization. */
  Owner = 'OWNER',
  /** A user who is unaffiliated with the organization. */
  Unaffiliated = 'UNAFFILIATED'
}

/** The possible digest algorithms used to sign SAML requests for an identity provider. */
export enum Github_SamlDigestAlgorithm {
  /** SHA1 */
  Sha1 = 'SHA1',
  /** SHA256 */
  Sha256 = 'SHA256',
  /** SHA384 */
  Sha384 = 'SHA384',
  /** SHA512 */
  Sha512 = 'SHA512'
}

/** The possible signature algorithms used to sign SAML requests for a Identity Provider. */
export enum Github_SamlSignatureAlgorithm {
  /** RSA-SHA1 */
  RsaSha1 = 'RSA_SHA1',
  /** RSA-SHA256 */
  RsaSha256 = 'RSA_SHA256',
  /** RSA-SHA384 */
  RsaSha384 = 'RSA_SHA384',
  /** RSA-SHA512 */
  RsaSha512 = 'RSA_SHA512'
}

/** A Saved Reply is text a user can use to reply quickly. */
export type Github_SavedReply = Github_Node & {
  __typename?: 'Github_SavedReply';
  /** The body of the saved reply. */
  body: Scalars['String'];
  /** The saved reply body rendered to HTML. */
  bodyHTML: Scalars['Github_HTML'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** The title of the saved reply. */
  title: Scalars['String'];
  /** The user that saved this reply. */
  user?: Maybe<Github_Actor>;
};

/** The connection type for SavedReply. */
export type Github_SavedReplyConnection = {
  __typename?: 'Github_SavedReplyConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_SavedReplyEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_SavedReply>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_SavedReplyEdge = {
  __typename?: 'Github_SavedReplyEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_SavedReply>;
};

/** Ordering options for saved reply connections. */
export type Github_SavedReplyOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order saved replies by. */
  field: Github_SavedReplyOrderField;
};

/** Properties by which saved reply connections can be ordered. */
export enum Github_SavedReplyOrderField {
  /** Order saved reply by when they were updated. */
  UpdatedAt = 'UPDATED_AT'
}

/** The results of a search. */
export type Github_SearchResultItem = Github_App | Github_Discussion | Github_Issue | Github_MarketplaceListing | Github_Organization | Github_PullRequest | Github_Repository | Github_User;

/** A list of results that matched against a search query. */
export type Github_SearchResultItemConnection = {
  __typename?: 'Github_SearchResultItemConnection';
  /** The number of pieces of code that matched the search query. */
  codeCount: Scalars['Int'];
  /** The number of discussions that matched the search query. */
  discussionCount: Scalars['Int'];
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_SearchResultItemEdge>>>;
  /** The number of issues that matched the search query. */
  issueCount: Scalars['Int'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_SearchResultItem>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The number of repositories that matched the search query. */
  repositoryCount: Scalars['Int'];
  /** The number of users that matched the search query. */
  userCount: Scalars['Int'];
  /** The number of wiki pages that matched the search query. */
  wikiCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_SearchResultItemEdge = {
  __typename?: 'Github_SearchResultItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_SearchResultItem>;
  /** Text matches on the result found. */
  textMatches?: Maybe<Array<Maybe<Github_TextMatch>>>;
};

/** Represents the individual results of a search. */
export enum Github_SearchType {
  /** Returns matching discussions in repositories. */
  Discussion = 'DISCUSSION',
  /** Returns results matching issues in repositories. */
  Issue = 'ISSUE',
  /** Returns results matching repositories. */
  Repository = 'REPOSITORY',
  /** Returns results matching users and organizations on GitHub. */
  User = 'USER'
}

/** A GitHub Security Advisory */
export type Github_SecurityAdvisory = Github_Node & {
  __typename?: 'Github_SecurityAdvisory';
  /** The CVSS associated with this advisory */
  cvss: Github_Cvss;
  /** CWEs associated with this Advisory */
  cwes: Github_CweConnection;
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** This is a long plaintext description of the advisory */
  description: Scalars['String'];
  /** The GitHub Security Advisory ID */
  ghsaId: Scalars['String'];
  id: Scalars['ID'];
  /** A list of identifiers for this advisory */
  identifiers: Array<Github_SecurityAdvisoryIdentifier>;
  /** The permalink for the advisory's dependabot alerts page */
  notificationsPermalink?: Maybe<Scalars['Github_URI']>;
  /** The organization that originated the advisory */
  origin: Scalars['String'];
  /** The permalink for the advisory */
  permalink?: Maybe<Scalars['Github_URI']>;
  /** When the advisory was published */
  publishedAt: Scalars['DateTime'];
  /** A list of references for this advisory */
  references: Array<Github_SecurityAdvisoryReference>;
  /** The severity of the advisory */
  severity: Github_SecurityAdvisorySeverity;
  /** A short plaintext summary of the advisory */
  summary: Scalars['String'];
  /** When the advisory was last updated */
  updatedAt: Scalars['DateTime'];
  /** Vulnerabilities associated with this Advisory */
  vulnerabilities: Github_SecurityVulnerabilityConnection;
  /** When the advisory was withdrawn, if it has been withdrawn */
  withdrawnAt?: Maybe<Scalars['DateTime']>;
};


/** A GitHub Security Advisory */
export type Github_SecurityAdvisoryCwesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A GitHub Security Advisory */
export type Github_SecurityAdvisoryVulnerabilitiesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  ecosystem?: InputMaybe<Github_SecurityAdvisoryEcosystem>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SecurityVulnerabilityOrder>;
  package?: InputMaybe<Scalars['String']>;
  severities?: InputMaybe<Array<Github_SecurityAdvisorySeverity>>;
};

/** The connection type for SecurityAdvisory. */
export type Github_SecurityAdvisoryConnection = {
  __typename?: 'Github_SecurityAdvisoryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_SecurityAdvisoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_SecurityAdvisory>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** The possible ecosystems of a security vulnerability's package. */
export enum Github_SecurityAdvisoryEcosystem {
  /** PHP packages hosted at packagist.org */
  Composer = 'COMPOSER',
  /** Go modules */
  Go = 'GO',
  /** Java artifacts hosted at the Maven central repository */
  Maven = 'MAVEN',
  /** JavaScript packages hosted at npmjs.com */
  Npm = 'NPM',
  /** .NET packages hosted at the NuGet Gallery */
  Nuget = 'NUGET',
  /** Python packages hosted at PyPI.org */
  Pip = 'PIP',
  /** Ruby gems hosted at RubyGems.org */
  Rubygems = 'RUBYGEMS',
  /** Rust crates */
  Rust = 'RUST'
}

/** An edge in a connection. */
export type Github_SecurityAdvisoryEdge = {
  __typename?: 'Github_SecurityAdvisoryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_SecurityAdvisory>;
};

/** A GitHub Security Advisory Identifier */
export type Github_SecurityAdvisoryIdentifier = {
  __typename?: 'Github_SecurityAdvisoryIdentifier';
  /** The identifier type, e.g. GHSA, CVE */
  type: Scalars['String'];
  /** The identifier */
  value: Scalars['String'];
};

/** An advisory identifier to filter results on. */
export type Github_SecurityAdvisoryIdentifierFilter = {
  /** The identifier type. */
  type: Github_SecurityAdvisoryIdentifierType;
  /** The identifier string. Supports exact or partial matching. */
  value: Scalars['String'];
};

/** Identifier formats available for advisories. */
export enum Github_SecurityAdvisoryIdentifierType {
  /** Common Vulnerabilities and Exposures Identifier. */
  Cve = 'CVE',
  /** GitHub Security Advisory ID. */
  Ghsa = 'GHSA'
}

/** Ordering options for security advisory connections */
export type Github_SecurityAdvisoryOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order security advisories by. */
  field: Github_SecurityAdvisoryOrderField;
};

/** Properties by which security advisory connections can be ordered. */
export enum Github_SecurityAdvisoryOrderField {
  /** Order advisories by publication time */
  PublishedAt = 'PUBLISHED_AT',
  /** Order advisories by update time */
  UpdatedAt = 'UPDATED_AT'
}

/** An individual package */
export type Github_SecurityAdvisoryPackage = {
  __typename?: 'Github_SecurityAdvisoryPackage';
  /** The ecosystem the package belongs to, e.g. RUBYGEMS, NPM */
  ecosystem: Github_SecurityAdvisoryEcosystem;
  /** The package name */
  name: Scalars['String'];
};

/** An individual package version */
export type Github_SecurityAdvisoryPackageVersion = {
  __typename?: 'Github_SecurityAdvisoryPackageVersion';
  /** The package name or version */
  identifier: Scalars['String'];
};

/** A GitHub Security Advisory Reference */
export type Github_SecurityAdvisoryReference = {
  __typename?: 'Github_SecurityAdvisoryReference';
  /** A publicly accessible reference */
  url: Scalars['Github_URI'];
};

/** Severity of the vulnerability. */
export enum Github_SecurityAdvisorySeverity {
  /** Critical. */
  Critical = 'CRITICAL',
  /** High. */
  High = 'HIGH',
  /** Low. */
  Low = 'LOW',
  /** Moderate. */
  Moderate = 'MODERATE'
}

/** An individual vulnerability within an Advisory */
export type Github_SecurityVulnerability = {
  __typename?: 'Github_SecurityVulnerability';
  /** The Advisory associated with this Vulnerability */
  advisory: Github_SecurityAdvisory;
  /** The first version containing a fix for the vulnerability */
  firstPatchedVersion?: Maybe<Github_SecurityAdvisoryPackageVersion>;
  /** A description of the vulnerable package */
  package: Github_SecurityAdvisoryPackage;
  /** The severity of the vulnerability within this package */
  severity: Github_SecurityAdvisorySeverity;
  /** When the vulnerability was last updated */
  updatedAt: Scalars['DateTime'];
  /**
   * A string that describes the vulnerable package versions.
   * This string follows a basic syntax with a few forms.
   * + `= 0.2.0` denotes a single vulnerable version.
   * + `<= 1.0.8` denotes a version range up to and including the specified version
   * + `< 0.1.11` denotes a version range up to, but excluding, the specified version
   * + `>= 4.3.0, < 4.3.5` denotes a version range with a known minimum and maximum version.
   * + `>= 0.0.1` denotes a version range with a known minimum, but no known maximum
   */
  vulnerableVersionRange: Scalars['String'];
};

/** The connection type for SecurityVulnerability. */
export type Github_SecurityVulnerabilityConnection = {
  __typename?: 'Github_SecurityVulnerabilityConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_SecurityVulnerabilityEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_SecurityVulnerability>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_SecurityVulnerabilityEdge = {
  __typename?: 'Github_SecurityVulnerabilityEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_SecurityVulnerability>;
};

/** Ordering options for security vulnerability connections */
export type Github_SecurityVulnerabilityOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order security vulnerabilities by. */
  field: Github_SecurityVulnerabilityOrderField;
};

/** Properties by which security vulnerability connections can be ordered. */
export enum Github_SecurityVulnerabilityOrderField {
  /** Order vulnerability by update time */
  UpdatedAt = 'UPDATED_AT'
}

/** Autogenerated input type of SetEnterpriseIdentityProvider */
export type Github_SetEnterpriseIdentityProviderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The digest algorithm used to sign SAML requests for the identity provider. */
  digestMethod: Github_SamlDigestAlgorithm;
  /** The ID of the enterprise on which to set an identity provider. */
  enterpriseId: Scalars['ID'];
  /** The x509 certificate used by the identity provider to sign assertions and responses. */
  idpCertificate: Scalars['String'];
  /** The Issuer Entity ID for the SAML identity provider */
  issuer?: InputMaybe<Scalars['String']>;
  /** The signature algorithm used to sign SAML requests for the identity provider. */
  signatureMethod: Github_SamlSignatureAlgorithm;
  /** The URL endpoint for the identity provider's SAML SSO. */
  ssoUrl: Scalars['Github_URI'];
};

/** Autogenerated return type of SetEnterpriseIdentityProvider */
export type Github_SetEnterpriseIdentityProviderPayload = {
  __typename?: 'Github_SetEnterpriseIdentityProviderPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The identity provider for the enterprise. */
  identityProvider?: Maybe<Github_EnterpriseIdentityProvider>;
};

/** Autogenerated input type of SetOrganizationInteractionLimit */
export type Github_SetOrganizationInteractionLimitInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** When this limit should expire. */
  expiry?: InputMaybe<Github_RepositoryInteractionLimitExpiry>;
  /** The limit to set. */
  limit: Github_RepositoryInteractionLimit;
  /** The ID of the organization to set a limit for. */
  organizationId: Scalars['ID'];
};

/** Autogenerated return type of SetOrganizationInteractionLimit */
export type Github_SetOrganizationInteractionLimitPayload = {
  __typename?: 'Github_SetOrganizationInteractionLimitPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The organization that the interaction limit was set for. */
  organization?: Maybe<Github_Organization>;
};

/** Autogenerated input type of SetRepositoryInteractionLimit */
export type Github_SetRepositoryInteractionLimitInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** When this limit should expire. */
  expiry?: InputMaybe<Github_RepositoryInteractionLimitExpiry>;
  /** The limit to set. */
  limit: Github_RepositoryInteractionLimit;
  /** The ID of the repository to set a limit for. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of SetRepositoryInteractionLimit */
export type Github_SetRepositoryInteractionLimitPayload = {
  __typename?: 'Github_SetRepositoryInteractionLimitPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The repository that the interaction limit was set for. */
  repository?: Maybe<Github_Repository>;
};

/** Autogenerated input type of SetUserInteractionLimit */
export type Github_SetUserInteractionLimitInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** When this limit should expire. */
  expiry?: InputMaybe<Github_RepositoryInteractionLimitExpiry>;
  /** The limit to set. */
  limit: Github_RepositoryInteractionLimit;
  /** The ID of the user to set a limit for. */
  userId: Scalars['ID'];
};

/** Autogenerated return type of SetUserInteractionLimit */
export type Github_SetUserInteractionLimitPayload = {
  __typename?: 'Github_SetUserInteractionLimitPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The user that the interaction limit was set for. */
  user?: Maybe<Github_User>;
};

/** Represents an S/MIME signature on a Commit or Tag. */
export type Github_SmimeSignature = Github_GitSignature & {
  __typename?: 'Github_SmimeSignature';
  /** Email used to sign this object. */
  email: Scalars['String'];
  /** True if the signature is valid and verified by GitHub. */
  isValid: Scalars['Boolean'];
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  payload: Scalars['String'];
  /** ASCII-armored signature header from object. */
  signature: Scalars['String'];
  /** GitHub user corresponding to the email signing this commit. */
  signer?: Maybe<Github_User>;
  /**
   * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
   */
  state: Github_GitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  wasSignedByGitHub: Scalars['Boolean'];
};

/** Entities that can sponsor others via GitHub Sponsors */
export type Github_Sponsor = Github_Organization | Github_User;

/** The connection type for Sponsor. */
export type Github_SponsorConnection = {
  __typename?: 'Github_SponsorConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_SponsorEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Sponsor>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Represents a user or organization who is sponsoring someone in GitHub Sponsors. */
export type Github_SponsorEdge = {
  __typename?: 'Github_SponsorEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Sponsor>;
};

/** Ordering options for connections to get sponsor entities for GitHub Sponsors. */
export type Github_SponsorOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order sponsor entities by. */
  field: Github_SponsorOrderField;
};

/** Properties by which sponsor connections can be ordered. */
export enum Github_SponsorOrderField {
  /** Order sponsorable entities by login (username). */
  Login = 'LOGIN',
  /** Order sponsors by their relevance to the viewer. */
  Relevance = 'RELEVANCE'
}

/** Entities that can be sponsored through GitHub Sponsors */
export type Github_Sponsorable = {
  /** The estimated next GitHub Sponsors payout for this user/organization in cents (USD). */
  estimatedNextSponsorsPayoutInCents: Scalars['Int'];
  /** True if this user/organization has a GitHub Sponsors listing. */
  hasSponsorsListing: Scalars['Boolean'];
  /** Check if the given account is sponsoring this user/organization. */
  isSponsoredBy: Scalars['Boolean'];
  /** True if the viewer is sponsored by this user/organization. */
  isSponsoringViewer: Scalars['Boolean'];
  /** The estimated monthly GitHub Sponsors income for this user/organization in cents (USD). */
  monthlyEstimatedSponsorsIncomeInCents: Scalars['Int'];
  /** List of users and organizations this entity is sponsoring. */
  sponsoring: Github_SponsorConnection;
  /** List of sponsors for this user or organization. */
  sponsors: Github_SponsorConnection;
  /** Events involving this sponsorable, such as new sponsorships. */
  sponsorsActivities: Github_SponsorsActivityConnection;
  /** The GitHub Sponsors listing for this user or organization. */
  sponsorsListing?: Maybe<Github_SponsorsListing>;
  /**
   * The sponsorship from the viewer to this user/organization; that is, the
   * sponsorship where you're the sponsor. Only returns a sponsorship if it is active.
   */
  sponsorshipForViewerAsSponsor?: Maybe<Github_Sponsorship>;
  /**
   * The sponsorship from this user/organization to the viewer; that is, the
   * sponsorship you're receiving. Only returns a sponsorship if it is active.
   */
  sponsorshipForViewerAsSponsorable?: Maybe<Github_Sponsorship>;
  /** List of sponsorship updates sent from this sponsorable to sponsors. */
  sponsorshipNewsletters: Github_SponsorshipNewsletterConnection;
  /** This object's sponsorships as the maintainer. */
  sponsorshipsAsMaintainer: Github_SponsorshipConnection;
  /** This object's sponsorships as the sponsor. */
  sponsorshipsAsSponsor: Github_SponsorshipConnection;
  /** Whether or not the viewer is able to sponsor this user/organization. */
  viewerCanSponsor: Scalars['Boolean'];
  /** True if the viewer is sponsoring this user/organization. */
  viewerIsSponsoring: Scalars['Boolean'];
};


/** Entities that can be sponsored through GitHub Sponsors */
export type Github_SponsorableIsSponsoredByArgs = {
  accountLogin: Scalars['String'];
};


/** Entities that can be sponsored through GitHub Sponsors */
export type Github_SponsorableSponsoringArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorOrder>;
};


/** Entities that can be sponsored through GitHub Sponsors */
export type Github_SponsorableSponsorsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorOrder>;
  tierId?: InputMaybe<Scalars['ID']>;
};


/** Entities that can be sponsored through GitHub Sponsors */
export type Github_SponsorableSponsorsActivitiesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorsActivityOrder>;
  period?: InputMaybe<Github_SponsorsActivityPeriod>;
};


/** Entities that can be sponsored through GitHub Sponsors */
export type Github_SponsorableSponsorshipNewslettersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorshipNewsletterOrder>;
};


/** Entities that can be sponsored through GitHub Sponsors */
export type Github_SponsorableSponsorshipsAsMaintainerArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  includePrivate?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorshipOrder>;
};


/** Entities that can be sponsored through GitHub Sponsors */
export type Github_SponsorableSponsorshipsAsSponsorArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorshipOrder>;
};

/** Entities that can be sponsored via GitHub Sponsors */
export type Github_SponsorableItem = Github_Organization | Github_User;

/** The connection type for SponsorableItem. */
export type Github_SponsorableItemConnection = {
  __typename?: 'Github_SponsorableItemConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_SponsorableItemEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_SponsorableItem>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_SponsorableItemEdge = {
  __typename?: 'Github_SponsorableItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_SponsorableItem>;
};

/** Ordering options for connections to get sponsorable entities for GitHub Sponsors. */
export type Github_SponsorableOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order sponsorable entities by. */
  field: Github_SponsorableOrderField;
};

/** Properties by which sponsorable connections can be ordered. */
export enum Github_SponsorableOrderField {
  /** Order sponsorable entities by login (username). */
  Login = 'LOGIN'
}

/** Github_Sponsorable mock concrete type. */
export type Github_Sponsorable__Mock = Github_Sponsorable & {
  __typename?: 'Github_Sponsorable__Mock';
  /** The estimated next GitHub Sponsors payout for this user/organization in cents (USD). */
  estimatedNextSponsorsPayoutInCents: Scalars['Int'];
  /** True if this user/organization has a GitHub Sponsors listing. */
  hasSponsorsListing: Scalars['Boolean'];
  /** Check if the given account is sponsoring this user/organization. */
  isSponsoredBy: Scalars['Boolean'];
  /** True if the viewer is sponsored by this user/organization. */
  isSponsoringViewer: Scalars['Boolean'];
  /** The estimated monthly GitHub Sponsors income for this user/organization in cents (USD). */
  monthlyEstimatedSponsorsIncomeInCents: Scalars['Int'];
  /** List of users and organizations this entity is sponsoring. */
  sponsoring: Github_SponsorConnection;
  /** List of sponsors for this user or organization. */
  sponsors: Github_SponsorConnection;
  /** Events involving this sponsorable, such as new sponsorships. */
  sponsorsActivities: Github_SponsorsActivityConnection;
  /** The GitHub Sponsors listing for this user or organization. */
  sponsorsListing?: Maybe<Github_SponsorsListing>;
  /**
   * The sponsorship from the viewer to this user/organization; that is, the
   * sponsorship where you're the sponsor. Only returns a sponsorship if it is active.
   */
  sponsorshipForViewerAsSponsor?: Maybe<Github_Sponsorship>;
  /**
   * The sponsorship from this user/organization to the viewer; that is, the
   * sponsorship you're receiving. Only returns a sponsorship if it is active.
   */
  sponsorshipForViewerAsSponsorable?: Maybe<Github_Sponsorship>;
  /** List of sponsorship updates sent from this sponsorable to sponsors. */
  sponsorshipNewsletters: Github_SponsorshipNewsletterConnection;
  /** This object's sponsorships as the maintainer. */
  sponsorshipsAsMaintainer: Github_SponsorshipConnection;
  /** This object's sponsorships as the sponsor. */
  sponsorshipsAsSponsor: Github_SponsorshipConnection;
  /** Whether or not the viewer is able to sponsor this user/organization. */
  viewerCanSponsor: Scalars['Boolean'];
  /** True if the viewer is sponsoring this user/organization. */
  viewerIsSponsoring: Scalars['Boolean'];
};


/** Github_Sponsorable mock concrete type. */
export type Github_Sponsorable__MockIsSponsoredByArgs = {
  accountLogin: Scalars['String'];
};


/** Github_Sponsorable mock concrete type. */
export type Github_Sponsorable__MockSponsoringArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorOrder>;
};


/** Github_Sponsorable mock concrete type. */
export type Github_Sponsorable__MockSponsorsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorOrder>;
  tierId?: InputMaybe<Scalars['ID']>;
};


/** Github_Sponsorable mock concrete type. */
export type Github_Sponsorable__MockSponsorsActivitiesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorsActivityOrder>;
  period?: InputMaybe<Github_SponsorsActivityPeriod>;
};


/** Github_Sponsorable mock concrete type. */
export type Github_Sponsorable__MockSponsorshipNewslettersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorshipNewsletterOrder>;
};


/** Github_Sponsorable mock concrete type. */
export type Github_Sponsorable__MockSponsorshipsAsMaintainerArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  includePrivate?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorshipOrder>;
};


/** Github_Sponsorable mock concrete type. */
export type Github_Sponsorable__MockSponsorshipsAsSponsorArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorshipOrder>;
};

/** An event related to sponsorship activity. */
export type Github_SponsorsActivity = Github_Node & {
  __typename?: 'Github_SponsorsActivity';
  /** What action this activity indicates took place. */
  action: Github_SponsorsActivityAction;
  id: Scalars['ID'];
  /** The tier that the sponsorship used to use, for tier change events. */
  previousSponsorsTier?: Maybe<Github_SponsorsTier>;
  /** The user or organization who triggered this activity and was/is sponsoring the sponsorable. */
  sponsor?: Maybe<Github_Sponsor>;
  /** The user or organization that is being sponsored, the maintainer. */
  sponsorable: Github_Sponsorable;
  /** The associated sponsorship tier. */
  sponsorsTier?: Maybe<Github_SponsorsTier>;
  /** The timestamp of this event. */
  timestamp?: Maybe<Scalars['DateTime']>;
};

/** The possible actions that GitHub Sponsors activities can represent. */
export enum Github_SponsorsActivityAction {
  /** The activity was cancelling a sponsorship. */
  CancelledSponsorship = 'CANCELLED_SPONSORSHIP',
  /** The activity was starting a sponsorship. */
  NewSponsorship = 'NEW_SPONSORSHIP',
  /** The activity was scheduling a downgrade or cancellation. */
  PendingChange = 'PENDING_CHANGE',
  /** The activity was funds being refunded to the sponsor or GitHub. */
  Refund = 'REFUND',
  /** The activity was disabling matching for a previously matched sponsorship. */
  SponsorMatchDisabled = 'SPONSOR_MATCH_DISABLED',
  /** The activity was changing the sponsorship tier, either directly by the sponsor or by a scheduled/pending change. */
  TierChange = 'TIER_CHANGE'
}

/** The connection type for SponsorsActivity. */
export type Github_SponsorsActivityConnection = {
  __typename?: 'Github_SponsorsActivityConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_SponsorsActivityEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_SponsorsActivity>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_SponsorsActivityEdge = {
  __typename?: 'Github_SponsorsActivityEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_SponsorsActivity>;
};

/** Ordering options for GitHub Sponsors activity connections. */
export type Github_SponsorsActivityOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order activity by. */
  field: Github_SponsorsActivityOrderField;
};

/** Properties by which GitHub Sponsors activity connections can be ordered. */
export enum Github_SponsorsActivityOrderField {
  /** Order activities by when they happened. */
  Timestamp = 'TIMESTAMP'
}

/** The possible time periods for which Sponsors activities can be requested. */
export enum Github_SponsorsActivityPeriod {
  /** Don't restrict the activity to any date range, include all activity. */
  All = 'ALL',
  /** The previous calendar day. */
  Day = 'DAY',
  /** The previous thirty days. */
  Month = 'MONTH',
  /** The previous seven days. */
  Week = 'WEEK'
}

/** A goal associated with a GitHub Sponsors listing, representing a target the sponsored maintainer would like to attain. */
export type Github_SponsorsGoal = {
  __typename?: 'Github_SponsorsGoal';
  /** A description of the goal from the maintainer. */
  description?: Maybe<Scalars['String']>;
  /** What the objective of this goal is. */
  kind: Github_SponsorsGoalKind;
  /** The percentage representing how complete this goal is, between 0-100. */
  percentComplete: Scalars['Int'];
  /**
   * What the goal amount is. Represents an amount in USD for monthly sponsorship
   * amount goals. Represents a count of unique sponsors for total sponsors count goals.
   */
  targetValue: Scalars['Int'];
  /** A brief summary of the kind and target value of this goal. */
  title: Scalars['String'];
};

/** The different kinds of goals a GitHub Sponsors member can have. */
export enum Github_SponsorsGoalKind {
  /** The goal is about getting a certain amount in USD from sponsorships each month. */
  MonthlySponsorshipAmount = 'MONTHLY_SPONSORSHIP_AMOUNT',
  /** The goal is about reaching a certain number of sponsors. */
  TotalSponsorsCount = 'TOTAL_SPONSORS_COUNT'
}

/** A GitHub Sponsors listing. */
export type Github_SponsorsListing = Github_Node & {
  __typename?: 'Github_SponsorsListing';
  /** The current goal the maintainer is trying to reach with GitHub Sponsors, if any. */
  activeGoal?: Maybe<Github_SponsorsGoal>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The full description of the listing. */
  fullDescription: Scalars['String'];
  /** The full description of the listing rendered to HTML. */
  fullDescriptionHTML: Scalars['Github_HTML'];
  id: Scalars['ID'];
  /** Whether this listing is publicly visible. */
  isPublic: Scalars['Boolean'];
  /** The listing's full name. */
  name: Scalars['String'];
  /** A future date on which this listing is eligible to receive a payout. */
  nextPayoutDate?: Maybe<Scalars['Date']>;
  /** The short description of the listing. */
  shortDescription: Scalars['String'];
  /** The short name of the listing. */
  slug: Scalars['String'];
  /** The entity this listing represents who can be sponsored on GitHub Sponsors. */
  sponsorable: Github_Sponsorable;
  /** The published tiers for this GitHub Sponsors listing. */
  tiers?: Maybe<Github_SponsorsTierConnection>;
};


/** A GitHub Sponsors listing. */
export type Github_SponsorsListingTiersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorsTierOrder>;
};

/** A GitHub Sponsors tier associated with a GitHub Sponsors listing. */
export type Github_SponsorsTier = Github_Node & {
  __typename?: 'Github_SponsorsTier';
  /** SponsorsTier information only visible to users that can administer the associated Sponsors listing. */
  adminInfo?: Maybe<Github_SponsorsTierAdminInfo>;
  /**
   * Get a different tier for this tier's maintainer that is at the same frequency
   * as this tier but with an equal or lesser cost. Returns the published tier with
   * the monthly price closest to this tier's without going over.
   */
  closestLesserValueTier?: Maybe<Github_SponsorsTier>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The description of the tier. */
  description: Scalars['String'];
  /** The tier description rendered to HTML */
  descriptionHTML: Scalars['Github_HTML'];
  id: Scalars['ID'];
  /**
   * Whether this tier was chosen at checkout time by the sponsor rather than
   * defined ahead of time by the maintainer who manages the Sponsors listing.
   */
  isCustomAmount: Scalars['Boolean'];
  /** Whether this tier is only for use with one-time sponsorships. */
  isOneTime: Scalars['Boolean'];
  /** How much this tier costs per month in cents. */
  monthlyPriceInCents: Scalars['Int'];
  /** How much this tier costs per month in USD. */
  monthlyPriceInDollars: Scalars['Int'];
  /** The name of the tier. */
  name: Scalars['String'];
  /** The sponsors listing that this tier belongs to. */
  sponsorsListing: Github_SponsorsListing;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** SponsorsTier information only visible to users that can administer the associated Sponsors listing. */
export type Github_SponsorsTierAdminInfo = {
  __typename?: 'Github_SponsorsTierAdminInfo';
  /** The sponsorships associated with this tier. */
  sponsorships: Github_SponsorshipConnection;
};


/** SponsorsTier information only visible to users that can administer the associated Sponsors listing. */
export type Github_SponsorsTierAdminInfoSponsorshipsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  includePrivate?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorshipOrder>;
};

/** The connection type for SponsorsTier. */
export type Github_SponsorsTierConnection = {
  __typename?: 'Github_SponsorsTierConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_SponsorsTierEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_SponsorsTier>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_SponsorsTierEdge = {
  __typename?: 'Github_SponsorsTierEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_SponsorsTier>;
};

/** Ordering options for Sponsors tiers connections. */
export type Github_SponsorsTierOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order tiers by. */
  field: Github_SponsorsTierOrderField;
};

/** Properties by which Sponsors tiers connections can be ordered. */
export enum Github_SponsorsTierOrderField {
  /** Order tiers by creation time. */
  CreatedAt = 'CREATED_AT',
  /** Order tiers by their monthly price in cents */
  MonthlyPriceInCents = 'MONTHLY_PRICE_IN_CENTS'
}

/** A sponsorship relationship between a sponsor and a maintainer */
export type Github_Sponsorship = Github_Node & {
  __typename?: 'Github_Sponsorship';
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Whether this sponsorship represents a one-time payment versus a recurring sponsorship. */
  isOneTimePayment: Scalars['Boolean'];
  /**
   * Check if the sponsor has chosen to receive sponsorship update emails sent from
   * the sponsorable. Only returns a non-null value when the viewer has permission to know this.
   */
  isSponsorOptedIntoEmail?: Maybe<Scalars['Boolean']>;
  /**
   * The entity that is being sponsored
   * @deprecated `Sponsorship.maintainer` will be removed. Use `Sponsorship.sponsorable` instead. Removal on 2020-04-01 UTC.
   */
  maintainer: Github_User;
  /** The privacy level for this sponsorship. */
  privacyLevel: Github_SponsorshipPrivacy;
  /**
   * The user that is sponsoring. Returns null if the sponsorship is private or if sponsor is not a user.
   * @deprecated `Sponsorship.sponsor` will be removed. Use `Sponsorship.sponsorEntity` instead. Removal on 2020-10-01 UTC.
   */
  sponsor?: Maybe<Github_User>;
  /** The user or organization that is sponsoring, if you have permission to view them. */
  sponsorEntity?: Maybe<Github_Sponsor>;
  /** The entity that is being sponsored */
  sponsorable: Github_Sponsorable;
  /** The associated sponsorship tier */
  tier?: Maybe<Github_SponsorsTier>;
  /** Identifies the date and time when the current tier was chosen for this sponsorship. */
  tierSelectedAt?: Maybe<Scalars['DateTime']>;
};

/** The connection type for Sponsorship. */
export type Github_SponsorshipConnection = {
  __typename?: 'Github_SponsorshipConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_SponsorshipEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Sponsorship>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
  /**
   * The total amount in cents of all recurring sponsorships in the connection
   * whose amount you can view. Does not include one-time sponsorships.
   */
  totalRecurringMonthlyPriceInCents: Scalars['Int'];
  /**
   * The total amount in USD of all recurring sponsorships in the connection whose
   * amount you can view. Does not include one-time sponsorships.
   */
  totalRecurringMonthlyPriceInDollars: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_SponsorshipEdge = {
  __typename?: 'Github_SponsorshipEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Sponsorship>;
};

/** An update sent to sponsors of a user or organization on GitHub Sponsors. */
export type Github_SponsorshipNewsletter = Github_Node & {
  __typename?: 'Github_SponsorshipNewsletter';
  /** The contents of the newsletter, the message the sponsorable wanted to give. */
  body: Scalars['String'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Indicates if the newsletter has been made available to sponsors. */
  isPublished: Scalars['Boolean'];
  /** The user or organization this newsletter is from. */
  sponsorable: Github_Sponsorable;
  /** The subject of the newsletter, what it's about. */
  subject: Scalars['String'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** The connection type for SponsorshipNewsletter. */
export type Github_SponsorshipNewsletterConnection = {
  __typename?: 'Github_SponsorshipNewsletterConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_SponsorshipNewsletterEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_SponsorshipNewsletter>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_SponsorshipNewsletterEdge = {
  __typename?: 'Github_SponsorshipNewsletterEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_SponsorshipNewsletter>;
};

/** Ordering options for sponsorship newsletter connections. */
export type Github_SponsorshipNewsletterOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order sponsorship newsletters by. */
  field: Github_SponsorshipNewsletterOrderField;
};

/** Properties by which sponsorship update connections can be ordered. */
export enum Github_SponsorshipNewsletterOrderField {
  /** Order sponsorship newsletters by when they were created. */
  CreatedAt = 'CREATED_AT'
}

/** Ordering options for sponsorship connections. */
export type Github_SponsorshipOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order sponsorship by. */
  field: Github_SponsorshipOrderField;
};

/** Properties by which sponsorship connections can be ordered. */
export enum Github_SponsorshipOrderField {
  /** Order sponsorship by creation time. */
  CreatedAt = 'CREATED_AT'
}

/** The privacy of a sponsorship */
export enum Github_SponsorshipPrivacy {
  /** Private */
  Private = 'PRIVATE',
  /** Public */
  Public = 'PUBLIC'
}

/** Ways in which star connections can be ordered. */
export type Github_StarOrder = {
  /** The direction in which to order nodes. */
  direction: Github_OrderDirection;
  /** The field in which to order nodes by. */
  field: Github_StarOrderField;
};

/** Properties by which star connections can be ordered. */
export enum Github_StarOrderField {
  /** Allows ordering a list of stars by when they were created. */
  StarredAt = 'STARRED_AT'
}

/** The connection type for User. */
export type Github_StargazerConnection = {
  __typename?: 'Github_StargazerConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_StargazerEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Represents a user that's starred a repository. */
export type Github_StargazerEdge = {
  __typename?: 'Github_StargazerEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  node: Github_User;
  /** Identifies when the item was starred. */
  starredAt: Scalars['DateTime'];
};

/** Things that can be starred. */
export type Github_Starrable = {
  id: Scalars['ID'];
  /** Returns a count of how many stargazers there are on this object */
  stargazerCount: Scalars['Int'];
  /** A list of users who have starred this starrable. */
  stargazers: Github_StargazerConnection;
  /** Returns a boolean indicating whether the viewing user has starred this starrable. */
  viewerHasStarred: Scalars['Boolean'];
};


/** Things that can be starred. */
export type Github_StarrableStargazersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_StarOrder>;
};

/** Github_Starrable mock concrete type. */
export type Github_Starrable__Mock = Github_Starrable & {
  __typename?: 'Github_Starrable__Mock';
  id: Scalars['ID'];
  /** Returns a count of how many stargazers there are on this object */
  stargazerCount: Scalars['Int'];
  /** A list of users who have starred this starrable. */
  stargazers: Github_StargazerConnection;
  /** Returns a boolean indicating whether the viewing user has starred this starrable. */
  viewerHasStarred: Scalars['Boolean'];
};


/** Github_Starrable mock concrete type. */
export type Github_Starrable__MockStargazersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_StarOrder>;
};

/** The connection type for Repository. */
export type Github_StarredRepositoryConnection = {
  __typename?: 'Github_StarredRepositoryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_StarredRepositoryEdge>>>;
  /** Is the list of stars for this user truncated? This is true for users that have many stars. */
  isOverLimit: Scalars['Boolean'];
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Repository>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Represents a starred repository. */
export type Github_StarredRepositoryEdge = {
  __typename?: 'Github_StarredRepositoryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  node: Github_Repository;
  /** Identifies when the item was starred. */
  starredAt: Scalars['DateTime'];
};

/** Represents a commit status. */
export type Github_Status = Github_Node & {
  __typename?: 'Github_Status';
  /** A list of status contexts and check runs for this commit. */
  combinedContexts: Github_StatusCheckRollupContextConnection;
  /** The commit this status is attached to. */
  commit?: Maybe<Github_Commit>;
  /** Looks up an individual status context by context name. */
  context?: Maybe<Github_StatusContext>;
  /** The individual status contexts for this commit. */
  contexts: Array<Github_StatusContext>;
  id: Scalars['ID'];
  /** The combined commit status. */
  state: Github_StatusState;
};


/** Represents a commit status. */
export type Github_StatusCombinedContextsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Represents a commit status. */
export type Github_StatusContextArgs = {
  name: Scalars['String'];
};

/** Represents the rollup for both the check runs and status for a commit. */
export type Github_StatusCheckRollup = Github_Node & {
  __typename?: 'Github_StatusCheckRollup';
  /** The commit the status and check runs are attached to. */
  commit?: Maybe<Github_Commit>;
  /** A list of status contexts and check runs for this commit. */
  contexts: Github_StatusCheckRollupContextConnection;
  id: Scalars['ID'];
  /** The combined status for the commit. */
  state: Github_StatusState;
};


/** Represents the rollup for both the check runs and status for a commit. */
export type Github_StatusCheckRollupContextsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Types that can be inside a StatusCheckRollup context. */
export type Github_StatusCheckRollupContext = Github_CheckRun | Github_StatusContext;

/** The connection type for StatusCheckRollupContext. */
export type Github_StatusCheckRollupContextConnection = {
  __typename?: 'Github_StatusCheckRollupContextConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_StatusCheckRollupContextEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_StatusCheckRollupContext>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_StatusCheckRollupContextEdge = {
  __typename?: 'Github_StatusCheckRollupContextEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_StatusCheckRollupContext>;
};

/** Represents an individual commit status context */
export type Github_StatusContext = Github_Node & Github_RequirableByPullRequest & {
  __typename?: 'Github_StatusContext';
  /** The avatar of the OAuth application or the user that created the status */
  avatarUrl?: Maybe<Scalars['Github_URI']>;
  /** This commit this status context is attached to. */
  commit?: Maybe<Github_Commit>;
  /** The name of this status context. */
  context: Scalars['String'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The actor who created this status context. */
  creator?: Maybe<Github_Actor>;
  /** The description for this status context. */
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** Whether this is required to pass before merging for a specific pull request. */
  isRequired: Scalars['Boolean'];
  /** The state of this status context. */
  state: Github_StatusState;
  /** The URL for this status context. */
  targetUrl?: Maybe<Scalars['Github_URI']>;
};


/** Represents an individual commit status context */
export type Github_StatusContextAvatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']>;
};


/** Represents an individual commit status context */
export type Github_StatusContextIsRequiredArgs = {
  pullRequestId?: InputMaybe<Scalars['ID']>;
  pullRequestNumber?: InputMaybe<Scalars['Int']>;
};

/** The possible commit status states. */
export enum Github_StatusState {
  /** Status is errored. */
  Error = 'ERROR',
  /** Status is expected. */
  Expected = 'EXPECTED',
  /** Status is failing. */
  Failure = 'FAILURE',
  /** Status is pending. */
  Pending = 'PENDING',
  /** Status is successful. */
  Success = 'SUCCESS'
}

/** Autogenerated input type of SubmitPullRequestReview */
export type Github_SubmitPullRequestReviewInput = {
  /** The text field to set on the Pull Request Review. */
  body?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The event to send to the Pull Request Review. */
  event: Github_PullRequestReviewEvent;
  /** The Pull Request ID to submit any pending reviews. */
  pullRequestId?: InputMaybe<Scalars['ID']>;
  /** The Pull Request Review ID to submit. */
  pullRequestReviewId?: InputMaybe<Scalars['ID']>;
};

/** Autogenerated return type of SubmitPullRequestReview */
export type Github_SubmitPullRequestReviewPayload = {
  __typename?: 'Github_SubmitPullRequestReviewPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The submitted pull request review. */
  pullRequestReview?: Maybe<Github_PullRequestReview>;
};

/** A pointer to a repository at a specific revision embedded inside another repository. */
export type Github_Submodule = {
  __typename?: 'Github_Submodule';
  /** The branch of the upstream submodule for tracking updates */
  branch?: Maybe<Scalars['String']>;
  /** The git URL of the submodule repository */
  gitUrl: Scalars['Github_URI'];
  /** The name of the submodule in .gitmodules */
  name: Scalars['String'];
  /** The path in the superproject that this submodule is located in */
  path: Scalars['String'];
  /** The commit revision of the subproject repository being tracked by the submodule */
  subprojectCommitOid?: Maybe<Scalars['Github_GitObjectID']>;
};

/** The connection type for Submodule. */
export type Github_SubmoduleConnection = {
  __typename?: 'Github_SubmoduleConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_SubmoduleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Submodule>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_SubmoduleEdge = {
  __typename?: 'Github_SubmoduleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Submodule>;
};

/** Entities that can be subscribed to for web and email notifications. */
export type Github_Subscribable = {
  id: Scalars['ID'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<Github_SubscriptionState>;
};

/** Github_Subscribable mock concrete type. */
export type Github_Subscribable__Mock = Github_Subscribable & {
  __typename?: 'Github_Subscribable__Mock';
  id: Scalars['ID'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<Github_SubscriptionState>;
};

/** Represents a 'subscribed' event on a given `Subscribable`. */
export type Github_SubscribedEvent = Github_Node & {
  __typename?: 'Github_SubscribedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Object referenced by event. */
  subscribable: Github_Subscribable;
};

/** The possible states of a subscription. */
export enum Github_SubscriptionState {
  /** The User is never notified. */
  Ignored = 'IGNORED',
  /** The User is notified of all conversations. */
  Subscribed = 'SUBSCRIBED',
  /** The User is only notified when participating or @mentioned. */
  Unsubscribed = 'UNSUBSCRIBED'
}

/** A suggestion to review a pull request based on a user's commit history and review comments. */
export type Github_SuggestedReviewer = {
  __typename?: 'Github_SuggestedReviewer';
  /** Is this suggestion based on past commits? */
  isAuthor: Scalars['Boolean'];
  /** Is this suggestion based on past review comments? */
  isCommenter: Scalars['Boolean'];
  /** Identifies the user suggested to review the pull request. */
  reviewer: Github_User;
};

/** Represents a Git tag. */
export type Github_Tag = Github_GitObject & Github_Node & {
  __typename?: 'Github_Tag';
  /** An abbreviated version of the Git object ID */
  abbreviatedOid: Scalars['String'];
  /** The HTTP path for this Git object */
  commitResourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this Git object */
  commitUrl: Scalars['Github_URI'];
  id: Scalars['ID'];
  /** The Git tag message. */
  message?: Maybe<Scalars['String']>;
  /** The Git tag name. */
  name: Scalars['String'];
  /** The Git object ID */
  oid: Scalars['Github_GitObjectID'];
  /** The Repository the Git object belongs to */
  repository: Github_Repository;
  /** Details about the tag author. */
  tagger?: Maybe<Github_GitActor>;
  /** The Git object the tag points to. */
  target: Github_GitObject;
};

/** A team of users in an organization. */
export type Github_Team = Github_MemberStatusable & Github_Node & Github_Subscribable & {
  __typename?: 'Github_Team';
  /** A list of teams that are ancestors of this team. */
  ancestors: Github_TeamConnection;
  /** A URL pointing to the team's avatar. */
  avatarUrl?: Maybe<Scalars['Github_URI']>;
  /** List of child teams belonging to this team */
  childTeams: Github_TeamConnection;
  /** The slug corresponding to the organization and team. */
  combinedSlug: Scalars['String'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The description of the team. */
  description?: Maybe<Scalars['String']>;
  /** Find a team discussion by its number. */
  discussion?: Maybe<Github_TeamDiscussion>;
  /** A list of team discussions. */
  discussions: Github_TeamDiscussionConnection;
  /** The HTTP path for team discussions */
  discussionsResourcePath: Scalars['Github_URI'];
  /** The HTTP URL for team discussions */
  discussionsUrl: Scalars['Github_URI'];
  /** The HTTP path for editing this team */
  editTeamResourcePath: Scalars['Github_URI'];
  /** The HTTP URL for editing this team */
  editTeamUrl: Scalars['Github_URI'];
  id: Scalars['ID'];
  /** A list of pending invitations for users to this team */
  invitations?: Maybe<Github_OrganizationInvitationConnection>;
  /** Get the status messages members of this entity have set that are either public or visible only to the organization. */
  memberStatuses: Github_UserStatusConnection;
  /** A list of users who are members of this team. */
  members: Github_TeamMemberConnection;
  /** The HTTP path for the team' members */
  membersResourcePath: Scalars['Github_URI'];
  /** The HTTP URL for the team' members */
  membersUrl: Scalars['Github_URI'];
  /** The name of the team. */
  name: Scalars['String'];
  /** The HTTP path creating a new team */
  newTeamResourcePath: Scalars['Github_URI'];
  /** The HTTP URL creating a new team */
  newTeamUrl: Scalars['Github_URI'];
  /** The organization that owns this team. */
  organization: Github_Organization;
  /** The parent team of the team. */
  parentTeam?: Maybe<Github_Team>;
  /** The level of privacy the team has. */
  privacy: Github_TeamPrivacy;
  /** A list of repositories this team has access to. */
  repositories: Github_TeamRepositoryConnection;
  /** The HTTP path for this team's repositories */
  repositoriesResourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this team's repositories */
  repositoriesUrl: Scalars['Github_URI'];
  /** The HTTP path for this team */
  resourcePath: Scalars['Github_URI'];
  /** What algorithm is used for review assignment for this team */
  reviewRequestDelegationAlgorithm?: Maybe<Github_TeamReviewAssignmentAlgorithm>;
  /** True if review assignment is enabled for this team */
  reviewRequestDelegationEnabled: Scalars['Boolean'];
  /** How many team members are required for review assignment for this team */
  reviewRequestDelegationMemberCount?: Maybe<Scalars['Int']>;
  /** When assigning team members via delegation, whether the entire team should be notified as well. */
  reviewRequestDelegationNotifyTeam: Scalars['Boolean'];
  /** The slug corresponding to the team. */
  slug: Scalars['String'];
  /** The HTTP path for this team's teams */
  teamsResourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this team's teams */
  teamsUrl: Scalars['Github_URI'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this team */
  url: Scalars['Github_URI'];
  /** Team is adminable by the viewer. */
  viewerCanAdminister: Scalars['Boolean'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<Github_SubscriptionState>;
};


/** A team of users in an organization. */
export type Github_TeamAncestorsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A team of users in an organization. */
export type Github_TeamAvatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']>;
};


/** A team of users in an organization. */
export type Github_TeamChildTeamsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  immediateOnly?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_TeamOrder>;
  userLogins?: InputMaybe<Array<Scalars['String']>>;
};


/** A team of users in an organization. */
export type Github_TeamDiscussionArgs = {
  number: Scalars['Int'];
};


/** A team of users in an organization. */
export type Github_TeamDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  isPinned?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_TeamDiscussionOrder>;
};


/** A team of users in an organization. */
export type Github_TeamInvitationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A team of users in an organization. */
export type Github_TeamMemberStatusesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_UserStatusOrder>;
};


/** A team of users in an organization. */
export type Github_TeamMembersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  membership?: InputMaybe<Github_TeamMembershipType>;
  orderBy?: InputMaybe<Github_TeamMemberOrder>;
  query?: InputMaybe<Scalars['String']>;
  role?: InputMaybe<Github_TeamMemberRole>;
};


/** A team of users in an organization. */
export type Github_TeamRepositoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_TeamRepositoryOrder>;
  query?: InputMaybe<Scalars['String']>;
};

/** Audit log entry for a team.add_member event. */
export type Github_TeamAddMemberAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_TeamAuditEntryData & {
  __typename?: 'Github_TeamAddMemberAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** Whether the team was mapped to an LDAP Group. */
  isLdapMapped?: Maybe<Scalars['Boolean']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The team associated with the action */
  team?: Maybe<Github_Team>;
  /** The name of the team */
  teamName?: Maybe<Scalars['String']>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a team.add_repository event. */
export type Github_TeamAddRepositoryAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & Github_TeamAuditEntryData & {
  __typename?: 'Github_TeamAddRepositoryAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** Whether the team was mapped to an LDAP Group. */
  isLdapMapped?: Maybe<Scalars['Boolean']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The team associated with the action */
  team?: Maybe<Github_Team>;
  /** The name of the team */
  teamName?: Maybe<Scalars['String']>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Metadata for an audit entry with action team.* */
export type Github_TeamAuditEntryData = {
  /** The team associated with the action */
  team?: Maybe<Github_Team>;
  /** The name of the team */
  teamName?: Maybe<Scalars['String']>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['Github_URI']>;
};

/** Github_TeamAuditEntryData mock concrete type. */
export type Github_TeamAuditEntryData__Mock = Github_TeamAuditEntryData & {
  __typename?: 'Github_TeamAuditEntryData__Mock';
  /** The team associated with the action */
  team?: Maybe<Github_Team>;
  /** The name of the team */
  teamName?: Maybe<Scalars['String']>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a team.change_parent_team event. */
export type Github_TeamChangeParentTeamAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_TeamAuditEntryData & {
  __typename?: 'Github_TeamChangeParentTeamAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** Whether the team was mapped to an LDAP Group. */
  isLdapMapped?: Maybe<Scalars['Boolean']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The new parent team. */
  parentTeam?: Maybe<Github_Team>;
  /** The name of the new parent team */
  parentTeamName?: Maybe<Scalars['String']>;
  /** The name of the former parent team */
  parentTeamNameWas?: Maybe<Scalars['String']>;
  /** The HTTP path for the parent team */
  parentTeamResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the parent team */
  parentTeamUrl?: Maybe<Scalars['Github_URI']>;
  /** The former parent team. */
  parentTeamWas?: Maybe<Github_Team>;
  /** The HTTP path for the previous parent team */
  parentTeamWasResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the previous parent team */
  parentTeamWasUrl?: Maybe<Scalars['Github_URI']>;
  /** The team associated with the action */
  team?: Maybe<Github_Team>;
  /** The name of the team */
  teamName?: Maybe<Scalars['String']>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** The connection type for Team. */
export type Github_TeamConnection = {
  __typename?: 'Github_TeamConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_TeamEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Team>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** A team discussion. */
export type Github_TeamDiscussion = Github_Comment & Github_Deletable & Github_Node & Github_Reactable & Github_Subscribable & Github_UniformResourceLocatable & Github_Updatable & Github_UpdatableComment & {
  __typename?: 'Github_TeamDiscussion';
  /** The actor who authored the comment. */
  author?: Maybe<Github_Actor>;
  /** Author's association with the discussion's team. */
  authorAssociation: Github_CommentAuthorAssociation;
  /** The body as Markdown. */
  body: Scalars['String'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['Github_HTML'];
  /** The body rendered to text. */
  bodyText: Scalars['String'];
  /** Identifies the discussion body hash. */
  bodyVersion: Scalars['String'];
  /** A list of comments on this discussion. */
  comments: Github_TeamDiscussionCommentConnection;
  /** The HTTP path for discussion comments */
  commentsResourcePath: Scalars['Github_URI'];
  /** The HTTP URL for discussion comments */
  commentsUrl: Scalars['Github_URI'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The actor who edited the comment. */
  editor?: Maybe<Github_Actor>;
  id: Scalars['ID'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'];
  /** Whether or not the discussion is pinned. */
  isPinned: Scalars['Boolean'];
  /** Whether or not the discussion is only visible to team members and org admins. */
  isPrivate: Scalars['Boolean'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>;
  /** Identifies the discussion within its team. */
  number: Scalars['Int'];
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<Github_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: Github_ReactionConnection;
  /** The HTTP path for this discussion */
  resourcePath: Scalars['Github_URI'];
  /** The team that defines the context of this discussion. */
  team: Github_Team;
  /** The title of the discussion */
  title: Scalars['String'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this discussion */
  url: Scalars['Github_URI'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<Github_UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'];
  /** Whether or not the current viewer can pin this discussion. */
  viewerCanPin: Scalars['Boolean'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'];
  /** Check if the viewer is able to change their subscription status for the repository. */
  viewerCanSubscribe: Scalars['Boolean'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<Github_CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'];
  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */
  viewerSubscription?: Maybe<Github_SubscriptionState>;
};


/** A team discussion. */
export type Github_TeamDiscussionCommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  fromComment?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_TeamDiscussionCommentOrder>;
};


/** A team discussion. */
export type Github_TeamDiscussionReactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Github_ReactionContent>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ReactionOrder>;
};


/** A team discussion. */
export type Github_TeamDiscussionUserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** A comment on a team discussion. */
export type Github_TeamDiscussionComment = Github_Comment & Github_Deletable & Github_Node & Github_Reactable & Github_UniformResourceLocatable & Github_Updatable & Github_UpdatableComment & {
  __typename?: 'Github_TeamDiscussionComment';
  /** The actor who authored the comment. */
  author?: Maybe<Github_Actor>;
  /** Author's association with the comment's team. */
  authorAssociation: Github_CommentAuthorAssociation;
  /** The body as Markdown. */
  body: Scalars['String'];
  /** The body rendered to HTML. */
  bodyHTML: Scalars['Github_HTML'];
  /** The body rendered to text. */
  bodyText: Scalars['String'];
  /** The current version of the body content. */
  bodyVersion: Scalars['String'];
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Check if this comment was created via an email reply. */
  createdViaEmail: Scalars['Boolean'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The discussion this comment is about. */
  discussion: Github_TeamDiscussion;
  /** The actor who edited the comment. */
  editor?: Maybe<Github_Actor>;
  id: Scalars['ID'];
  /** Check if this comment was edited and includes an edit with the creation data */
  includesCreatedEdit: Scalars['Boolean'];
  /** The moment the editor made the last edit */
  lastEditedAt?: Maybe<Scalars['DateTime']>;
  /** Identifies the comment number. */
  number: Scalars['Int'];
  /** Identifies when the comment was published at. */
  publishedAt?: Maybe<Scalars['DateTime']>;
  /** A list of reactions grouped by content left on the subject. */
  reactionGroups?: Maybe<Array<Github_ReactionGroup>>;
  /** A list of Reactions left on the Issue. */
  reactions: Github_ReactionConnection;
  /** The HTTP path for this comment */
  resourcePath: Scalars['Github_URI'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this comment */
  url: Scalars['Github_URI'];
  /** A list of edits to this content. */
  userContentEdits?: Maybe<Github_UserContentEditConnection>;
  /** Check if the current viewer can delete this object. */
  viewerCanDelete: Scalars['Boolean'];
  /** Can user react to this subject */
  viewerCanReact: Scalars['Boolean'];
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<Github_CommentCannotUpdateReason>;
  /** Did the viewer author this comment. */
  viewerDidAuthor: Scalars['Boolean'];
};


/** A comment on a team discussion. */
export type Github_TeamDiscussionCommentReactionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  content?: InputMaybe<Github_ReactionContent>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ReactionOrder>;
};


/** A comment on a team discussion. */
export type Github_TeamDiscussionCommentUserContentEditsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for TeamDiscussionComment. */
export type Github_TeamDiscussionCommentConnection = {
  __typename?: 'Github_TeamDiscussionCommentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_TeamDiscussionCommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_TeamDiscussionComment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_TeamDiscussionCommentEdge = {
  __typename?: 'Github_TeamDiscussionCommentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_TeamDiscussionComment>;
};

/** Ways in which team discussion comment connections can be ordered. */
export type Github_TeamDiscussionCommentOrder = {
  /** The direction in which to order nodes. */
  direction: Github_OrderDirection;
  /** The field by which to order nodes. */
  field: Github_TeamDiscussionCommentOrderField;
};

/** Properties by which team discussion comment connections can be ordered. */
export enum Github_TeamDiscussionCommentOrderField {
  /** Allows sequential ordering of team discussion comments (which is equivalent to chronological ordering). */
  Number = 'NUMBER'
}

/** The connection type for TeamDiscussion. */
export type Github_TeamDiscussionConnection = {
  __typename?: 'Github_TeamDiscussionConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_TeamDiscussionEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_TeamDiscussion>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_TeamDiscussionEdge = {
  __typename?: 'Github_TeamDiscussionEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_TeamDiscussion>;
};

/** Ways in which team discussion connections can be ordered. */
export type Github_TeamDiscussionOrder = {
  /** The direction in which to order nodes. */
  direction: Github_OrderDirection;
  /** The field by which to order nodes. */
  field: Github_TeamDiscussionOrderField;
};

/** Properties by which team discussion connections can be ordered. */
export enum Github_TeamDiscussionOrderField {
  /** Allows chronological ordering of team discussions. */
  CreatedAt = 'CREATED_AT'
}

/** An edge in a connection. */
export type Github_TeamEdge = {
  __typename?: 'Github_TeamEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_Team>;
};

/** The connection type for User. */
export type Github_TeamMemberConnection = {
  __typename?: 'Github_TeamMemberConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_TeamMemberEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Represents a user who is a member of a team. */
export type Github_TeamMemberEdge = {
  __typename?: 'Github_TeamMemberEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The HTTP path to the organization's member access page. */
  memberAccessResourcePath: Scalars['Github_URI'];
  /** The HTTP URL to the organization's member access page. */
  memberAccessUrl: Scalars['Github_URI'];
  node: Github_User;
  /** The role the member has on the team. */
  role: Github_TeamMemberRole;
};

/** Ordering options for team member connections */
export type Github_TeamMemberOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order team members by. */
  field: Github_TeamMemberOrderField;
};

/** Properties by which team member connections can be ordered. */
export enum Github_TeamMemberOrderField {
  /** Order team members by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order team members by login */
  Login = 'LOGIN'
}

/** The possible team member roles; either 'maintainer' or 'member'. */
export enum Github_TeamMemberRole {
  /** A team maintainer has permission to add and remove team members. */
  Maintainer = 'MAINTAINER',
  /** A team member has no administrative permissions on the team. */
  Member = 'MEMBER'
}

/** Defines which types of team members are included in the returned list. Can be one of IMMEDIATE, CHILD_TEAM or ALL. */
export enum Github_TeamMembershipType {
  /** Includes immediate and child team members for the team. */
  All = 'ALL',
  /** Includes only child team members for the team. */
  ChildTeam = 'CHILD_TEAM',
  /** Includes only immediate members of the team. */
  Immediate = 'IMMEDIATE'
}

/** Ways in which team connections can be ordered. */
export type Github_TeamOrder = {
  /** The direction in which to order nodes. */
  direction: Github_OrderDirection;
  /** The field in which to order nodes by. */
  field: Github_TeamOrderField;
};

/** Properties by which team connections can be ordered. */
export enum Github_TeamOrderField {
  /** Allows ordering a list of teams by name. */
  Name = 'NAME'
}

/** The possible team privacy values. */
export enum Github_TeamPrivacy {
  /** A secret team can only be seen by its members. */
  Secret = 'SECRET',
  /** A visible team can be seen and @mentioned by every member of the organization. */
  Visible = 'VISIBLE'
}

/** Audit log entry for a team.remove_member event. */
export type Github_TeamRemoveMemberAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_TeamAuditEntryData & {
  __typename?: 'Github_TeamRemoveMemberAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** Whether the team was mapped to an LDAP Group. */
  isLdapMapped?: Maybe<Scalars['Boolean']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The team associated with the action */
  team?: Maybe<Github_Team>;
  /** The name of the team */
  teamName?: Maybe<Scalars['String']>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** Audit log entry for a team.remove_repository event. */
export type Github_TeamRemoveRepositoryAuditEntry = Github_AuditEntry & Github_Node & Github_OrganizationAuditEntryData & Github_RepositoryAuditEntryData & Github_TeamAuditEntryData & {
  __typename?: 'Github_TeamRemoveRepositoryAuditEntry';
  /** The action name */
  action: Scalars['String'];
  /** The user who initiated the action */
  actor?: Maybe<Github_AuditEntryActor>;
  /** The IP address of the actor */
  actorIp?: Maybe<Scalars['String']>;
  /** A readable representation of the actor's location */
  actorLocation?: Maybe<Github_ActorLocation>;
  /** The username of the user who initiated the action */
  actorLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the actor. */
  actorResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the actor. */
  actorUrl?: Maybe<Scalars['Github_URI']>;
  /** The time the action was initiated */
  createdAt: Scalars['Github_PreciseDateTime'];
  id: Scalars['ID'];
  /** Whether the team was mapped to an LDAP Group. */
  isLdapMapped?: Maybe<Scalars['Boolean']>;
  /** The corresponding operation type for the action */
  operationType?: Maybe<Github_OperationType>;
  /** The Organization associated with the Audit Entry. */
  organization?: Maybe<Github_Organization>;
  /** The name of the Organization. */
  organizationName?: Maybe<Scalars['String']>;
  /** The HTTP path for the organization */
  organizationResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the organization */
  organizationUrl?: Maybe<Scalars['Github_URI']>;
  /** The repository associated with the action */
  repository?: Maybe<Github_Repository>;
  /** The name of the repository */
  repositoryName?: Maybe<Scalars['String']>;
  /** The HTTP path for the repository */
  repositoryResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the repository */
  repositoryUrl?: Maybe<Scalars['Github_URI']>;
  /** The team associated with the action */
  team?: Maybe<Github_Team>;
  /** The name of the team */
  teamName?: Maybe<Scalars['String']>;
  /** The HTTP path for this team */
  teamResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for this team */
  teamUrl?: Maybe<Scalars['Github_URI']>;
  /** The user affected by the action */
  user?: Maybe<Github_User>;
  /** For actions involving two users, the actor is the initiator and the user is the affected user. */
  userLogin?: Maybe<Scalars['String']>;
  /** The HTTP path for the user. */
  userResourcePath?: Maybe<Scalars['Github_URI']>;
  /** The HTTP URL for the user. */
  userUrl?: Maybe<Scalars['Github_URI']>;
};

/** The connection type for Repository. */
export type Github_TeamRepositoryConnection = {
  __typename?: 'Github_TeamRepositoryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_TeamRepositoryEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_Repository>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Represents a team repository. */
export type Github_TeamRepositoryEdge = {
  __typename?: 'Github_TeamRepositoryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  node: Github_Repository;
  /** The permission level the team has on the repository */
  permission: Github_RepositoryPermission;
};

/** Ordering options for team repository connections */
export type Github_TeamRepositoryOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order repositories by. */
  field: Github_TeamRepositoryOrderField;
};

/** Properties by which team repository connections can be ordered. */
export enum Github_TeamRepositoryOrderField {
  /** Order repositories by creation time */
  CreatedAt = 'CREATED_AT',
  /** Order repositories by name */
  Name = 'NAME',
  /** Order repositories by permission */
  Permission = 'PERMISSION',
  /** Order repositories by push time */
  PushedAt = 'PUSHED_AT',
  /** Order repositories by number of stargazers */
  Stargazers = 'STARGAZERS',
  /** Order repositories by update time */
  UpdatedAt = 'UPDATED_AT'
}

/** The possible team review assignment algorithms */
export enum Github_TeamReviewAssignmentAlgorithm {
  /** Balance review load across the entire team */
  LoadBalance = 'LOAD_BALANCE',
  /** Alternate reviews between each team member */
  RoundRobin = 'ROUND_ROBIN'
}

/** The role of a user on a team. */
export enum Github_TeamRole {
  /** User has admin rights on the team. */
  Admin = 'ADMIN',
  /** User is a member of the team. */
  Member = 'MEMBER'
}

/** A text match within a search result. */
export type Github_TextMatch = {
  __typename?: 'Github_TextMatch';
  /** The specific text fragment within the property matched on. */
  fragment: Scalars['String'];
  /** Highlights within the matched fragment. */
  highlights: Array<Github_TextMatchHighlight>;
  /** The property matched on. */
  property: Scalars['String'];
};

/** Represents a single highlight in a search result match. */
export type Github_TextMatchHighlight = {
  __typename?: 'Github_TextMatchHighlight';
  /** The indice in the fragment where the matched text begins. */
  beginIndice: Scalars['Int'];
  /** The indice in the fragment where the matched text ends. */
  endIndice: Scalars['Int'];
  /** The text matched. */
  text: Scalars['String'];
};

/** A topic aggregates entities that are related to a subject. */
export type Github_Topic = Github_Node & Github_Starrable & {
  __typename?: 'Github_Topic';
  id: Scalars['ID'];
  /** The topic's name. */
  name: Scalars['String'];
  /**
   * A list of related topics, including aliases of this topic, sorted with the most relevant
   * first. Returns up to 10 Topics.
   */
  relatedTopics: Array<Github_Topic>;
  /** A list of repositories. */
  repositories: Github_RepositoryConnection;
  /** Returns a count of how many stargazers there are on this object */
  stargazerCount: Scalars['Int'];
  /** A list of users who have starred this starrable. */
  stargazers: Github_StargazerConnection;
  /** Returns a boolean indicating whether the viewing user has starred this starrable. */
  viewerHasStarred: Scalars['Boolean'];
};


/** A topic aggregates entities that are related to a subject. */
export type Github_TopicRelatedTopicsArgs = {
  first?: InputMaybe<Scalars['Int']>;
};


/** A topic aggregates entities that are related to a subject. */
export type Github_TopicRepositoriesArgs = {
  affiliations?: InputMaybe<Array<InputMaybe<Github_RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  isLocked?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_RepositoryOrder>;
  ownerAffiliations?: InputMaybe<Array<InputMaybe<Github_RepositoryAffiliation>>>;
  privacy?: InputMaybe<Github_RepositoryPrivacy>;
  sponsorableOnly?: InputMaybe<Scalars['Boolean']>;
};


/** A topic aggregates entities that are related to a subject. */
export type Github_TopicStargazersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_StarOrder>;
};

/** Metadata for an audit entry with a topic. */
export type Github_TopicAuditEntryData = {
  /** The name of the topic added to the repository */
  topic?: Maybe<Github_Topic>;
  /** The name of the topic added to the repository */
  topicName?: Maybe<Scalars['String']>;
};

/** Github_TopicAuditEntryData mock concrete type. */
export type Github_TopicAuditEntryData__Mock = Github_TopicAuditEntryData & {
  __typename?: 'Github_TopicAuditEntryData__Mock';
  /** The name of the topic added to the repository */
  topic?: Maybe<Github_Topic>;
  /** The name of the topic added to the repository */
  topicName?: Maybe<Scalars['String']>;
};

/** Reason that the suggested topic is declined. */
export enum Github_TopicSuggestionDeclineReason {
  /** The suggested topic is not relevant to the repository. */
  NotRelevant = 'NOT_RELEVANT',
  /** The viewer does not like the suggested topic. */
  PersonalPreference = 'PERSONAL_PREFERENCE',
  /** The suggested topic is too general for the repository. */
  TooGeneral = 'TOO_GENERAL',
  /** The suggested topic is too specific for the repository (e.g. #ruby-on-rails-version-4-2-1). */
  TooSpecific = 'TOO_SPECIFIC'
}

/** Autogenerated input type of TransferIssue */
export type Github_TransferIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the issue to be transferred */
  issueId: Scalars['ID'];
  /** The Node ID of the repository the issue should be transferred to */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of TransferIssue */
export type Github_TransferIssuePayload = {
  __typename?: 'Github_TransferIssuePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The issue that was transferred */
  issue?: Maybe<Github_Issue>;
};

/** Represents a 'transferred' event on a given issue or pull request. */
export type Github_TransferredEvent = Github_Node & {
  __typename?: 'Github_TransferredEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The repository this came from */
  fromRepository?: Maybe<Github_Repository>;
  id: Scalars['ID'];
  /** Identifies the issue associated with the event. */
  issue: Github_Issue;
};

/** Represents a Git tree. */
export type Github_Tree = Github_GitObject & Github_Node & {
  __typename?: 'Github_Tree';
  /** An abbreviated version of the Git object ID */
  abbreviatedOid: Scalars['String'];
  /** The HTTP path for this Git object */
  commitResourcePath: Scalars['Github_URI'];
  /** The HTTP URL for this Git object */
  commitUrl: Scalars['Github_URI'];
  /** A list of tree entries. */
  entries?: Maybe<Array<Github_TreeEntry>>;
  id: Scalars['ID'];
  /** The Git object ID */
  oid: Scalars['Github_GitObjectID'];
  /** The Repository the Git object belongs to */
  repository: Github_Repository;
};

/** Represents a Git tree entry. */
export type Github_TreeEntry = {
  __typename?: 'Github_TreeEntry';
  /** The extension of the file */
  extension?: Maybe<Scalars['String']>;
  /** Whether or not this tree entry is generated */
  isGenerated: Scalars['Boolean'];
  /** Entry file mode. */
  mode: Scalars['Int'];
  /** Entry file name. */
  name: Scalars['String'];
  /** Entry file object. */
  object?: Maybe<Github_GitObject>;
  /** Entry file Git object ID. */
  oid: Scalars['Github_GitObjectID'];
  /** The full path of the file. */
  path?: Maybe<Scalars['String']>;
  /** The Repository the tree entry belongs to */
  repository: Github_Repository;
  /** If the TreeEntry is for a directory occupied by a submodule project, this returns the corresponding submodule */
  submodule?: Maybe<Github_Submodule>;
  /** Entry file type. */
  type: Scalars['String'];
};

/** Autogenerated input type of UnarchiveRepository */
export type Github_UnarchiveRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the repository to unarchive. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of UnarchiveRepository */
export type Github_UnarchiveRepositoryPayload = {
  __typename?: 'Github_UnarchiveRepositoryPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The repository that was unarchived. */
  repository?: Maybe<Github_Repository>;
};

/** Represents an 'unassigned' event on any assignable object. */
export type Github_UnassignedEvent = Github_Node & {
  __typename?: 'Github_UnassignedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the assignable associated with the event. */
  assignable: Github_Assignable;
  /** Identifies the user or mannequin that was unassigned. */
  assignee?: Maybe<Github_Assignee>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /**
   * Identifies the subject (user) who was unassigned.
   * @deprecated Assignees can now be mannequins. Use the `assignee` field instead. Removal on 2020-01-01 UTC.
   */
  user?: Maybe<Github_User>;
};

/** Autogenerated input type of UnfollowUser */
export type Github_UnfollowUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the user to unfollow. */
  userId: Scalars['ID'];
};

/** Autogenerated return type of UnfollowUser */
export type Github_UnfollowUserPayload = {
  __typename?: 'Github_UnfollowUserPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The user that was unfollowed. */
  user?: Maybe<Github_User>;
};

/** Represents a type that can be retrieved by a URL. */
export type Github_UniformResourceLocatable = {
  /** The HTML path to this resource. */
  resourcePath: Scalars['Github_URI'];
  /** The URL to this resource. */
  url: Scalars['Github_URI'];
};

/** Github_UniformResourceLocatable mock concrete type. */
export type Github_UniformResourceLocatable__Mock = Github_UniformResourceLocatable & {
  __typename?: 'Github_UniformResourceLocatable__Mock';
  /** The HTML path to this resource. */
  resourcePath: Scalars['Github_URI'];
  /** The URL to this resource. */
  url: Scalars['Github_URI'];
};

/** Represents an unknown signature on a Commit or Tag. */
export type Github_UnknownSignature = Github_GitSignature & {
  __typename?: 'Github_UnknownSignature';
  /** Email used to sign this object. */
  email: Scalars['String'];
  /** True if the signature is valid and verified by GitHub. */
  isValid: Scalars['Boolean'];
  /** Payload for GPG signing object. Raw ODB object without the signature header. */
  payload: Scalars['String'];
  /** ASCII-armored signature header from object. */
  signature: Scalars['String'];
  /** GitHub user corresponding to the email signing this commit. */
  signer?: Maybe<Github_User>;
  /**
   * The state of this signature. `VALID` if signature is valid and verified by
   * GitHub, otherwise represents reason why signature is considered invalid.
   */
  state: Github_GitSignatureState;
  /** True if the signature was made with GitHub's signing key. */
  wasSignedByGitHub: Scalars['Boolean'];
};

/** Represents an 'unlabeled' event on a given issue or pull request. */
export type Github_UnlabeledEvent = Github_Node & {
  __typename?: 'Github_UnlabeledEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Identifies the label associated with the 'unlabeled' event. */
  label: Github_Label;
  /** Identifies the `Labelable` associated with the event. */
  labelable: Github_Labelable;
};

/** Autogenerated input type of UnlinkRepositoryFromProject */
export type Github_UnlinkRepositoryFromProjectInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the Project linked to the Repository. */
  projectId: Scalars['ID'];
  /** The ID of the Repository linked to the Project. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of UnlinkRepositoryFromProject */
export type Github_UnlinkRepositoryFromProjectPayload = {
  __typename?: 'Github_UnlinkRepositoryFromProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The linked Project. */
  project?: Maybe<Github_Project>;
  /** The linked Repository. */
  repository?: Maybe<Github_Repository>;
};

/** Autogenerated input type of UnlockLockable */
export type Github_UnlockLockableInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the item to be unlocked. */
  lockableId: Scalars['ID'];
};

/** Autogenerated return type of UnlockLockable */
export type Github_UnlockLockablePayload = {
  __typename?: 'Github_UnlockLockablePayload';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The item that was unlocked. */
  unlockedRecord?: Maybe<Github_Lockable>;
};

/** Represents an 'unlocked' event on a given issue or pull request. */
export type Github_UnlockedEvent = Github_Node & {
  __typename?: 'Github_UnlockedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Object that was unlocked. */
  lockable: Github_Lockable;
};

/** Autogenerated input type of UnmarkDiscussionCommentAsAnswer */
export type Github_UnmarkDiscussionCommentAsAnswerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the discussion comment to unmark as an answer. */
  id: Scalars['ID'];
};

/** Autogenerated return type of UnmarkDiscussionCommentAsAnswer */
export type Github_UnmarkDiscussionCommentAsAnswerPayload = {
  __typename?: 'Github_UnmarkDiscussionCommentAsAnswerPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The discussion that includes the comment. */
  discussion?: Maybe<Github_Discussion>;
};

/** Autogenerated input type of UnmarkFileAsViewed */
export type Github_UnmarkFileAsViewedInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The path of the file to mark as unviewed */
  path: Scalars['String'];
  /** The Node ID of the pull request. */
  pullRequestId: Scalars['ID'];
};

/** Autogenerated return type of UnmarkFileAsViewed */
export type Github_UnmarkFileAsViewedPayload = {
  __typename?: 'Github_UnmarkFileAsViewedPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated pull request. */
  pullRequest?: Maybe<Github_PullRequest>;
};

/** Autogenerated input type of UnmarkIssueAsDuplicate */
export type Github_UnmarkIssueAsDuplicateInput = {
  /** ID of the issue or pull request currently considered canonical/authoritative/original. */
  canonicalId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** ID of the issue or pull request currently marked as a duplicate. */
  duplicateId: Scalars['ID'];
};

/** Autogenerated return type of UnmarkIssueAsDuplicate */
export type Github_UnmarkIssueAsDuplicatePayload = {
  __typename?: 'Github_UnmarkIssueAsDuplicatePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The issue or pull request that was marked as a duplicate. */
  duplicate?: Maybe<Github_IssueOrPullRequest>;
};

/** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */
export type Github_UnmarkedAsDuplicateEvent = Github_Node & {
  __typename?: 'Github_UnmarkedAsDuplicateEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** The authoritative issue or pull request which has been duplicated by another. */
  canonical?: Maybe<Github_IssueOrPullRequest>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** The issue or pull request which has been marked as a duplicate of another. */
  duplicate?: Maybe<Github_IssueOrPullRequest>;
  id: Scalars['ID'];
  /** Canonical and duplicate belong to different repositories. */
  isCrossRepository: Scalars['Boolean'];
};

/** Autogenerated input type of UnminimizeComment */
export type Github_UnminimizeCommentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the subject to modify. */
  subjectId: Scalars['ID'];
};

/** Autogenerated return type of UnminimizeComment */
export type Github_UnminimizeCommentPayload = {
  __typename?: 'Github_UnminimizeCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The comment that was unminimized. */
  unminimizedComment?: Maybe<Github_Minimizable>;
};

/** Autogenerated input type of UnpinIssue */
export type Github_UnpinIssueInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the issue to be unpinned */
  issueId: Scalars['ID'];
};

/** Autogenerated return type of UnpinIssue */
export type Github_UnpinIssuePayload = {
  __typename?: 'Github_UnpinIssuePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The issue that was unpinned */
  issue?: Maybe<Github_Issue>;
};

/** Represents an 'unpinned' event on a given issue or pull request. */
export type Github_UnpinnedEvent = Github_Node & {
  __typename?: 'Github_UnpinnedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Identifies the issue associated with the event. */
  issue: Github_Issue;
};

/** Autogenerated input type of UnresolveReviewThread */
export type Github_UnresolveReviewThreadInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the thread to unresolve */
  threadId: Scalars['ID'];
};

/** Autogenerated return type of UnresolveReviewThread */
export type Github_UnresolveReviewThreadPayload = {
  __typename?: 'Github_UnresolveReviewThreadPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The thread to resolve. */
  thread?: Maybe<Github_PullRequestReviewThread>;
};

/** Represents an 'unsubscribed' event on a given `Subscribable`. */
export type Github_UnsubscribedEvent = Github_Node & {
  __typename?: 'Github_UnsubscribedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** Object referenced by event. */
  subscribable: Github_Subscribable;
};

/** Entities that can be updated. */
export type Github_Updatable = {
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
};

/** Comments that can be updated. */
export type Github_UpdatableComment = {
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<Github_CommentCannotUpdateReason>;
};

/** Github_UpdatableComment mock concrete type. */
export type Github_UpdatableComment__Mock = Github_UpdatableComment & {
  __typename?: 'Github_UpdatableComment__Mock';
  /** Reasons why the current viewer can not update this comment. */
  viewerCannotUpdateReasons: Array<Github_CommentCannotUpdateReason>;
};

/** Github_Updatable mock concrete type. */
export type Github_Updatable__Mock = Github_Updatable & {
  __typename?: 'Github_Updatable__Mock';
  /** Check if the current viewer can update this object. */
  viewerCanUpdate: Scalars['Boolean'];
};

/** Autogenerated input type of UpdateBranchProtectionRule */
export type Github_UpdateBranchProtectionRuleInput = {
  /** Can this branch be deleted. */
  allowsDeletions?: InputMaybe<Scalars['Boolean']>;
  /** Are force pushes allowed on this branch. */
  allowsForcePushes?: InputMaybe<Scalars['Boolean']>;
  /** The global relay id of the branch protection rule to be updated. */
  branchProtectionRuleId: Scalars['ID'];
  /** A list of User or Team IDs allowed to bypass force push targeting matching branches. */
  bypassForcePushActorIds?: InputMaybe<Array<Scalars['ID']>>;
  /** A list of User or Team IDs allowed to bypass pull requests targeting matching branches. */
  bypassPullRequestActorIds?: InputMaybe<Array<Scalars['ID']>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Will new commits pushed to matching branches dismiss pull request review approvals. */
  dismissesStaleReviews?: InputMaybe<Scalars['Boolean']>;
  /** Can admins overwrite branch protection. */
  isAdminEnforced?: InputMaybe<Scalars['Boolean']>;
  /** The glob-like pattern used to determine matching branches. */
  pattern?: InputMaybe<Scalars['String']>;
  /** A list of User, Team or App IDs allowed to push to matching branches. */
  pushActorIds?: InputMaybe<Array<Scalars['ID']>>;
  /** Number of approving reviews required to update matching branches. */
  requiredApprovingReviewCount?: InputMaybe<Scalars['Int']>;
  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */
  requiredStatusCheckContexts?: InputMaybe<Array<Scalars['String']>>;
  /** The list of required status checks */
  requiredStatusChecks?: InputMaybe<Array<Github_RequiredStatusCheckInput>>;
  /** Are approving reviews required to update matching branches. */
  requiresApprovingReviews?: InputMaybe<Scalars['Boolean']>;
  /** Are reviews from code owners required to update matching branches. */
  requiresCodeOwnerReviews?: InputMaybe<Scalars['Boolean']>;
  /** Are commits required to be signed. */
  requiresCommitSignatures?: InputMaybe<Scalars['Boolean']>;
  /** Are conversations required to be resolved before merging. */
  requiresConversationResolution?: InputMaybe<Scalars['Boolean']>;
  /** Are merge commits prohibited from being pushed to this branch. */
  requiresLinearHistory?: InputMaybe<Scalars['Boolean']>;
  /** Are status checks required to update matching branches. */
  requiresStatusChecks?: InputMaybe<Scalars['Boolean']>;
  /** Are branches required to be up to date before merging. */
  requiresStrictStatusChecks?: InputMaybe<Scalars['Boolean']>;
  /** Is pushing to matching branches restricted. */
  restrictsPushes?: InputMaybe<Scalars['Boolean']>;
  /** Is dismissal of pull request reviews restricted. */
  restrictsReviewDismissals?: InputMaybe<Scalars['Boolean']>;
  /** A list of User or Team IDs allowed to dismiss reviews on pull requests targeting matching branches. */
  reviewDismissalActorIds?: InputMaybe<Array<Scalars['ID']>>;
};

/** Autogenerated return type of UpdateBranchProtectionRule */
export type Github_UpdateBranchProtectionRulePayload = {
  __typename?: 'Github_UpdateBranchProtectionRulePayload';
  /** The newly created BranchProtectionRule. */
  branchProtectionRule?: Maybe<Github_BranchProtectionRule>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateCheckRun */
export type Github_UpdateCheckRunInput = {
  /** Possible further actions the integrator can perform, which a user may trigger. */
  actions?: InputMaybe<Array<Github_CheckRunAction>>;
  /** The node of the check. */
  checkRunId: Scalars['ID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The time that the check run finished. */
  completedAt?: InputMaybe<Scalars['DateTime']>;
  /** The final conclusion of the check. */
  conclusion?: InputMaybe<Github_CheckConclusionState>;
  /** The URL of the integrator's site that has the full details of the check. */
  detailsUrl?: InputMaybe<Scalars['Github_URI']>;
  /** A reference for the run on the integrator's system. */
  externalId?: InputMaybe<Scalars['String']>;
  /** The name of the check. */
  name?: InputMaybe<Scalars['String']>;
  /** Descriptive details about the run. */
  output?: InputMaybe<Github_CheckRunOutput>;
  /** The node ID of the repository. */
  repositoryId: Scalars['ID'];
  /** The time that the check run began. */
  startedAt?: InputMaybe<Scalars['DateTime']>;
  /** The current status. */
  status?: InputMaybe<Github_RequestableCheckStatusState>;
};

/** Autogenerated return type of UpdateCheckRun */
export type Github_UpdateCheckRunPayload = {
  __typename?: 'Github_UpdateCheckRunPayload';
  /** The updated check run. */
  checkRun?: Maybe<Github_CheckRun>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateCheckSuitePreferences */
export type Github_UpdateCheckSuitePreferencesInput = {
  /** The check suite preferences to modify. */
  autoTriggerPreferences: Array<Github_CheckSuiteAutoTriggerPreference>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of UpdateCheckSuitePreferences */
export type Github_UpdateCheckSuitePreferencesPayload = {
  __typename?: 'Github_UpdateCheckSuitePreferencesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated repository. */
  repository?: Maybe<Github_Repository>;
};

/** Autogenerated input type of UpdateDiscussionComment */
export type Github_UpdateDiscussionCommentInput = {
  /** The new contents of the comment body. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the discussion comment to update. */
  commentId: Scalars['ID'];
};

/** Autogenerated return type of UpdateDiscussionComment */
export type Github_UpdateDiscussionCommentPayload = {
  __typename?: 'Github_UpdateDiscussionCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The modified discussion comment. */
  comment?: Maybe<Github_DiscussionComment>;
};

/** Autogenerated input type of UpdateDiscussion */
export type Github_UpdateDiscussionInput = {
  /** The new contents of the discussion body. */
  body?: InputMaybe<Scalars['String']>;
  /** The Node ID of a discussion category within the same repository to change this discussion to. */
  categoryId?: InputMaybe<Scalars['ID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the discussion to update. */
  discussionId: Scalars['ID'];
  /** The new discussion title. */
  title?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateDiscussion */
export type Github_UpdateDiscussionPayload = {
  __typename?: 'Github_UpdateDiscussionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The modified discussion. */
  discussion?: Maybe<Github_Discussion>;
};

/** Autogenerated input type of UpdateEnterpriseAdministratorRole */
export type Github_UpdateEnterpriseAdministratorRoleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the Enterprise which the admin belongs to. */
  enterpriseId: Scalars['ID'];
  /** The login of a administrator whose role is being changed. */
  login: Scalars['String'];
  /** The new role for the Enterprise administrator. */
  role: Github_EnterpriseAdministratorRole;
};

/** Autogenerated return type of UpdateEnterpriseAdministratorRole */
export type Github_UpdateEnterpriseAdministratorRolePayload = {
  __typename?: 'Github_UpdateEnterpriseAdministratorRolePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A message confirming the result of changing the administrator's role. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseAllowPrivateRepositoryForkingSetting */
export type Github_UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the allow private repository forking setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the allow private repository forking setting on the enterprise. */
  settingValue: Github_EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseAllowPrivateRepositoryForkingSetting */
export type Github_UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload = {
  __typename?: 'Github_UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated allow private repository forking setting. */
  enterprise?: Maybe<Github_Enterprise>;
  /** A message confirming the result of updating the allow private repository forking setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseDefaultRepositoryPermissionSetting */
export type Github_UpdateEnterpriseDefaultRepositoryPermissionSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the base repository permission setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the base repository permission setting on the enterprise. */
  settingValue: Github_EnterpriseDefaultRepositoryPermissionSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseDefaultRepositoryPermissionSetting */
export type Github_UpdateEnterpriseDefaultRepositoryPermissionSettingPayload = {
  __typename?: 'Github_UpdateEnterpriseDefaultRepositoryPermissionSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated base repository permission setting. */
  enterprise?: Maybe<Github_Enterprise>;
  /** A message confirming the result of updating the base repository permission setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanChangeRepositoryVisibilitySetting */
export type Github_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the members can change repository visibility setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the members can change repository visibility setting on the enterprise. */
  settingValue: Github_EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanChangeRepositoryVisibilitySetting */
export type Github_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload = {
  __typename?: 'Github_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated members can change repository visibility setting. */
  enterprise?: Maybe<Github_Enterprise>;
  /** A message confirming the result of updating the members can change repository visibility setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanCreateRepositoriesSetting */
export type Github_UpdateEnterpriseMembersCanCreateRepositoriesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the members can create repositories setting. */
  enterpriseId: Scalars['ID'];
  /** Allow members to create internal repositories. Defaults to current value. */
  membersCanCreateInternalRepositories?: InputMaybe<Scalars['Boolean']>;
  /** Allow members to create private repositories. Defaults to current value. */
  membersCanCreatePrivateRepositories?: InputMaybe<Scalars['Boolean']>;
  /** Allow members to create public repositories. Defaults to current value. */
  membersCanCreatePublicRepositories?: InputMaybe<Scalars['Boolean']>;
  /** When false, allow member organizations to set their own repository creation member privileges. */
  membersCanCreateRepositoriesPolicyEnabled?: InputMaybe<Scalars['Boolean']>;
  /**
   * Value for the members can create repositories setting on the enterprise. This
   * or the granular public/private/internal allowed fields (but not both) must be provided.
   */
  settingValue?: InputMaybe<Github_EnterpriseMembersCanCreateRepositoriesSettingValue>;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanCreateRepositoriesSetting */
export type Github_UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload = {
  __typename?: 'Github_UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated members can create repositories setting. */
  enterprise?: Maybe<Github_Enterprise>;
  /** A message confirming the result of updating the members can create repositories setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanDeleteIssuesSetting */
export type Github_UpdateEnterpriseMembersCanDeleteIssuesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the members can delete issues setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the members can delete issues setting on the enterprise. */
  settingValue: Github_EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanDeleteIssuesSetting */
export type Github_UpdateEnterpriseMembersCanDeleteIssuesSettingPayload = {
  __typename?: 'Github_UpdateEnterpriseMembersCanDeleteIssuesSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated members can delete issues setting. */
  enterprise?: Maybe<Github_Enterprise>;
  /** A message confirming the result of updating the members can delete issues setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanDeleteRepositoriesSetting */
export type Github_UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the members can delete repositories setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the members can delete repositories setting on the enterprise. */
  settingValue: Github_EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanDeleteRepositoriesSetting */
export type Github_UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload = {
  __typename?: 'Github_UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated members can delete repositories setting. */
  enterprise?: Maybe<Github_Enterprise>;
  /** A message confirming the result of updating the members can delete repositories setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanInviteCollaboratorsSetting */
export type Github_UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the members can invite collaborators setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the members can invite collaborators setting on the enterprise. */
  settingValue: Github_EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanInviteCollaboratorsSetting */
export type Github_UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload = {
  __typename?: 'Github_UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated members can invite collaborators setting. */
  enterprise?: Maybe<Github_Enterprise>;
  /** A message confirming the result of updating the members can invite collaborators setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanMakePurchasesSetting */
export type Github_UpdateEnterpriseMembersCanMakePurchasesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the members can make purchases setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the members can make purchases setting on the enterprise. */
  settingValue: Github_EnterpriseMembersCanMakePurchasesSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanMakePurchasesSetting */
export type Github_UpdateEnterpriseMembersCanMakePurchasesSettingPayload = {
  __typename?: 'Github_UpdateEnterpriseMembersCanMakePurchasesSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated members can make purchases setting. */
  enterprise?: Maybe<Github_Enterprise>;
  /** A message confirming the result of updating the members can make purchases setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanUpdateProtectedBranchesSetting */
export type Github_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the members can update protected branches setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the members can update protected branches setting on the enterprise. */
  settingValue: Github_EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanUpdateProtectedBranchesSetting */
export type Github_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload = {
  __typename?: 'Github_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated members can update protected branches setting. */
  enterprise?: Maybe<Github_Enterprise>;
  /** A message confirming the result of updating the members can update protected branches setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseMembersCanViewDependencyInsightsSetting */
export type Github_UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the members can view dependency insights setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the members can view dependency insights setting on the enterprise. */
  settingValue: Github_EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseMembersCanViewDependencyInsightsSetting */
export type Github_UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload = {
  __typename?: 'Github_UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated members can view dependency insights setting. */
  enterprise?: Maybe<Github_Enterprise>;
  /** A message confirming the result of updating the members can view dependency insights setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseOrganizationProjectsSetting */
export type Github_UpdateEnterpriseOrganizationProjectsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the organization projects setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the organization projects setting on the enterprise. */
  settingValue: Github_EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseOrganizationProjectsSetting */
export type Github_UpdateEnterpriseOrganizationProjectsSettingPayload = {
  __typename?: 'Github_UpdateEnterpriseOrganizationProjectsSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated organization projects setting. */
  enterprise?: Maybe<Github_Enterprise>;
  /** A message confirming the result of updating the organization projects setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseProfile */
export type Github_UpdateEnterpriseProfileInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The description of the enterprise. */
  description?: InputMaybe<Scalars['String']>;
  /** The Enterprise ID to update. */
  enterpriseId: Scalars['ID'];
  /** The location of the enterprise. */
  location?: InputMaybe<Scalars['String']>;
  /** The name of the enterprise. */
  name?: InputMaybe<Scalars['String']>;
  /** The URL of the enterprise's website. */
  websiteUrl?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateEnterpriseProfile */
export type Github_UpdateEnterpriseProfilePayload = {
  __typename?: 'Github_UpdateEnterpriseProfilePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated enterprise. */
  enterprise?: Maybe<Github_Enterprise>;
};

/** Autogenerated input type of UpdateEnterpriseRepositoryProjectsSetting */
export type Github_UpdateEnterpriseRepositoryProjectsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the repository projects setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the repository projects setting on the enterprise. */
  settingValue: Github_EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseRepositoryProjectsSetting */
export type Github_UpdateEnterpriseRepositoryProjectsSettingPayload = {
  __typename?: 'Github_UpdateEnterpriseRepositoryProjectsSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated repository projects setting. */
  enterprise?: Maybe<Github_Enterprise>;
  /** A message confirming the result of updating the repository projects setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseTeamDiscussionsSetting */
export type Github_UpdateEnterpriseTeamDiscussionsSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the team discussions setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the team discussions setting on the enterprise. */
  settingValue: Github_EnterpriseEnabledDisabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseTeamDiscussionsSetting */
export type Github_UpdateEnterpriseTeamDiscussionsSettingPayload = {
  __typename?: 'Github_UpdateEnterpriseTeamDiscussionsSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated team discussions setting. */
  enterprise?: Maybe<Github_Enterprise>;
  /** A message confirming the result of updating the team discussions setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnterpriseTwoFactorAuthenticationRequiredSetting */
export type Github_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the enterprise on which to set the two factor authentication required setting. */
  enterpriseId: Scalars['ID'];
  /** The value for the two factor authentication required setting on the enterprise. */
  settingValue: Github_EnterpriseEnabledSettingValue;
};

/** Autogenerated return type of UpdateEnterpriseTwoFactorAuthenticationRequiredSetting */
export type Github_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload = {
  __typename?: 'Github_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The enterprise with the updated two factor authentication required setting. */
  enterprise?: Maybe<Github_Enterprise>;
  /** A message confirming the result of updating the two factor authentication required setting. */
  message?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateEnvironment */
export type Github_UpdateEnvironmentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The node ID of the environment. */
  environmentId: Scalars['ID'];
  /** The ids of users or teams that can approve deployments to this environment */
  reviewers?: InputMaybe<Array<Scalars['ID']>>;
  /** The wait timer in minutes. */
  waitTimer?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of UpdateEnvironment */
export type Github_UpdateEnvironmentPayload = {
  __typename?: 'Github_UpdateEnvironmentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated environment. */
  environment?: Maybe<Github_Environment>;
};

/** Autogenerated input type of UpdateIpAllowListEnabledSetting */
export type Github_UpdateIpAllowListEnabledSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the owner on which to set the IP allow list enabled setting. */
  ownerId: Scalars['ID'];
  /** The value for the IP allow list enabled setting. */
  settingValue: Github_IpAllowListEnabledSettingValue;
};

/** Autogenerated return type of UpdateIpAllowListEnabledSetting */
export type Github_UpdateIpAllowListEnabledSettingPayload = {
  __typename?: 'Github_UpdateIpAllowListEnabledSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The IP allow list owner on which the setting was updated. */
  owner?: Maybe<Github_IpAllowListOwner>;
};

/** Autogenerated input type of UpdateIpAllowListEntry */
export type Github_UpdateIpAllowListEntryInput = {
  /** An IP address or range of addresses in CIDR notation. */
  allowListValue: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the IP allow list entry to update. */
  ipAllowListEntryId: Scalars['ID'];
  /** Whether the IP allow list entry is active when an IP allow list is enabled. */
  isActive: Scalars['Boolean'];
  /** An optional name for the IP allow list entry. */
  name?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateIpAllowListEntry */
export type Github_UpdateIpAllowListEntryPayload = {
  __typename?: 'Github_UpdateIpAllowListEntryPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The IP allow list entry that was updated. */
  ipAllowListEntry?: Maybe<Github_IpAllowListEntry>;
};

/** Autogenerated input type of UpdateIpAllowListForInstalledAppsEnabledSetting */
export type Github_UpdateIpAllowListForInstalledAppsEnabledSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the owner. */
  ownerId: Scalars['ID'];
  /** The value for the IP allow list configuration for installed GitHub Apps setting. */
  settingValue: Github_IpAllowListForInstalledAppsEnabledSettingValue;
};

/** Autogenerated return type of UpdateIpAllowListForInstalledAppsEnabledSetting */
export type Github_UpdateIpAllowListForInstalledAppsEnabledSettingPayload = {
  __typename?: 'Github_UpdateIpAllowListForInstalledAppsEnabledSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The IP allow list owner on which the setting was updated. */
  owner?: Maybe<Github_IpAllowListOwner>;
};

/** Autogenerated input type of UpdateIssueComment */
export type Github_UpdateIssueCommentInput = {
  /** The updated text of the comment. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the IssueComment to modify. */
  id: Scalars['ID'];
};

/** Autogenerated return type of UpdateIssueComment */
export type Github_UpdateIssueCommentPayload = {
  __typename?: 'Github_UpdateIssueCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated comment. */
  issueComment?: Maybe<Github_IssueComment>;
};

/** Autogenerated input type of UpdateIssue */
export type Github_UpdateIssueInput = {
  /** An array of Node IDs of users for this issue. */
  assigneeIds?: InputMaybe<Array<Scalars['ID']>>;
  /** The body for the issue description. */
  body?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the Issue to modify. */
  id: Scalars['ID'];
  /** An array of Node IDs of labels for this issue. */
  labelIds?: InputMaybe<Array<Scalars['ID']>>;
  /** The Node ID of the milestone for this issue. */
  milestoneId?: InputMaybe<Scalars['ID']>;
  /** An array of Node IDs for projects associated with this issue. */
  projectIds?: InputMaybe<Array<Scalars['ID']>>;
  /** The desired issue state. */
  state?: InputMaybe<Github_IssueState>;
  /** The title for the issue. */
  title?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateIssue */
export type Github_UpdateIssuePayload = {
  __typename?: 'Github_UpdateIssuePayload';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The issue. */
  issue?: Maybe<Github_Issue>;
};

/** Autogenerated input type of UpdateLabel */
export type Github_UpdateLabelInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** A 6 character hex code, without the leading #, identifying the updated color of the label. */
  color?: InputMaybe<Scalars['String']>;
  /** A brief description of the label, such as its purpose. */
  description?: InputMaybe<Scalars['String']>;
  /** The Node ID of the label to be updated. */
  id: Scalars['ID'];
  /** The updated name of the label. */
  name?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateLabel */
export type Github_UpdateLabelPayload = {
  __typename?: 'Github_UpdateLabelPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated label. */
  label?: Maybe<Github_Label>;
};

/** Autogenerated input type of UpdateNotificationRestrictionSetting */
export type Github_UpdateNotificationRestrictionSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the owner on which to set the restrict notifications setting. */
  ownerId: Scalars['ID'];
  /** The value for the restrict notifications setting. */
  settingValue: Github_NotificationRestrictionSettingValue;
};

/** Autogenerated return type of UpdateNotificationRestrictionSetting */
export type Github_UpdateNotificationRestrictionSettingPayload = {
  __typename?: 'Github_UpdateNotificationRestrictionSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The owner on which the setting was updated. */
  owner?: Maybe<Github_VerifiableDomainOwner>;
};

/** Autogenerated input type of UpdateOrganizationAllowPrivateRepositoryForkingSetting */
export type Github_UpdateOrganizationAllowPrivateRepositoryForkingSettingInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Enable forking of private repositories in the organization? */
  forkingEnabled: Scalars['Boolean'];
  /** The ID of the organization on which to set the allow private repository forking setting. */
  organizationId: Scalars['ID'];
};

/** Autogenerated return type of UpdateOrganizationAllowPrivateRepositoryForkingSetting */
export type Github_UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload = {
  __typename?: 'Github_UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** A message confirming the result of updating the allow private repository forking setting. */
  message?: Maybe<Scalars['String']>;
  /** The organization with the updated allow private repository forking setting. */
  organization?: Maybe<Github_Organization>;
};

/** Autogenerated input type of UpdateProjectCard */
export type Github_UpdateProjectCardInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Whether or not the ProjectCard should be archived */
  isArchived?: InputMaybe<Scalars['Boolean']>;
  /** The note of ProjectCard. */
  note?: InputMaybe<Scalars['String']>;
  /** The ProjectCard ID to update. */
  projectCardId: Scalars['ID'];
};

/** Autogenerated return type of UpdateProjectCard */
export type Github_UpdateProjectCardPayload = {
  __typename?: 'Github_UpdateProjectCardPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated ProjectCard. */
  projectCard?: Maybe<Github_ProjectCard>;
};

/** Autogenerated input type of UpdateProjectColumn */
export type Github_UpdateProjectColumnInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The name of project column. */
  name: Scalars['String'];
  /** The ProjectColumn ID to update. */
  projectColumnId: Scalars['ID'];
};

/** Autogenerated return type of UpdateProjectColumn */
export type Github_UpdateProjectColumnPayload = {
  __typename?: 'Github_UpdateProjectColumnPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated project column. */
  projectColumn?: Maybe<Github_ProjectColumn>;
};

/** Autogenerated input type of UpdateProject */
export type Github_UpdateProjectInput = {
  /** The description of project. */
  body?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The name of project. */
  name?: InputMaybe<Scalars['String']>;
  /** The Project ID to update. */
  projectId: Scalars['ID'];
  /** Whether the project is public or not. */
  public?: InputMaybe<Scalars['Boolean']>;
  /** Whether the project is open or closed. */
  state?: InputMaybe<Github_ProjectState>;
};

/** Autogenerated input type of UpdateProjectNextItemField */
export type Github_UpdateProjectNextItemFieldInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The id of the field to be updated. Only supports custom fields and status for now. */
  fieldId: Scalars['ID'];
  /** The id of the item to be updated. */
  itemId: Scalars['ID'];
  /** The ID of the Project. */
  projectId: Scalars['ID'];
  /** The value which will be set on the field. */
  value: Scalars['String'];
};

/** Autogenerated return type of UpdateProjectNextItemField */
export type Github_UpdateProjectNextItemFieldPayload = {
  __typename?: 'Github_UpdateProjectNextItemFieldPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated item. */
  projectNextItem?: Maybe<Github_ProjectNextItem>;
};

/** Autogenerated return type of UpdateProject */
export type Github_UpdateProjectPayload = {
  __typename?: 'Github_UpdateProjectPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated project. */
  project?: Maybe<Github_Project>;
};

/** Autogenerated input type of UpdatePullRequestBranch */
export type Github_UpdatePullRequestBranchInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The head ref oid for the upstream branch. */
  expectedHeadOid?: InputMaybe<Scalars['Github_GitObjectID']>;
  /** The Node ID of the pull request. */
  pullRequestId: Scalars['ID'];
};

/** Autogenerated return type of UpdatePullRequestBranch */
export type Github_UpdatePullRequestBranchPayload = {
  __typename?: 'Github_UpdatePullRequestBranchPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated pull request. */
  pullRequest?: Maybe<Github_PullRequest>;
};

/** Autogenerated input type of UpdatePullRequest */
export type Github_UpdatePullRequestInput = {
  /** An array of Node IDs of users for this pull request. */
  assigneeIds?: InputMaybe<Array<Scalars['ID']>>;
  /**
   * The name of the branch you want your changes pulled into. This should be an existing branch
   * on the current repository.
   */
  baseRefName?: InputMaybe<Scalars['String']>;
  /** The contents of the pull request. */
  body?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** An array of Node IDs of labels for this pull request. */
  labelIds?: InputMaybe<Array<Scalars['ID']>>;
  /** Indicates whether maintainers can modify the pull request. */
  maintainerCanModify?: InputMaybe<Scalars['Boolean']>;
  /** The Node ID of the milestone for this pull request. */
  milestoneId?: InputMaybe<Scalars['ID']>;
  /** An array of Node IDs for projects associated with this pull request. */
  projectIds?: InputMaybe<Array<Scalars['ID']>>;
  /** The Node ID of the pull request. */
  pullRequestId: Scalars['ID'];
  /** The target state of the pull request. */
  state?: InputMaybe<Github_PullRequestUpdateState>;
  /** The title of the pull request. */
  title?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of UpdatePullRequest */
export type Github_UpdatePullRequestPayload = {
  __typename?: 'Github_UpdatePullRequestPayload';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated pull request. */
  pullRequest?: Maybe<Github_PullRequest>;
};

/** Autogenerated input type of UpdatePullRequestReviewComment */
export type Github_UpdatePullRequestReviewCommentInput = {
  /** The text of the comment. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the comment to modify. */
  pullRequestReviewCommentId: Scalars['ID'];
};

/** Autogenerated return type of UpdatePullRequestReviewComment */
export type Github_UpdatePullRequestReviewCommentPayload = {
  __typename?: 'Github_UpdatePullRequestReviewCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated comment. */
  pullRequestReviewComment?: Maybe<Github_PullRequestReviewComment>;
};

/** Autogenerated input type of UpdatePullRequestReview */
export type Github_UpdatePullRequestReviewInput = {
  /** The contents of the pull request review body. */
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the pull request review to modify. */
  pullRequestReviewId: Scalars['ID'];
};

/** Autogenerated return type of UpdatePullRequestReview */
export type Github_UpdatePullRequestReviewPayload = {
  __typename?: 'Github_UpdatePullRequestReviewPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated pull request review. */
  pullRequestReview?: Maybe<Github_PullRequestReview>;
};

/** Autogenerated input type of UpdateRef */
export type Github_UpdateRefInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Permit updates of branch Refs that are not fast-forwards? */
  force?: InputMaybe<Scalars['Boolean']>;
  /** The GitObjectID that the Ref shall be updated to target. */
  oid: Scalars['Github_GitObjectID'];
  /** The Node ID of the Ref to be updated. */
  refId: Scalars['ID'];
};

/** Autogenerated return type of UpdateRef */
export type Github_UpdateRefPayload = {
  __typename?: 'Github_UpdateRefPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated Ref. */
  ref?: Maybe<Github_Ref>;
};

/** Autogenerated input type of UpdateRefs */
export type Github_UpdateRefsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** A list of ref updates. */
  refUpdates: Array<Github_RefUpdate>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
};

/** Autogenerated return type of UpdateRefs */
export type Github_UpdateRefsPayload = {
  __typename?: 'Github_UpdateRefsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateRepository */
export type Github_UpdateRepositoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** A new description for the repository. Pass an empty string to erase the existing description. */
  description?: InputMaybe<Scalars['String']>;
  /** Indicates if the repository should have the issues feature enabled. */
  hasIssuesEnabled?: InputMaybe<Scalars['Boolean']>;
  /** Indicates if the repository should have the project boards feature enabled. */
  hasProjectsEnabled?: InputMaybe<Scalars['Boolean']>;
  /** Indicates if the repository should have the wiki feature enabled. */
  hasWikiEnabled?: InputMaybe<Scalars['Boolean']>;
  /** The URL for a web page about this repository. Pass an empty string to erase the existing URL. */
  homepageUrl?: InputMaybe<Scalars['Github_URI']>;
  /** The new name of the repository. */
  name?: InputMaybe<Scalars['String']>;
  /** The ID of the repository to update. */
  repositoryId: Scalars['ID'];
  /**
   * Whether this repository should be marked as a template such that anyone who
   * can access it can create new repositories with the same files and directory structure.
   */
  template?: InputMaybe<Scalars['Boolean']>;
};

/** Autogenerated return type of UpdateRepository */
export type Github_UpdateRepositoryPayload = {
  __typename?: 'Github_UpdateRepositoryPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated repository. */
  repository?: Maybe<Github_Repository>;
};

/** Autogenerated input type of UpdateSponsorshipPreferences */
export type Github_UpdateSponsorshipPreferencesInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /**
   * Specify whether others should be able to see that the sponsor is sponsoring
   * the sponsorable. Public visibility still does not reveal which tier is used.
   */
  privacyLevel?: InputMaybe<Github_SponsorshipPrivacy>;
  /** Whether the sponsor should receive email updates from the sponsorable. */
  receiveEmails?: InputMaybe<Scalars['Boolean']>;
  /**
   * The ID of the user or organization who is acting as the sponsor, paying for
   * the sponsorship. Required if sponsorLogin is not given.
   */
  sponsorId?: InputMaybe<Scalars['ID']>;
  /**
   * The username of the user or organization who is acting as the sponsor, paying
   * for the sponsorship. Required if sponsorId is not given.
   */
  sponsorLogin?: InputMaybe<Scalars['String']>;
  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */
  sponsorableId?: InputMaybe<Scalars['ID']>;
  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */
  sponsorableLogin?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateSponsorshipPreferences */
export type Github_UpdateSponsorshipPreferencesPayload = {
  __typename?: 'Github_UpdateSponsorshipPreferencesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The sponsorship that was updated. */
  sponsorship?: Maybe<Github_Sponsorship>;
};

/** Autogenerated input type of UpdateSubscription */
export type Github_UpdateSubscriptionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The new state of the subscription. */
  state: Github_SubscriptionState;
  /** The Node ID of the subscribable object to modify. */
  subscribableId: Scalars['ID'];
};

/** Autogenerated return type of UpdateSubscription */
export type Github_UpdateSubscriptionPayload = {
  __typename?: 'Github_UpdateSubscriptionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The input subscribable entity. */
  subscribable?: Maybe<Github_Subscribable>;
};

/** Autogenerated input type of UpdateTeamDiscussionComment */
export type Github_UpdateTeamDiscussionCommentInput = {
  /** The updated text of the comment. */
  body: Scalars['String'];
  /** The current version of the body content. */
  bodyVersion?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the comment to modify. */
  id: Scalars['ID'];
};

/** Autogenerated return type of UpdateTeamDiscussionComment */
export type Github_UpdateTeamDiscussionCommentPayload = {
  __typename?: 'Github_UpdateTeamDiscussionCommentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated comment. */
  teamDiscussionComment?: Maybe<Github_TeamDiscussionComment>;
};

/** Autogenerated input type of UpdateTeamDiscussion */
export type Github_UpdateTeamDiscussionInput = {
  /** The updated text of the discussion. */
  body?: InputMaybe<Scalars['String']>;
  /**
   * The current version of the body content. If provided, this update operation
   * will be rejected if the given version does not match the latest version on the server.
   */
  bodyVersion?: InputMaybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the discussion to modify. */
  id: Scalars['ID'];
  /** If provided, sets the pinned state of the updated discussion. */
  pinned?: InputMaybe<Scalars['Boolean']>;
  /** The updated title of the discussion. */
  title?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateTeamDiscussion */
export type Github_UpdateTeamDiscussionPayload = {
  __typename?: 'Github_UpdateTeamDiscussionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The updated discussion. */
  teamDiscussion?: Maybe<Github_TeamDiscussion>;
};

/** Autogenerated input type of UpdateTeamReviewAssignment */
export type Github_UpdateTeamReviewAssignmentInput = {
  /** The algorithm to use for review assignment */
  algorithm?: InputMaybe<Github_TeamReviewAssignmentAlgorithm>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Turn on or off review assignment */
  enabled: Scalars['Boolean'];
  /** An array of team member IDs to exclude */
  excludedTeamMemberIds?: InputMaybe<Array<Scalars['ID']>>;
  /** The Node ID of the team to update review assignments of */
  id: Scalars['ID'];
  /** Notify the entire team of the PR if it is delegated */
  notifyTeam?: InputMaybe<Scalars['Boolean']>;
  /** The number of team members to assign */
  teamMemberCount?: InputMaybe<Scalars['Int']>;
};

/** Autogenerated return type of UpdateTeamReviewAssignment */
export type Github_UpdateTeamReviewAssignmentPayload = {
  __typename?: 'Github_UpdateTeamReviewAssignmentPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The team that was modified */
  team?: Maybe<Github_Team>;
};

/** Autogenerated input type of UpdateTopics */
export type Github_UpdateTopicsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The Node ID of the repository. */
  repositoryId: Scalars['ID'];
  /** An array of topic names. */
  topicNames: Array<Scalars['String']>;
};

/** Autogenerated return type of UpdateTopics */
export type Github_UpdateTopicsPayload = {
  __typename?: 'Github_UpdateTopicsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Names of the provided topics that are not valid. */
  invalidTopicNames?: Maybe<Array<Scalars['String']>>;
  /** The updated repository. */
  repository?: Maybe<Github_Repository>;
};

/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_User = Github_Actor & Github_Node & Github_PackageOwner & Github_ProfileOwner & Github_ProjectNextOwner & Github_ProjectOwner & Github_RepositoryDiscussionAuthor & Github_RepositoryDiscussionCommentAuthor & Github_RepositoryOwner & Github_Sponsorable & Github_UniformResourceLocatable & {
  __typename?: 'Github_User';
  /** Determine if this repository owner has any items that can be pinned to their profile. */
  anyPinnableItems: Scalars['Boolean'];
  /** A URL pointing to the user's public avatar. */
  avatarUrl: Scalars['Github_URI'];
  /** The user's public profile bio. */
  bio?: Maybe<Scalars['String']>;
  /** The user's public profile bio as HTML. */
  bioHTML: Scalars['Github_HTML'];
  /** Could this user receive email notifications, if the organization had notification restrictions enabled? */
  canReceiveOrganizationEmailsWhenNotificationsRestricted: Scalars['Boolean'];
  /** A list of commit comments made by this user. */
  commitComments: Github_CommitCommentConnection;
  /** The user's public profile company. */
  company?: Maybe<Scalars['String']>;
  /** The user's public profile company as HTML. */
  companyHTML: Scalars['Github_HTML'];
  /** The collection of contributions this user has made to different repositories. */
  contributionsCollection: Github_ContributionsCollection;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The user's publicly visible profile email. */
  email: Scalars['String'];
  /** The estimated next GitHub Sponsors payout for this user/organization in cents (USD). */
  estimatedNextSponsorsPayoutInCents: Scalars['Int'];
  /** A list of users the given user is followed by. */
  followers: Github_FollowerConnection;
  /** A list of users the given user is following. */
  following: Github_FollowingConnection;
  /** Find gist by repo name. */
  gist?: Maybe<Github_Gist>;
  /** A list of gist comments made by this user. */
  gistComments: Github_GistCommentConnection;
  /** A list of the Gists the user has created. */
  gists: Github_GistConnection;
  /** True if this user/organization has a GitHub Sponsors listing. */
  hasSponsorsListing: Scalars['Boolean'];
  /** The hovercard information for this user in a given context */
  hovercard: Github_Hovercard;
  id: Scalars['ID'];
  /** The interaction ability settings for this user. */
  interactionAbility?: Maybe<Github_RepositoryInteractionAbility>;
  /** Whether or not this user is a participant in the GitHub Security Bug Bounty. */
  isBountyHunter: Scalars['Boolean'];
  /** Whether or not this user is a participant in the GitHub Campus Experts Program. */
  isCampusExpert: Scalars['Boolean'];
  /** Whether or not this user is a GitHub Developer Program member. */
  isDeveloperProgramMember: Scalars['Boolean'];
  /** Whether or not this user is a GitHub employee. */
  isEmployee: Scalars['Boolean'];
  /** Whether or not this user is following the viewer. Inverse of viewer_is_following */
  isFollowingViewer: Scalars['Boolean'];
  /** Whether or not this user is a member of the GitHub Stars Program. */
  isGitHubStar: Scalars['Boolean'];
  /** Whether or not the user has marked themselves as for hire. */
  isHireable: Scalars['Boolean'];
  /** Whether or not this user is a site administrator. */
  isSiteAdmin: Scalars['Boolean'];
  /** Check if the given account is sponsoring this user/organization. */
  isSponsoredBy: Scalars['Boolean'];
  /** True if the viewer is sponsored by this user/organization. */
  isSponsoringViewer: Scalars['Boolean'];
  /** Whether or not this user is the viewing user. */
  isViewer: Scalars['Boolean'];
  /** A list of issue comments made by this user. */
  issueComments: Github_IssueCommentConnection;
  /** A list of issues associated with this user. */
  issues: Github_IssueConnection;
  /**
   * Showcases a selection of repositories and gists that the profile owner has
   * either curated or that have been selected automatically based on popularity.
   */
  itemShowcase: Github_ProfileItemShowcase;
  /** The user's public profile location. */
  location?: Maybe<Scalars['String']>;
  /** The username used to login. */
  login: Scalars['String'];
  /** The estimated monthly GitHub Sponsors income for this user/organization in cents (USD). */
  monthlyEstimatedSponsorsIncomeInCents: Scalars['Int'];
  /** The user's public profile name. */
  name?: Maybe<Scalars['String']>;
  /** Find an organization by its login that the user belongs to. */
  organization?: Maybe<Github_Organization>;
  /** Verified email addresses that match verified domains for a specified organization the user is a member of. */
  organizationVerifiedDomainEmails: Array<Scalars['String']>;
  /** A list of organizations the user belongs to. */
  organizations: Github_OrganizationConnection;
  /** A list of packages under the owner. */
  packages: Github_PackageConnection;
  /** A list of repositories and gists this profile owner can pin to their profile. */
  pinnableItems: Github_PinnableItemConnection;
  /** A list of repositories and gists this profile owner has pinned to their profile */
  pinnedItems: Github_PinnableItemConnection;
  /** Returns how many more items this profile owner can pin to their profile. */
  pinnedItemsRemaining: Scalars['Int'];
  /** Find project by number. */
  project?: Maybe<Github_Project>;
  /** Find a project by project (beta) number. */
  projectNext?: Maybe<Github_ProjectNext>;
  /** A list of projects under the owner. */
  projects: Github_ProjectConnection;
  /** A list of project (beta) items under the owner. */
  projectsNext: Github_ProjectNextConnection;
  /** The HTTP path listing user's projects */
  projectsResourcePath: Scalars['Github_URI'];
  /** The HTTP URL listing user's projects */
  projectsUrl: Scalars['Github_URI'];
  /** A list of public keys associated with this user. */
  publicKeys: Github_PublicKeyConnection;
  /** A list of pull requests associated with this user. */
  pullRequests: Github_PullRequestConnection;
  /** A list of repositories that the user owns. */
  repositories: Github_RepositoryConnection;
  /** A list of repositories that the user recently contributed to. */
  repositoriesContributedTo: Github_RepositoryConnection;
  /** Find Repository. */
  repository?: Maybe<Github_Repository>;
  /** Discussion comments this user has authored. */
  repositoryDiscussionComments: Github_DiscussionCommentConnection;
  /** Discussions this user has started. */
  repositoryDiscussions: Github_DiscussionConnection;
  /** The HTTP path for this user */
  resourcePath: Scalars['Github_URI'];
  /** Replies this user has saved */
  savedReplies?: Maybe<Github_SavedReplyConnection>;
  /** List of users and organizations this entity is sponsoring. */
  sponsoring: Github_SponsorConnection;
  /** List of sponsors for this user or organization. */
  sponsors: Github_SponsorConnection;
  /** Events involving this sponsorable, such as new sponsorships. */
  sponsorsActivities: Github_SponsorsActivityConnection;
  /** The GitHub Sponsors listing for this user or organization. */
  sponsorsListing?: Maybe<Github_SponsorsListing>;
  /**
   * The sponsorship from the viewer to this user/organization; that is, the
   * sponsorship where you're the sponsor. Only returns a sponsorship if it is active.
   */
  sponsorshipForViewerAsSponsor?: Maybe<Github_Sponsorship>;
  /**
   * The sponsorship from this user/organization to the viewer; that is, the
   * sponsorship you're receiving. Only returns a sponsorship if it is active.
   */
  sponsorshipForViewerAsSponsorable?: Maybe<Github_Sponsorship>;
  /** List of sponsorship updates sent from this sponsorable to sponsors. */
  sponsorshipNewsletters: Github_SponsorshipNewsletterConnection;
  /** This object's sponsorships as the maintainer. */
  sponsorshipsAsMaintainer: Github_SponsorshipConnection;
  /** This object's sponsorships as the sponsor. */
  sponsorshipsAsSponsor: Github_SponsorshipConnection;
  /** Repositories the user has starred. */
  starredRepositories: Github_StarredRepositoryConnection;
  /** The user's description of what they're currently doing. */
  status?: Maybe<Github_UserStatus>;
  /** Repositories the user has contributed to, ordered by contribution rank, plus repositories the user has created */
  topRepositories: Github_RepositoryConnection;
  /** The user's Twitter username. */
  twitterUsername?: Maybe<Scalars['String']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this user */
  url: Scalars['Github_URI'];
  /** Can the viewer pin repositories and gists to the profile? */
  viewerCanChangePinnedItems: Scalars['Boolean'];
  /** Can the current viewer create new projects on this owner. */
  viewerCanCreateProjects: Scalars['Boolean'];
  /** Whether or not the viewer is able to follow the user. */
  viewerCanFollow: Scalars['Boolean'];
  /** Whether or not the viewer is able to sponsor this user/organization. */
  viewerCanSponsor: Scalars['Boolean'];
  /** Whether or not this user is followed by the viewer. Inverse of is_following_viewer. */
  viewerIsFollowing: Scalars['Boolean'];
  /** True if the viewer is sponsoring this user/organization. */
  viewerIsSponsoring: Scalars['Boolean'];
  /** A list of repositories the given user is watching. */
  watching: Github_RepositoryConnection;
  /** A URL pointing to the user's public website/blog. */
  websiteUrl?: Maybe<Scalars['Github_URI']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserAnyPinnableItemsArgs = {
  type?: InputMaybe<Github_PinnableItemType>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserAvatarUrlArgs = {
  size?: InputMaybe<Scalars['Int']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserCanReceiveOrganizationEmailsWhenNotificationsRestrictedArgs = {
  login: Scalars['String'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserCommitCommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserContributionsCollectionArgs = {
  from?: InputMaybe<Scalars['DateTime']>;
  organizationID?: InputMaybe<Scalars['ID']>;
  to?: InputMaybe<Scalars['DateTime']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserFollowersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserFollowingArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserGistArgs = {
  name: Scalars['String'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserGistCommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserGistsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_GistOrder>;
  privacy?: InputMaybe<Github_GistPrivacy>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserHovercardArgs = {
  primarySubjectId?: InputMaybe<Scalars['ID']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserIsSponsoredByArgs = {
  accountLogin: Scalars['String'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserIssueCommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_IssueCommentOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserIssuesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  filterBy?: InputMaybe<Github_IssueFilters>;
  first?: InputMaybe<Scalars['Int']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_IssueOrder>;
  states?: InputMaybe<Array<Github_IssueState>>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserOrganizationArgs = {
  login: Scalars['String'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserOrganizationVerifiedDomainEmailsArgs = {
  login: Scalars['String'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserPackagesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  names?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  orderBy?: InputMaybe<Github_PackageOrder>;
  packageType?: InputMaybe<Github_PackageType>;
  repositoryId?: InputMaybe<Scalars['ID']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserPinnableItemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  types?: InputMaybe<Array<Github_PinnableItemType>>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserPinnedItemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  types?: InputMaybe<Array<Github_PinnableItemType>>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserProjectArgs = {
  number: Scalars['Int'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserProjectNextArgs = {
  number: Scalars['Int'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserProjectsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_ProjectOrder>;
  search?: InputMaybe<Scalars['String']>;
  states?: InputMaybe<Array<Github_ProjectState>>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserProjectsNextArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  query?: InputMaybe<Scalars['String']>;
  sortBy?: InputMaybe<Github_ProjectNextOrderField>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserPublicKeysArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserPullRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  baseRefName?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  headRefName?: InputMaybe<Scalars['String']>;
  labels?: InputMaybe<Array<Scalars['String']>>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_IssueOrder>;
  states?: InputMaybe<Array<Github_PullRequestState>>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserRepositoriesArgs = {
  affiliations?: InputMaybe<Array<InputMaybe<Github_RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  isFork?: InputMaybe<Scalars['Boolean']>;
  isLocked?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_RepositoryOrder>;
  ownerAffiliations?: InputMaybe<Array<InputMaybe<Github_RepositoryAffiliation>>>;
  privacy?: InputMaybe<Github_RepositoryPrivacy>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserRepositoriesContributedToArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  contributionTypes?: InputMaybe<Array<InputMaybe<Github_RepositoryContributionType>>>;
  first?: InputMaybe<Scalars['Int']>;
  includeUserRepositories?: InputMaybe<Scalars['Boolean']>;
  isLocked?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_RepositoryOrder>;
  privacy?: InputMaybe<Github_RepositoryPrivacy>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserRepositoryArgs = {
  followRenames?: InputMaybe<Scalars['Boolean']>;
  name: Scalars['String'];
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserRepositoryDiscussionCommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  onlyAnswers?: InputMaybe<Scalars['Boolean']>;
  repositoryId?: InputMaybe<Scalars['ID']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserRepositoryDiscussionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  answered?: InputMaybe<Scalars['Boolean']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_DiscussionOrder>;
  repositoryId?: InputMaybe<Scalars['ID']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserSavedRepliesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SavedReplyOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserSponsoringArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserSponsorsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorOrder>;
  tierId?: InputMaybe<Scalars['ID']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserSponsorsActivitiesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorsActivityOrder>;
  period?: InputMaybe<Github_SponsorsActivityPeriod>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserSponsorshipNewslettersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorshipNewsletterOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserSponsorshipsAsMaintainerArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  includePrivate?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorshipOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserSponsorshipsAsSponsorArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SponsorshipOrder>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserStarredRepositoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_StarOrder>;
  ownedByViewer?: InputMaybe<Scalars['Boolean']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserTopRepositoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy: Github_RepositoryOrder;
  since?: InputMaybe<Scalars['DateTime']>;
};


/** A user is an individual's account on GitHub that owns repositories and can make new content. */
export type Github_UserWatchingArgs = {
  affiliations?: InputMaybe<Array<InputMaybe<Github_RepositoryAffiliation>>>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  isLocked?: InputMaybe<Scalars['Boolean']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_RepositoryOrder>;
  ownerAffiliations?: InputMaybe<Array<InputMaybe<Github_RepositoryAffiliation>>>;
  privacy?: InputMaybe<Github_RepositoryPrivacy>;
};

/** The possible durations that a user can be blocked for. */
export enum Github_UserBlockDuration {
  /** The user was blocked for 1 day */
  OneDay = 'ONE_DAY',
  /** The user was blocked for 30 days */
  OneMonth = 'ONE_MONTH',
  /** The user was blocked for 7 days */
  OneWeek = 'ONE_WEEK',
  /** The user was blocked permanently */
  Permanent = 'PERMANENT',
  /** The user was blocked for 3 days */
  ThreeDays = 'THREE_DAYS'
}

/** Represents a 'user_blocked' event on a given user. */
export type Github_UserBlockedEvent = Github_Node & {
  __typename?: 'Github_UserBlockedEvent';
  /** Identifies the actor who performed the event. */
  actor?: Maybe<Github_Actor>;
  /** Number of days that the user was blocked for. */
  blockDuration: Github_UserBlockDuration;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  id: Scalars['ID'];
  /** The user who was blocked. */
  subject?: Maybe<Github_User>;
};

/** The connection type for User. */
export type Github_UserConnection = {
  __typename?: 'Github_UserConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_UserEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_User>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edit on user content */
export type Github_UserContentEdit = Github_Node & {
  __typename?: 'Github_UserContentEdit';
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the date and time when the object was deleted. */
  deletedAt?: Maybe<Scalars['DateTime']>;
  /** The actor who deleted this content */
  deletedBy?: Maybe<Github_Actor>;
  /** A summary of the changes for this edit */
  diff?: Maybe<Scalars['String']>;
  /** When this content was edited */
  editedAt: Scalars['DateTime'];
  /** The actor who edited this content */
  editor?: Maybe<Github_Actor>;
  id: Scalars['ID'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** A list of edits to content. */
export type Github_UserContentEditConnection = {
  __typename?: 'Github_UserContentEditConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_UserContentEditEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_UserContentEdit>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_UserContentEditEdge = {
  __typename?: 'Github_UserContentEditEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_UserContentEdit>;
};

/** Represents a user. */
export type Github_UserEdge = {
  __typename?: 'Github_UserEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_User>;
};

/** Email attributes from External Identity */
export type Github_UserEmailMetadata = {
  __typename?: 'Github_UserEmailMetadata';
  /** Boolean to identify primary emails */
  primary?: Maybe<Scalars['Boolean']>;
  /** Type of email */
  type?: Maybe<Scalars['String']>;
  /** Email id */
  value: Scalars['String'];
};

/** The user's description of what they're currently doing. */
export type Github_UserStatus = Github_Node & {
  __typename?: 'Github_UserStatus';
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** An emoji summarizing the user's status. */
  emoji?: Maybe<Scalars['String']>;
  /** The status emoji as HTML. */
  emojiHTML?: Maybe<Scalars['Github_HTML']>;
  /** If set, the status will not be shown after this date. */
  expiresAt?: Maybe<Scalars['DateTime']>;
  id: Scalars['ID'];
  /** Whether this status indicates the user is not fully available on GitHub. */
  indicatesLimitedAvailability: Scalars['Boolean'];
  /** A brief message describing what the user is doing. */
  message?: Maybe<Scalars['String']>;
  /** The organization whose members can see this status. If null, this status is publicly visible. */
  organization?: Maybe<Github_Organization>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The user who has this status. */
  user: Github_User;
};

/** The connection type for UserStatus. */
export type Github_UserStatusConnection = {
  __typename?: 'Github_UserStatusConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_UserStatusEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_UserStatus>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_UserStatusEdge = {
  __typename?: 'Github_UserStatusEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_UserStatus>;
};

/** Ordering options for user status connections. */
export type Github_UserStatusOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order user statuses by. */
  field: Github_UserStatusOrderField;
};

/** Properties by which user status connections can be ordered. */
export enum Github_UserStatusOrderField {
  /** Order user statuses by when they were updated. */
  UpdatedAt = 'UPDATED_AT'
}

/** A domain that can be verified or approved for an organization or an enterprise. */
export type Github_VerifiableDomain = Github_Node & {
  __typename?: 'Github_VerifiableDomain';
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The DNS host name that should be used for verification. */
  dnsHostName?: Maybe<Scalars['Github_URI']>;
  /** The unicode encoded domain. */
  domain: Scalars['Github_URI'];
  /** Whether a TXT record for verification with the expected host name was found. */
  hasFoundHostName: Scalars['Boolean'];
  /** Whether a TXT record for verification with the expected verification token was found. */
  hasFoundVerificationToken: Scalars['Boolean'];
  id: Scalars['ID'];
  /** Whether or not the domain is approved. */
  isApproved: Scalars['Boolean'];
  /** Whether this domain is required to exist for an organization or enterprise policy to be enforced. */
  isRequiredForPolicyEnforcement: Scalars['Boolean'];
  /** Whether or not the domain is verified. */
  isVerified: Scalars['Boolean'];
  /** The owner of the domain. */
  owner: Github_VerifiableDomainOwner;
  /** The punycode encoded domain. */
  punycodeEncodedDomain: Scalars['Github_URI'];
  /** The time that the current verification token will expire. */
  tokenExpirationTime?: Maybe<Scalars['DateTime']>;
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The current verification token for the domain. */
  verificationToken?: Maybe<Scalars['String']>;
};

/** The connection type for VerifiableDomain. */
export type Github_VerifiableDomainConnection = {
  __typename?: 'Github_VerifiableDomainConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<Github_VerifiableDomainEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Github_VerifiableDomain>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type Github_VerifiableDomainEdge = {
  __typename?: 'Github_VerifiableDomainEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Github_VerifiableDomain>;
};

/** Ordering options for verifiable domain connections. */
export type Github_VerifiableDomainOrder = {
  /** The ordering direction. */
  direction: Github_OrderDirection;
  /** The field to order verifiable domains by. */
  field: Github_VerifiableDomainOrderField;
};

/** Properties by which verifiable domain connections can be ordered. */
export enum Github_VerifiableDomainOrderField {
  /** Order verifiable domains by their creation date. */
  CreatedAt = 'CREATED_AT',
  /** Order verifiable domains by the domain name. */
  Domain = 'DOMAIN'
}

/** Types that can own a verifiable domain. */
export type Github_VerifiableDomainOwner = Github_Enterprise | Github_Organization;

/** Autogenerated input type of VerifyVerifiableDomain */
export type Github_VerifyVerifiableDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the verifiable domain to verify. */
  id: Scalars['ID'];
};

/** Autogenerated return type of VerifyVerifiableDomain */
export type Github_VerifyVerifiableDomainPayload = {
  __typename?: 'Github_VerifyVerifiableDomainPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The verifiable domain that was verified. */
  domain?: Maybe<Github_VerifiableDomain>;
};

/** A hovercard context with a message describing how the viewer is related. */
export type Github_ViewerHovercardContext = Github_HovercardContext & {
  __typename?: 'Github_ViewerHovercardContext';
  /** A string describing this context */
  message: Scalars['String'];
  /** An octicon to accompany this context */
  octicon: Scalars['String'];
  /** Identifies the user who is related to this context. */
  viewer: Github_User;
};

/** A subject that may be upvoted. */
export type Github_Votable = {
  /** Number of upvotes that this subject has received. */
  upvoteCount: Scalars['Int'];
  /** Whether or not the current user can add or remove an upvote on this subject. */
  viewerCanUpvote: Scalars['Boolean'];
  /** Whether or not the current user has already upvoted this subject. */
  viewerHasUpvoted: Scalars['Boolean'];
};

/** Github_Votable mock concrete type. */
export type Github_Votable__Mock = Github_Votable & {
  __typename?: 'Github_Votable__Mock';
  /** Number of upvotes that this subject has received. */
  upvoteCount: Scalars['Int'];
  /** Whether or not the current user can add or remove an upvote on this subject. */
  viewerCanUpvote: Scalars['Boolean'];
  /** Whether or not the current user has already upvoted this subject. */
  viewerHasUpvoted: Scalars['Boolean'];
};

/** A workflow contains meta information about an Actions workflow file. */
export type Github_Workflow = Github_Node & {
  __typename?: 'Github_Workflow';
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  id: Scalars['ID'];
  /** The name of the workflow. */
  name: Scalars['String'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
};

/** A workflow run. */
export type Github_WorkflowRun = Github_Node & {
  __typename?: 'Github_WorkflowRun';
  /** The check suite this workflow run belongs to. */
  checkSuite: Github_CheckSuite;
  /** Identifies the date and time when the object was created. */
  createdAt: Scalars['DateTime'];
  /** Identifies the primary key from the database. */
  databaseId?: Maybe<Scalars['Int']>;
  /** The log of deployment reviews */
  deploymentReviews: Github_DeploymentReviewConnection;
  id: Scalars['ID'];
  /** The pending deployment requests of all check runs in this workflow run */
  pendingDeploymentRequests: Github_DeploymentRequestConnection;
  /** The HTTP path for this workflow run */
  resourcePath: Scalars['Github_URI'];
  /** A number that uniquely identifies this workflow run in its parent workflow. */
  runNumber: Scalars['Int'];
  /** Identifies the date and time when the object was last updated. */
  updatedAt: Scalars['DateTime'];
  /** The HTTP URL for this workflow run */
  url: Scalars['Github_URI'];
  /** The workflow executed in this workflow run. */
  workflow: Github_Workflow;
};


/** A workflow run. */
export type Github_WorkflowRunDeploymentReviewsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A workflow run. */
export type Github_WorkflowRunPendingDeploymentRequestsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type Mutation = {
  __typename?: 'Mutation';
  /** Accepts a pending invitation for a user to become an administrator of an enterprise. */
  github_acceptEnterpriseAdministratorInvitation?: Maybe<Github_AcceptEnterpriseAdministratorInvitationPayload>;
  /** Applies a suggested topic to the repository. */
  github_acceptTopicSuggestion?: Maybe<Github_AcceptTopicSuggestionPayload>;
  /** Adds assignees to an assignable object. */
  github_addAssigneesToAssignable?: Maybe<Github_AddAssigneesToAssignablePayload>;
  /** Adds a comment to an Issue or Pull Request. */
  github_addComment?: Maybe<Github_AddCommentPayload>;
  /** Adds a comment to a Discussion, possibly as a reply to another comment. */
  github_addDiscussionComment?: Maybe<Github_AddDiscussionCommentPayload>;
  /** Adds a support entitlement to an enterprise member. */
  github_addEnterpriseSupportEntitlement?: Maybe<Github_AddEnterpriseSupportEntitlementPayload>;
  /** Adds labels to a labelable object. */
  github_addLabelsToLabelable?: Maybe<Github_AddLabelsToLabelablePayload>;
  /** Adds a card to a ProjectColumn. Either `contentId` or `note` must be provided but **not** both. */
  github_addProjectCard?: Maybe<Github_AddProjectCardPayload>;
  /** Adds a column to a Project. */
  github_addProjectColumn?: Maybe<Github_AddProjectColumnPayload>;
  /** Adds an existing item (Issue or PullRequest) to a Project. */
  github_addProjectNextItem?: Maybe<Github_AddProjectNextItemPayload>;
  /** Adds a review to a Pull Request. */
  github_addPullRequestReview?: Maybe<Github_AddPullRequestReviewPayload>;
  /** Adds a comment to a review. */
  github_addPullRequestReviewComment?: Maybe<Github_AddPullRequestReviewCommentPayload>;
  /** Adds a new thread to a pending Pull Request Review. */
  github_addPullRequestReviewThread?: Maybe<Github_AddPullRequestReviewThreadPayload>;
  /** Adds a reaction to a subject. */
  github_addReaction?: Maybe<Github_AddReactionPayload>;
  /** Adds a star to a Starrable. */
  github_addStar?: Maybe<Github_AddStarPayload>;
  /** Add an upvote to a discussion or discussion comment. */
  github_addUpvote?: Maybe<Github_AddUpvotePayload>;
  /** Adds a verifiable domain to an owning account. */
  github_addVerifiableDomain?: Maybe<Github_AddVerifiableDomainPayload>;
  /** Approve all pending deployments under one or more environments */
  github_approveDeployments?: Maybe<Github_ApproveDeploymentsPayload>;
  /** Approve a verifiable domain for notification delivery. */
  github_approveVerifiableDomain?: Maybe<Github_ApproveVerifiableDomainPayload>;
  /** Marks a repository as archived. */
  github_archiveRepository?: Maybe<Github_ArchiveRepositoryPayload>;
  /** Cancels a pending invitation for an administrator to join an enterprise. */
  github_cancelEnterpriseAdminInvitation?: Maybe<Github_CancelEnterpriseAdminInvitationPayload>;
  /** Cancel an active sponsorship. */
  github_cancelSponsorship?: Maybe<Github_CancelSponsorshipPayload>;
  /** Update your status on GitHub. */
  github_changeUserStatus?: Maybe<Github_ChangeUserStatusPayload>;
  /** Clears all labels from a labelable object. */
  github_clearLabelsFromLabelable?: Maybe<Github_ClearLabelsFromLabelablePayload>;
  /** Creates a new project by cloning configuration from an existing project. */
  github_cloneProject?: Maybe<Github_CloneProjectPayload>;
  /** Create a new repository with the same files and directory structure as a template repository. */
  github_cloneTemplateRepository?: Maybe<Github_CloneTemplateRepositoryPayload>;
  /** Close an issue. */
  github_closeIssue?: Maybe<Github_CloseIssuePayload>;
  /** Close a pull request. */
  github_closePullRequest?: Maybe<Github_ClosePullRequestPayload>;
  /** Convert a project note card to one associated with a newly created issue. */
  github_convertProjectCardNoteToIssue?: Maybe<Github_ConvertProjectCardNoteToIssuePayload>;
  /** Converts a pull request to draft */
  github_convertPullRequestToDraft?: Maybe<Github_ConvertPullRequestToDraftPayload>;
  /** Create a new branch protection rule */
  github_createBranchProtectionRule?: Maybe<Github_CreateBranchProtectionRulePayload>;
  /** Create a check run. */
  github_createCheckRun?: Maybe<Github_CreateCheckRunPayload>;
  /** Create a check suite */
  github_createCheckSuite?: Maybe<Github_CreateCheckSuitePayload>;
  /**
   * Appends a commit to the given branch as the authenticated user.
   *
   * This mutation creates a commit whose parent is the HEAD of the provided
   * branch and also updates that branch to point to the new commit.
   * It can be thought of as similar to `git commit`.
   *
   * ### Locating a Branch
   *
   * Commits are appended to a `branch` of type `Ref`.
   * This must refer to a git branch (i.e.  the fully qualified path must
   * begin with `refs/heads/`, although including this prefix is optional.
   *
   * Callers may specify the `branch` to commit to either by its global node
   * ID or by passing both of `repositoryNameWithOwner` and `refName`.  For
   * more details see the documentation for `CommittableBranch`.
   *
   * ### Describing Changes
   *
   * `fileChanges` are specified as a `FilesChanges` object describing
   * `FileAdditions` and `FileDeletions`.
   *
   * Please see the documentation for `FileChanges` for more information on
   * how to use this argument to describe any set of file changes.
   *
   * ### Authorship
   *
   * Similar to the web commit interface, this mutation does not support
   * specifying the author or committer of the commit and will not add
   * support for this in the future.
   *
   * A commit created by a successful execution of this mutation will be
   * authored by the owner of the credential which authenticates the API
   * request.  The committer will be identical to that of commits authored
   * using the web interface.
   *
   * If you need full control over author and committer information, please
   * use the Git Database REST API instead.
   *
   * ### Commit Signing
   *
   * Commits made using this mutation are automatically signed by GitHub if
   * supported and will be marked as verified in the user interface.
   */
  github_createCommitOnBranch?: Maybe<Github_CreateCommitOnBranchPayload>;
  /** Creates a new deployment event. */
  github_createDeployment?: Maybe<Github_CreateDeploymentPayload>;
  /** Create a deployment status. */
  github_createDeploymentStatus?: Maybe<Github_CreateDeploymentStatusPayload>;
  /** Create a discussion. */
  github_createDiscussion?: Maybe<Github_CreateDiscussionPayload>;
  /** Creates an organization as part of an enterprise account. */
  github_createEnterpriseOrganization?: Maybe<Github_CreateEnterpriseOrganizationPayload>;
  /** Creates an environment or simply returns it if already exists. */
  github_createEnvironment?: Maybe<Github_CreateEnvironmentPayload>;
  /** Creates a new IP allow list entry. */
  github_createIpAllowListEntry?: Maybe<Github_CreateIpAllowListEntryPayload>;
  /** Creates a new issue. */
  github_createIssue?: Maybe<Github_CreateIssuePayload>;
  /** Creates a new label. */
  github_createLabel?: Maybe<Github_CreateLabelPayload>;
  /** Creates a new project. */
  github_createProject?: Maybe<Github_CreateProjectPayload>;
  /** Create a new pull request */
  github_createPullRequest?: Maybe<Github_CreatePullRequestPayload>;
  /** Create a new Git Ref. */
  github_createRef?: Maybe<Github_CreateRefPayload>;
  /** Create a new repository. */
  github_createRepository?: Maybe<Github_CreateRepositoryPayload>;
  /** Start a new sponsorship of a maintainer in GitHub Sponsors, or reactivate a past sponsorship. */
  github_createSponsorship?: Maybe<Github_CreateSponsorshipPayload>;
  /** Creates a new team discussion. */
  github_createTeamDiscussion?: Maybe<Github_CreateTeamDiscussionPayload>;
  /** Creates a new team discussion comment. */
  github_createTeamDiscussionComment?: Maybe<Github_CreateTeamDiscussionCommentPayload>;
  /** Rejects a suggested topic for the repository. */
  github_declineTopicSuggestion?: Maybe<Github_DeclineTopicSuggestionPayload>;
  /** Delete a branch protection rule */
  github_deleteBranchProtectionRule?: Maybe<Github_DeleteBranchProtectionRulePayload>;
  /** Deletes a deployment. */
  github_deleteDeployment?: Maybe<Github_DeleteDeploymentPayload>;
  /** Delete a discussion and all of its replies. */
  github_deleteDiscussion?: Maybe<Github_DeleteDiscussionPayload>;
  /** Delete a discussion comment. If it has replies, wipe it instead. */
  github_deleteDiscussionComment?: Maybe<Github_DeleteDiscussionCommentPayload>;
  /** Deletes an environment */
  github_deleteEnvironment?: Maybe<Github_DeleteEnvironmentPayload>;
  /** Deletes an IP allow list entry. */
  github_deleteIpAllowListEntry?: Maybe<Github_DeleteIpAllowListEntryPayload>;
  /** Deletes an Issue object. */
  github_deleteIssue?: Maybe<Github_DeleteIssuePayload>;
  /** Deletes an IssueComment object. */
  github_deleteIssueComment?: Maybe<Github_DeleteIssueCommentPayload>;
  /** Deletes a label. */
  github_deleteLabel?: Maybe<Github_DeleteLabelPayload>;
  /** Delete a package version. */
  github_deletePackageVersion?: Maybe<Github_DeletePackageVersionPayload>;
  /** Deletes a project. */
  github_deleteProject?: Maybe<Github_DeleteProjectPayload>;
  /** Deletes a project card. */
  github_deleteProjectCard?: Maybe<Github_DeleteProjectCardPayload>;
  /** Deletes a project column. */
  github_deleteProjectColumn?: Maybe<Github_DeleteProjectColumnPayload>;
  /** Deletes an item from a Project. */
  github_deleteProjectNextItem?: Maybe<Github_DeleteProjectNextItemPayload>;
  /** Deletes a pull request review. */
  github_deletePullRequestReview?: Maybe<Github_DeletePullRequestReviewPayload>;
  /** Deletes a pull request review comment. */
  github_deletePullRequestReviewComment?: Maybe<Github_DeletePullRequestReviewCommentPayload>;
  /** Delete a Git Ref. */
  github_deleteRef?: Maybe<Github_DeleteRefPayload>;
  /** Deletes a team discussion. */
  github_deleteTeamDiscussion?: Maybe<Github_DeleteTeamDiscussionPayload>;
  /** Deletes a team discussion comment. */
  github_deleteTeamDiscussionComment?: Maybe<Github_DeleteTeamDiscussionCommentPayload>;
  /** Deletes a verifiable domain. */
  github_deleteVerifiableDomain?: Maybe<Github_DeleteVerifiableDomainPayload>;
  /** Disable auto merge on the given pull request */
  github_disablePullRequestAutoMerge?: Maybe<Github_DisablePullRequestAutoMergePayload>;
  /** Dismisses an approved or rejected pull request review. */
  github_dismissPullRequestReview?: Maybe<Github_DismissPullRequestReviewPayload>;
  /** Dismisses the Dependabot alert. */
  github_dismissRepositoryVulnerabilityAlert?: Maybe<Github_DismissRepositoryVulnerabilityAlertPayload>;
  /** Enable the default auto-merge on a pull request. */
  github_enablePullRequestAutoMerge?: Maybe<Github_EnablePullRequestAutoMergePayload>;
  /** Follow a user. */
  github_followUser?: Maybe<Github_FollowUserPayload>;
  /** Creates a new project by importing columns and a list of issues/PRs. */
  github_importProject?: Maybe<Github_ImportProjectPayload>;
  /** Invite someone to become an administrator of the enterprise. */
  github_inviteEnterpriseAdmin?: Maybe<Github_InviteEnterpriseAdminPayload>;
  /** Creates a repository link for a project. */
  github_linkRepositoryToProject?: Maybe<Github_LinkRepositoryToProjectPayload>;
  /** Lock a lockable object */
  github_lockLockable?: Maybe<Github_LockLockablePayload>;
  /** Mark a discussion comment as the chosen answer for discussions in an answerable category. */
  github_markDiscussionCommentAsAnswer?: Maybe<Github_MarkDiscussionCommentAsAnswerPayload>;
  /** Mark a pull request file as viewed */
  github_markFileAsViewed?: Maybe<Github_MarkFileAsViewedPayload>;
  /** Marks a pull request ready for review. */
  github_markPullRequestReadyForReview?: Maybe<Github_MarkPullRequestReadyForReviewPayload>;
  /** Merge a head into a branch. */
  github_mergeBranch?: Maybe<Github_MergeBranchPayload>;
  /** Merge a pull request. */
  github_mergePullRequest?: Maybe<Github_MergePullRequestPayload>;
  /** Minimizes a comment on an Issue, Commit, Pull Request, or Gist */
  github_minimizeComment?: Maybe<Github_MinimizeCommentPayload>;
  /** Moves a project card to another place. */
  github_moveProjectCard?: Maybe<Github_MoveProjectCardPayload>;
  /** Moves a project column to another place. */
  github_moveProjectColumn?: Maybe<Github_MoveProjectColumnPayload>;
  /** Pin an issue to a repository */
  github_pinIssue?: Maybe<Github_PinIssuePayload>;
  /** Regenerates the identity provider recovery codes for an enterprise */
  github_regenerateEnterpriseIdentityProviderRecoveryCodes?: Maybe<Github_RegenerateEnterpriseIdentityProviderRecoveryCodesPayload>;
  /** Regenerates a verifiable domain's verification token. */
  github_regenerateVerifiableDomainToken?: Maybe<Github_RegenerateVerifiableDomainTokenPayload>;
  /** Reject all pending deployments under one or more environments */
  github_rejectDeployments?: Maybe<Github_RejectDeploymentsPayload>;
  /** Removes assignees from an assignable object. */
  github_removeAssigneesFromAssignable?: Maybe<Github_RemoveAssigneesFromAssignablePayload>;
  /** Removes an administrator from the enterprise. */
  github_removeEnterpriseAdmin?: Maybe<Github_RemoveEnterpriseAdminPayload>;
  /** Removes the identity provider from an enterprise */
  github_removeEnterpriseIdentityProvider?: Maybe<Github_RemoveEnterpriseIdentityProviderPayload>;
  /** Removes an organization from the enterprise */
  github_removeEnterpriseOrganization?: Maybe<Github_RemoveEnterpriseOrganizationPayload>;
  /** Removes a support entitlement from an enterprise member. */
  github_removeEnterpriseSupportEntitlement?: Maybe<Github_RemoveEnterpriseSupportEntitlementPayload>;
  /** Removes labels from a Labelable object. */
  github_removeLabelsFromLabelable?: Maybe<Github_RemoveLabelsFromLabelablePayload>;
  /** Removes outside collaborator from all repositories in an organization. */
  github_removeOutsideCollaborator?: Maybe<Github_RemoveOutsideCollaboratorPayload>;
  /** Removes a reaction from a subject. */
  github_removeReaction?: Maybe<Github_RemoveReactionPayload>;
  /** Removes a star from a Starrable. */
  github_removeStar?: Maybe<Github_RemoveStarPayload>;
  /** Remove an upvote to a discussion or discussion comment. */
  github_removeUpvote?: Maybe<Github_RemoveUpvotePayload>;
  /** Reopen a issue. */
  github_reopenIssue?: Maybe<Github_ReopenIssuePayload>;
  /** Reopen a pull request. */
  github_reopenPullRequest?: Maybe<Github_ReopenPullRequestPayload>;
  /** Set review requests on a pull request. */
  github_requestReviews?: Maybe<Github_RequestReviewsPayload>;
  /** Rerequests an existing check suite. */
  github_rerequestCheckSuite?: Maybe<Github_RerequestCheckSuitePayload>;
  /** Marks a review thread as resolved. */
  github_resolveReviewThread?: Maybe<Github_ResolveReviewThreadPayload>;
  /** Creates or updates the identity provider for an enterprise. */
  github_setEnterpriseIdentityProvider?: Maybe<Github_SetEnterpriseIdentityProviderPayload>;
  /** Set an organization level interaction limit for an organization's public repositories. */
  github_setOrganizationInteractionLimit?: Maybe<Github_SetOrganizationInteractionLimitPayload>;
  /** Sets an interaction limit setting for a repository. */
  github_setRepositoryInteractionLimit?: Maybe<Github_SetRepositoryInteractionLimitPayload>;
  /** Set a user level interaction limit for an user's public repositories. */
  github_setUserInteractionLimit?: Maybe<Github_SetUserInteractionLimitPayload>;
  /** Submits a pending pull request review. */
  github_submitPullRequestReview?: Maybe<Github_SubmitPullRequestReviewPayload>;
  /** Transfer an issue to a different repository */
  github_transferIssue?: Maybe<Github_TransferIssuePayload>;
  /** Unarchives a repository. */
  github_unarchiveRepository?: Maybe<Github_UnarchiveRepositoryPayload>;
  /** Unfollow a user. */
  github_unfollowUser?: Maybe<Github_UnfollowUserPayload>;
  /** Deletes a repository link from a project. */
  github_unlinkRepositoryFromProject?: Maybe<Github_UnlinkRepositoryFromProjectPayload>;
  /** Unlock a lockable object */
  github_unlockLockable?: Maybe<Github_UnlockLockablePayload>;
  /** Unmark a discussion comment as the chosen answer for discussions in an answerable category. */
  github_unmarkDiscussionCommentAsAnswer?: Maybe<Github_UnmarkDiscussionCommentAsAnswerPayload>;
  /** Unmark a pull request file as viewed */
  github_unmarkFileAsViewed?: Maybe<Github_UnmarkFileAsViewedPayload>;
  /** Unmark an issue as a duplicate of another issue. */
  github_unmarkIssueAsDuplicate?: Maybe<Github_UnmarkIssueAsDuplicatePayload>;
  /** Unminimizes a comment on an Issue, Commit, Pull Request, or Gist */
  github_unminimizeComment?: Maybe<Github_UnminimizeCommentPayload>;
  /** Unpin a pinned issue from a repository */
  github_unpinIssue?: Maybe<Github_UnpinIssuePayload>;
  /** Marks a review thread as unresolved. */
  github_unresolveReviewThread?: Maybe<Github_UnresolveReviewThreadPayload>;
  /** Create a new branch protection rule */
  github_updateBranchProtectionRule?: Maybe<Github_UpdateBranchProtectionRulePayload>;
  /** Update a check run */
  github_updateCheckRun?: Maybe<Github_UpdateCheckRunPayload>;
  /** Modifies the settings of an existing check suite */
  github_updateCheckSuitePreferences?: Maybe<Github_UpdateCheckSuitePreferencesPayload>;
  /** Update a discussion */
  github_updateDiscussion?: Maybe<Github_UpdateDiscussionPayload>;
  /** Update the contents of a comment on a Discussion */
  github_updateDiscussionComment?: Maybe<Github_UpdateDiscussionCommentPayload>;
  /** Updates the role of an enterprise administrator. */
  github_updateEnterpriseAdministratorRole?: Maybe<Github_UpdateEnterpriseAdministratorRolePayload>;
  /** Sets whether private repository forks are enabled for an enterprise. */
  github_updateEnterpriseAllowPrivateRepositoryForkingSetting?: Maybe<Github_UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload>;
  /** Sets the base repository permission for organizations in an enterprise. */
  github_updateEnterpriseDefaultRepositoryPermissionSetting?: Maybe<Github_UpdateEnterpriseDefaultRepositoryPermissionSettingPayload>;
  /** Sets whether organization members with admin permissions on a repository can change repository visibility. */
  github_updateEnterpriseMembersCanChangeRepositoryVisibilitySetting?: Maybe<Github_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload>;
  /** Sets the members can create repositories setting for an enterprise. */
  github_updateEnterpriseMembersCanCreateRepositoriesSetting?: Maybe<Github_UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload>;
  /** Sets the members can delete issues setting for an enterprise. */
  github_updateEnterpriseMembersCanDeleteIssuesSetting?: Maybe<Github_UpdateEnterpriseMembersCanDeleteIssuesSettingPayload>;
  /** Sets the members can delete repositories setting for an enterprise. */
  github_updateEnterpriseMembersCanDeleteRepositoriesSetting?: Maybe<Github_UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload>;
  /** Sets whether members can invite collaborators are enabled for an enterprise. */
  github_updateEnterpriseMembersCanInviteCollaboratorsSetting?: Maybe<Github_UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload>;
  /** Sets whether or not an organization admin can make purchases. */
  github_updateEnterpriseMembersCanMakePurchasesSetting?: Maybe<Github_UpdateEnterpriseMembersCanMakePurchasesSettingPayload>;
  /** Sets the members can update protected branches setting for an enterprise. */
  github_updateEnterpriseMembersCanUpdateProtectedBranchesSetting?: Maybe<Github_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload>;
  /** Sets the members can view dependency insights for an enterprise. */
  github_updateEnterpriseMembersCanViewDependencyInsightsSetting?: Maybe<Github_UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload>;
  /** Sets whether organization projects are enabled for an enterprise. */
  github_updateEnterpriseOrganizationProjectsSetting?: Maybe<Github_UpdateEnterpriseOrganizationProjectsSettingPayload>;
  /** Updates an enterprise's profile. */
  github_updateEnterpriseProfile?: Maybe<Github_UpdateEnterpriseProfilePayload>;
  /** Sets whether repository projects are enabled for a enterprise. */
  github_updateEnterpriseRepositoryProjectsSetting?: Maybe<Github_UpdateEnterpriseRepositoryProjectsSettingPayload>;
  /** Sets whether team discussions are enabled for an enterprise. */
  github_updateEnterpriseTeamDiscussionsSetting?: Maybe<Github_UpdateEnterpriseTeamDiscussionsSettingPayload>;
  /** Sets whether two factor authentication is required for all users in an enterprise. */
  github_updateEnterpriseTwoFactorAuthenticationRequiredSetting?: Maybe<Github_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload>;
  /** Updates an environment. */
  github_updateEnvironment?: Maybe<Github_UpdateEnvironmentPayload>;
  /** Sets whether an IP allow list is enabled on an owner. */
  github_updateIpAllowListEnabledSetting?: Maybe<Github_UpdateIpAllowListEnabledSettingPayload>;
  /** Updates an IP allow list entry. */
  github_updateIpAllowListEntry?: Maybe<Github_UpdateIpAllowListEntryPayload>;
  /** Sets whether IP allow list configuration for installed GitHub Apps is enabled on an owner. */
  github_updateIpAllowListForInstalledAppsEnabledSetting?: Maybe<Github_UpdateIpAllowListForInstalledAppsEnabledSettingPayload>;
  /** Updates an Issue. */
  github_updateIssue?: Maybe<Github_UpdateIssuePayload>;
  /** Updates an IssueComment object. */
  github_updateIssueComment?: Maybe<Github_UpdateIssueCommentPayload>;
  /** Updates an existing label. */
  github_updateLabel?: Maybe<Github_UpdateLabelPayload>;
  /** Update the setting to restrict notifications to only verified or approved domains available to an owner. */
  github_updateNotificationRestrictionSetting?: Maybe<Github_UpdateNotificationRestrictionSettingPayload>;
  /** Sets whether private repository forks are enabled for an organization. */
  github_updateOrganizationAllowPrivateRepositoryForkingSetting?: Maybe<Github_UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload>;
  /** Updates an existing project. */
  github_updateProject?: Maybe<Github_UpdateProjectPayload>;
  /** Updates an existing project card. */
  github_updateProjectCard?: Maybe<Github_UpdateProjectCardPayload>;
  /** Updates an existing project column. */
  github_updateProjectColumn?: Maybe<Github_UpdateProjectColumnPayload>;
  /** Updates a field of an item from a Project. */
  github_updateProjectNextItemField?: Maybe<Github_UpdateProjectNextItemFieldPayload>;
  /** Update a pull request */
  github_updatePullRequest?: Maybe<Github_UpdatePullRequestPayload>;
  /** Merge HEAD from upstream branch into pull request branch */
  github_updatePullRequestBranch?: Maybe<Github_UpdatePullRequestBranchPayload>;
  /** Updates the body of a pull request review. */
  github_updatePullRequestReview?: Maybe<Github_UpdatePullRequestReviewPayload>;
  /** Updates a pull request review comment. */
  github_updatePullRequestReviewComment?: Maybe<Github_UpdatePullRequestReviewCommentPayload>;
  /** Update a Git Ref. */
  github_updateRef?: Maybe<Github_UpdateRefPayload>;
  /**
   * Creates, updates and/or deletes multiple refs in a repository.
   *
   * This mutation takes a list of `RefUpdate`s and performs these updates
   * on the repository. All updates are performed atomically, meaning that
   * if one of them is rejected, no other ref will be modified.
   *
   * `RefUpdate.beforeOid` specifies that the given reference needs to point
   * to the given value before performing any updates. A value of
   * `0000000000000000000000000000000000000000` can be used to verify that
   * the references should not exist.
   *
   * `RefUpdate.afterOid` specifies the value that the given reference
   * will point to after performing all updates. A value of
   * `0000000000000000000000000000000000000000` can be used to delete a
   * reference.
   *
   * If `RefUpdate.force` is set to `true`, a non-fast-forward updates
   * for the given reference will be allowed.
   */
  github_updateRefs?: Maybe<Github_UpdateRefsPayload>;
  /** Update information about a repository. */
  github_updateRepository?: Maybe<Github_UpdateRepositoryPayload>;
  /** Change visibility of your sponsorship and opt in or out of email updates from the maintainer. */
  github_updateSponsorshipPreferences?: Maybe<Github_UpdateSponsorshipPreferencesPayload>;
  /** Updates the state for subscribable subjects. */
  github_updateSubscription?: Maybe<Github_UpdateSubscriptionPayload>;
  /** Updates a team discussion. */
  github_updateTeamDiscussion?: Maybe<Github_UpdateTeamDiscussionPayload>;
  /** Updates a discussion comment. */
  github_updateTeamDiscussionComment?: Maybe<Github_UpdateTeamDiscussionCommentPayload>;
  /** Updates team review assignment. */
  github_updateTeamReviewAssignment?: Maybe<Github_UpdateTeamReviewAssignmentPayload>;
  /** Replaces the repository's topics with the given topics. */
  github_updateTopics?: Maybe<Github_UpdateTopicsPayload>;
  /** Verify that a verifiable domain has the expected DNS record. */
  github_verifyVerifiableDomain?: Maybe<Github_VerifyVerifiableDomainPayload>;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_AcceptEnterpriseAdministratorInvitationArgs = {
  github_token: Scalars['Secret'];
  input: Github_AcceptEnterpriseAdministratorInvitationInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_AcceptTopicSuggestionArgs = {
  github_token: Scalars['Secret'];
  input: Github_AcceptTopicSuggestionInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_AddAssigneesToAssignableArgs = {
  github_token: Scalars['Secret'];
  input: Github_AddAssigneesToAssignableInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_AddCommentArgs = {
  github_token: Scalars['Secret'];
  input: Github_AddCommentInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_AddDiscussionCommentArgs = {
  github_token: Scalars['Secret'];
  input: Github_AddDiscussionCommentInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_AddEnterpriseSupportEntitlementArgs = {
  github_token: Scalars['Secret'];
  input: Github_AddEnterpriseSupportEntitlementInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_AddLabelsToLabelableArgs = {
  github_token: Scalars['Secret'];
  input: Github_AddLabelsToLabelableInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_AddProjectCardArgs = {
  github_token: Scalars['Secret'];
  input: Github_AddProjectCardInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_AddProjectColumnArgs = {
  github_token: Scalars['Secret'];
  input: Github_AddProjectColumnInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_AddProjectNextItemArgs = {
  github_token: Scalars['Secret'];
  input: Github_AddProjectNextItemInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_AddPullRequestReviewArgs = {
  github_token: Scalars['Secret'];
  input: Github_AddPullRequestReviewInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_AddPullRequestReviewCommentArgs = {
  github_token: Scalars['Secret'];
  input: Github_AddPullRequestReviewCommentInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_AddPullRequestReviewThreadArgs = {
  github_token: Scalars['Secret'];
  input: Github_AddPullRequestReviewThreadInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_AddReactionArgs = {
  github_token: Scalars['Secret'];
  input: Github_AddReactionInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_AddStarArgs = {
  github_token: Scalars['Secret'];
  input: Github_AddStarInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_AddUpvoteArgs = {
  github_token: Scalars['Secret'];
  input: Github_AddUpvoteInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_AddVerifiableDomainArgs = {
  github_token: Scalars['Secret'];
  input: Github_AddVerifiableDomainInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_ApproveDeploymentsArgs = {
  github_token: Scalars['Secret'];
  input: Github_ApproveDeploymentsInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_ApproveVerifiableDomainArgs = {
  github_token: Scalars['Secret'];
  input: Github_ApproveVerifiableDomainInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_ArchiveRepositoryArgs = {
  github_token: Scalars['Secret'];
  input: Github_ArchiveRepositoryInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_CancelEnterpriseAdminInvitationArgs = {
  github_token: Scalars['Secret'];
  input: Github_CancelEnterpriseAdminInvitationInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_CancelSponsorshipArgs = {
  github_token: Scalars['Secret'];
  input: Github_CancelSponsorshipInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_ChangeUserStatusArgs = {
  github_token: Scalars['Secret'];
  input: Github_ChangeUserStatusInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_ClearLabelsFromLabelableArgs = {
  github_token: Scalars['Secret'];
  input: Github_ClearLabelsFromLabelableInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_CloneProjectArgs = {
  github_token: Scalars['Secret'];
  input: Github_CloneProjectInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_CloneTemplateRepositoryArgs = {
  github_token: Scalars['Secret'];
  input: Github_CloneTemplateRepositoryInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_CloseIssueArgs = {
  github_token: Scalars['Secret'];
  input: Github_CloseIssueInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_ClosePullRequestArgs = {
  github_token: Scalars['Secret'];
  input: Github_ClosePullRequestInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_ConvertProjectCardNoteToIssueArgs = {
  github_token: Scalars['Secret'];
  input: Github_ConvertProjectCardNoteToIssueInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_ConvertPullRequestToDraftArgs = {
  github_token: Scalars['Secret'];
  input: Github_ConvertPullRequestToDraftInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_CreateBranchProtectionRuleArgs = {
  github_token: Scalars['Secret'];
  input: Github_CreateBranchProtectionRuleInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_CreateCheckRunArgs = {
  github_token: Scalars['Secret'];
  input: Github_CreateCheckRunInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_CreateCheckSuiteArgs = {
  github_token: Scalars['Secret'];
  input: Github_CreateCheckSuiteInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_CreateCommitOnBranchArgs = {
  github_token: Scalars['Secret'];
  input: Github_CreateCommitOnBranchInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_CreateDeploymentArgs = {
  github_token: Scalars['Secret'];
  input: Github_CreateDeploymentInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_CreateDeploymentStatusArgs = {
  github_token: Scalars['Secret'];
  input: Github_CreateDeploymentStatusInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_CreateDiscussionArgs = {
  github_token: Scalars['Secret'];
  input: Github_CreateDiscussionInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_CreateEnterpriseOrganizationArgs = {
  github_token: Scalars['Secret'];
  input: Github_CreateEnterpriseOrganizationInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_CreateEnvironmentArgs = {
  github_token: Scalars['Secret'];
  input: Github_CreateEnvironmentInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_CreateIpAllowListEntryArgs = {
  github_token: Scalars['Secret'];
  input: Github_CreateIpAllowListEntryInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_CreateIssueArgs = {
  github_token: Scalars['Secret'];
  input: Github_CreateIssueInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_CreateLabelArgs = {
  github_token: Scalars['Secret'];
  input: Github_CreateLabelInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_CreateProjectArgs = {
  github_token: Scalars['Secret'];
  input: Github_CreateProjectInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_CreatePullRequestArgs = {
  github_token: Scalars['Secret'];
  input: Github_CreatePullRequestInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_CreateRefArgs = {
  github_token: Scalars['Secret'];
  input: Github_CreateRefInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_CreateRepositoryArgs = {
  github_token: Scalars['Secret'];
  input: Github_CreateRepositoryInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_CreateSponsorshipArgs = {
  github_token: Scalars['Secret'];
  input: Github_CreateSponsorshipInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_CreateTeamDiscussionArgs = {
  github_token: Scalars['Secret'];
  input: Github_CreateTeamDiscussionInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_CreateTeamDiscussionCommentArgs = {
  github_token: Scalars['Secret'];
  input: Github_CreateTeamDiscussionCommentInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_DeclineTopicSuggestionArgs = {
  github_token: Scalars['Secret'];
  input: Github_DeclineTopicSuggestionInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_DeleteBranchProtectionRuleArgs = {
  github_token: Scalars['Secret'];
  input: Github_DeleteBranchProtectionRuleInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_DeleteDeploymentArgs = {
  github_token: Scalars['Secret'];
  input: Github_DeleteDeploymentInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_DeleteDiscussionArgs = {
  github_token: Scalars['Secret'];
  input: Github_DeleteDiscussionInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_DeleteDiscussionCommentArgs = {
  github_token: Scalars['Secret'];
  input: Github_DeleteDiscussionCommentInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_DeleteEnvironmentArgs = {
  github_token: Scalars['Secret'];
  input: Github_DeleteEnvironmentInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_DeleteIpAllowListEntryArgs = {
  github_token: Scalars['Secret'];
  input: Github_DeleteIpAllowListEntryInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_DeleteIssueArgs = {
  github_token: Scalars['Secret'];
  input: Github_DeleteIssueInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_DeleteIssueCommentArgs = {
  github_token: Scalars['Secret'];
  input: Github_DeleteIssueCommentInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_DeleteLabelArgs = {
  github_token: Scalars['Secret'];
  input: Github_DeleteLabelInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_DeletePackageVersionArgs = {
  github_token: Scalars['Secret'];
  input: Github_DeletePackageVersionInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_DeleteProjectArgs = {
  github_token: Scalars['Secret'];
  input: Github_DeleteProjectInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_DeleteProjectCardArgs = {
  github_token: Scalars['Secret'];
  input: Github_DeleteProjectCardInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_DeleteProjectColumnArgs = {
  github_token: Scalars['Secret'];
  input: Github_DeleteProjectColumnInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_DeleteProjectNextItemArgs = {
  github_token: Scalars['Secret'];
  input: Github_DeleteProjectNextItemInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_DeletePullRequestReviewArgs = {
  github_token: Scalars['Secret'];
  input: Github_DeletePullRequestReviewInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_DeletePullRequestReviewCommentArgs = {
  github_token: Scalars['Secret'];
  input: Github_DeletePullRequestReviewCommentInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_DeleteRefArgs = {
  github_token: Scalars['Secret'];
  input: Github_DeleteRefInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_DeleteTeamDiscussionArgs = {
  github_token: Scalars['Secret'];
  input: Github_DeleteTeamDiscussionInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_DeleteTeamDiscussionCommentArgs = {
  github_token: Scalars['Secret'];
  input: Github_DeleteTeamDiscussionCommentInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_DeleteVerifiableDomainArgs = {
  github_token: Scalars['Secret'];
  input: Github_DeleteVerifiableDomainInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_DisablePullRequestAutoMergeArgs = {
  github_token: Scalars['Secret'];
  input: Github_DisablePullRequestAutoMergeInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_DismissPullRequestReviewArgs = {
  github_token: Scalars['Secret'];
  input: Github_DismissPullRequestReviewInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_DismissRepositoryVulnerabilityAlertArgs = {
  github_token: Scalars['Secret'];
  input: Github_DismissRepositoryVulnerabilityAlertInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_EnablePullRequestAutoMergeArgs = {
  github_token: Scalars['Secret'];
  input: Github_EnablePullRequestAutoMergeInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_FollowUserArgs = {
  github_token: Scalars['Secret'];
  input: Github_FollowUserInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_ImportProjectArgs = {
  github_token: Scalars['Secret'];
  input: Github_ImportProjectInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_InviteEnterpriseAdminArgs = {
  github_token: Scalars['Secret'];
  input: Github_InviteEnterpriseAdminInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_LinkRepositoryToProjectArgs = {
  github_token: Scalars['Secret'];
  input: Github_LinkRepositoryToProjectInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_LockLockableArgs = {
  github_token: Scalars['Secret'];
  input: Github_LockLockableInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_MarkDiscussionCommentAsAnswerArgs = {
  github_token: Scalars['Secret'];
  input: Github_MarkDiscussionCommentAsAnswerInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_MarkFileAsViewedArgs = {
  github_token: Scalars['Secret'];
  input: Github_MarkFileAsViewedInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_MarkPullRequestReadyForReviewArgs = {
  github_token: Scalars['Secret'];
  input: Github_MarkPullRequestReadyForReviewInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_MergeBranchArgs = {
  github_token: Scalars['Secret'];
  input: Github_MergeBranchInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_MergePullRequestArgs = {
  github_token: Scalars['Secret'];
  input: Github_MergePullRequestInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_MinimizeCommentArgs = {
  github_token: Scalars['Secret'];
  input: Github_MinimizeCommentInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_MoveProjectCardArgs = {
  github_token: Scalars['Secret'];
  input: Github_MoveProjectCardInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_MoveProjectColumnArgs = {
  github_token: Scalars['Secret'];
  input: Github_MoveProjectColumnInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_PinIssueArgs = {
  github_token: Scalars['Secret'];
  input: Github_PinIssueInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_RegenerateEnterpriseIdentityProviderRecoveryCodesArgs = {
  github_token: Scalars['Secret'];
  input: Github_RegenerateEnterpriseIdentityProviderRecoveryCodesInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_RegenerateVerifiableDomainTokenArgs = {
  github_token: Scalars['Secret'];
  input: Github_RegenerateVerifiableDomainTokenInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_RejectDeploymentsArgs = {
  github_token: Scalars['Secret'];
  input: Github_RejectDeploymentsInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_RemoveAssigneesFromAssignableArgs = {
  github_token: Scalars['Secret'];
  input: Github_RemoveAssigneesFromAssignableInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_RemoveEnterpriseAdminArgs = {
  github_token: Scalars['Secret'];
  input: Github_RemoveEnterpriseAdminInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_RemoveEnterpriseIdentityProviderArgs = {
  github_token: Scalars['Secret'];
  input: Github_RemoveEnterpriseIdentityProviderInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_RemoveEnterpriseOrganizationArgs = {
  github_token: Scalars['Secret'];
  input: Github_RemoveEnterpriseOrganizationInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_RemoveEnterpriseSupportEntitlementArgs = {
  github_token: Scalars['Secret'];
  input: Github_RemoveEnterpriseSupportEntitlementInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_RemoveLabelsFromLabelableArgs = {
  github_token: Scalars['Secret'];
  input: Github_RemoveLabelsFromLabelableInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_RemoveOutsideCollaboratorArgs = {
  github_token: Scalars['Secret'];
  input: Github_RemoveOutsideCollaboratorInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_RemoveReactionArgs = {
  github_token: Scalars['Secret'];
  input: Github_RemoveReactionInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_RemoveStarArgs = {
  github_token: Scalars['Secret'];
  input: Github_RemoveStarInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_RemoveUpvoteArgs = {
  github_token: Scalars['Secret'];
  input: Github_RemoveUpvoteInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_ReopenIssueArgs = {
  github_token: Scalars['Secret'];
  input: Github_ReopenIssueInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_ReopenPullRequestArgs = {
  github_token: Scalars['Secret'];
  input: Github_ReopenPullRequestInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_RequestReviewsArgs = {
  github_token: Scalars['Secret'];
  input: Github_RequestReviewsInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_RerequestCheckSuiteArgs = {
  github_token: Scalars['Secret'];
  input: Github_RerequestCheckSuiteInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_ResolveReviewThreadArgs = {
  github_token: Scalars['Secret'];
  input: Github_ResolveReviewThreadInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_SetEnterpriseIdentityProviderArgs = {
  github_token: Scalars['Secret'];
  input: Github_SetEnterpriseIdentityProviderInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_SetOrganizationInteractionLimitArgs = {
  github_token: Scalars['Secret'];
  input: Github_SetOrganizationInteractionLimitInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_SetRepositoryInteractionLimitArgs = {
  github_token: Scalars['Secret'];
  input: Github_SetRepositoryInteractionLimitInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_SetUserInteractionLimitArgs = {
  github_token: Scalars['Secret'];
  input: Github_SetUserInteractionLimitInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_SubmitPullRequestReviewArgs = {
  github_token: Scalars['Secret'];
  input: Github_SubmitPullRequestReviewInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_TransferIssueArgs = {
  github_token: Scalars['Secret'];
  input: Github_TransferIssueInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UnarchiveRepositoryArgs = {
  github_token: Scalars['Secret'];
  input: Github_UnarchiveRepositoryInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UnfollowUserArgs = {
  github_token: Scalars['Secret'];
  input: Github_UnfollowUserInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UnlinkRepositoryFromProjectArgs = {
  github_token: Scalars['Secret'];
  input: Github_UnlinkRepositoryFromProjectInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UnlockLockableArgs = {
  github_token: Scalars['Secret'];
  input: Github_UnlockLockableInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UnmarkDiscussionCommentAsAnswerArgs = {
  github_token: Scalars['Secret'];
  input: Github_UnmarkDiscussionCommentAsAnswerInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UnmarkFileAsViewedArgs = {
  github_token: Scalars['Secret'];
  input: Github_UnmarkFileAsViewedInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UnmarkIssueAsDuplicateArgs = {
  github_token: Scalars['Secret'];
  input: Github_UnmarkIssueAsDuplicateInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UnminimizeCommentArgs = {
  github_token: Scalars['Secret'];
  input: Github_UnminimizeCommentInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UnpinIssueArgs = {
  github_token: Scalars['Secret'];
  input: Github_UnpinIssueInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UnresolveReviewThreadArgs = {
  github_token: Scalars['Secret'];
  input: Github_UnresolveReviewThreadInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateBranchProtectionRuleArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateBranchProtectionRuleInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateCheckRunArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateCheckRunInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateCheckSuitePreferencesArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateCheckSuitePreferencesInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateDiscussionArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateDiscussionInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateDiscussionCommentArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateDiscussionCommentInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateEnterpriseAdministratorRoleArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateEnterpriseAdministratorRoleInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateEnterpriseAllowPrivateRepositoryForkingSettingArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateEnterpriseDefaultRepositoryPermissionSettingArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateEnterpriseDefaultRepositoryPermissionSettingInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateEnterpriseMembersCanCreateRepositoriesSettingArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateEnterpriseMembersCanCreateRepositoriesSettingInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateEnterpriseMembersCanDeleteIssuesSettingArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateEnterpriseMembersCanDeleteIssuesSettingInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateEnterpriseMembersCanDeleteRepositoriesSettingArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateEnterpriseMembersCanInviteCollaboratorsSettingArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateEnterpriseMembersCanMakePurchasesSettingArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateEnterpriseMembersCanMakePurchasesSettingInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateEnterpriseMembersCanViewDependencyInsightsSettingArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateEnterpriseOrganizationProjectsSettingArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateEnterpriseOrganizationProjectsSettingInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateEnterpriseProfileArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateEnterpriseProfileInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateEnterpriseRepositoryProjectsSettingArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateEnterpriseRepositoryProjectsSettingInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateEnterpriseTeamDiscussionsSettingArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateEnterpriseTeamDiscussionsSettingInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateEnvironmentArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateEnvironmentInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateIpAllowListEnabledSettingArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateIpAllowListEnabledSettingInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateIpAllowListEntryArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateIpAllowListEntryInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateIpAllowListForInstalledAppsEnabledSettingArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateIpAllowListForInstalledAppsEnabledSettingInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateIssueArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateIssueInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateIssueCommentArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateIssueCommentInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateLabelArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateLabelInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateNotificationRestrictionSettingArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateNotificationRestrictionSettingInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateOrganizationAllowPrivateRepositoryForkingSettingArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateOrganizationAllowPrivateRepositoryForkingSettingInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateProjectArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateProjectInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateProjectCardArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateProjectCardInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateProjectColumnArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateProjectColumnInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateProjectNextItemFieldArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateProjectNextItemFieldInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdatePullRequestArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdatePullRequestInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdatePullRequestBranchArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdatePullRequestBranchInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdatePullRequestReviewArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdatePullRequestReviewInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdatePullRequestReviewCommentArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdatePullRequestReviewCommentInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateRefArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateRefInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateRefsArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateRefsInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateRepositoryArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateRepositoryInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateSponsorshipPreferencesArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateSponsorshipPreferencesInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateSubscriptionArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateSubscriptionInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateTeamDiscussionArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateTeamDiscussionInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateTeamDiscussionCommentArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateTeamDiscussionCommentInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateTeamReviewAssignmentArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateTeamReviewAssignmentInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_UpdateTopicsArgs = {
  github_token: Scalars['Secret'];
  input: Github_UpdateTopicsInput;
};


/**
 * Mutation root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `mutation`.
 *
 * If an operation is a `mutation`, the result of the operation is the result of executing the mutations
 * top level selection set on the `Mutation` root object type. This selection set is executed serially.
 *
 * It is expected that the top level fields in a `mutation` operation perform sideeffects on backend data systems.
 * Serial execution of the provided mutations ensures against race conditions during these sideeffects.
 */
export type MutationGithub_VerifyVerifiableDomainArgs = {
  github_token: Scalars['Secret'];
  input: Github_VerifyVerifiableDomainInput;
};

/**
 * PageInfo indicates if more results are available in a connection.
 * See *GraphQL Cursor Connections Specification*
 */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** Cursor corresponding to the last node in edges */
  endCursor: Scalars['String'];
  /** Indicates whether more edges exist following the set defined by the pagination arguments. */
  hasNextPage: Scalars['Boolean'];
  /** Indicates whether more edges exist prior to the set defined by the pagination arguments. */
  hasPreviousPage: Scalars['Boolean'];
  /** Cursor corresponding to the first node in edges */
  startCursor: Scalars['String'];
};

/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type Query = {
  __typename?: 'Query';
  /**
   * A published article by ID
   * This endpoint allows the client to retrieve a single published article given its `id`.
   */
  devto_getArticleById?: Maybe<Devto_ArticleShow>;
  /**
   * A published article by path
   * This endpoint allows the client to retrieve a single published article given its `path`.
   */
  devto_getArticleByPath?: Maybe<Devto_ArticleShow>;
  /**
   * Published articles
   * This endpoint allows the client to retrieve a list of articles.
   *
   * "Articles" are all the posts that users create on DEV that typically
   * show up in the feed. They can be a blog post, a discussion question,
   * a help thread etc. but is referred to as article within the code.
   *
   * By default it will return featured, published articles ordered
   * by descending popularity.
   *
   * It supports pagination, each page will contain `30` articles by default.
   */
  devto_getArticles?: Maybe<Array<Maybe<Devto_GetArticlesResponse>>>;
  /**
   * Articles with a video
   * This endpoint allows the client to retrieve a list of articles
   * that are uploaded with a video.
   *
   * It will only return published video articles
   * ordered by descending popularity.
   *
   * It supports pagination, each page will contain `24` articles by default.
   */
  devto_getArticlesWithVideo?: Maybe<Array<Maybe<Devto_GetArticlesWithVideoResponse>>>;
  /**
   * Comment
   * This endpoint allows the client to retrieve a comment as well as his descendants comments.
   *
   * It will return the required comment (the root) with its nested descendants as a thread.
   *
   * See the format specification for further details.
   */
  devto_getCommentById?: Maybe<Devto_DevToComment>;
  /**
   * Comments
   * This endpoint allows the client to retrieve all comments belonging to an
   * article or podcast episode as threaded conversations.
   *
   * It will return the all top level comments with their nested comments as
   * threads. See the format specification for further details.
   */
  devto_getCommentsByArticleId?: Maybe<Array<Maybe<Devto_GetCommentsByArticleIdResponse>>>;
  /** Followed tags: This endpoint allows the client to retrieve a list of the tags they follow. */
  devto_getFollowedTags?: Maybe<Array<Maybe<Devto_GetFollowedTagsResponse>>>;
  /**
   * Followers
   * This endpoint allows the client to retrieve a list of the followers they have.
   *
   * "Followers" are users that are following other users on the website.
   *
   * It supports pagination, each page will contain `80` followers by default.
   */
  devto_getFollowers?: Maybe<Array<Maybe<Devto_GetFollowersResponse>>>;
  /**
   * Published articles sorted by publish date
   * This endpoint allows the client to retrieve a list of articles.
   * ordered by descending publish date.
   *
   * It supports pagination, each page will contain `30` articles by default.
   */
  devto_getLatestArticles?: Maybe<Array<Maybe<Devto_GetLatestArticlesResponse>>>;
  /**
   * A listing
   * This endpoint allows the client to retrieve a single listing given its `id`.
   *
   * An unpublished listing is only accessible if authentication is supplied and it belongs to the authenticated user.
   */
  devto_getListingById?: Maybe<Devto_Listing>;
  /**
   * Published listings
   * This endpoint allows the client to retrieve a list of listings.
   *
   * "Listings" are classified ads that users create on DEV.
   * They can be related to conference announcements, job offers, mentorships,
   * upcoming events and more.
   *
   * By default it will return published listings ordered by descending
   * freshness.
   *
   * It supports pagination, each page will contain `30` articles by default.
   */
  devto_getListings?: Maybe<Array<Maybe<Devto_GetListingsResponse>>>;
  /**
   * Published listings by category
   * This endpoint allows the client to retrieve a list of listings belonging
   * to the specified category.
   *
   * "Listings" are classified ads that users create on DEV.
   * They can be related to conference announcements, job offers, mentorships,
   * upcoming events and more.
   *
   * By default it will return published listings ordered by descending
   * freshness.
   *
   * It supports pagination, each page will contain `30` articles by default.
   */
  devto_getListingsByCategory?: Maybe<Array<Maybe<Devto_GetListingsByCategoryResponse>>>;
  /**
   * Organization's Articles
   * This endpoint allows the client to retrieve a list of Articles belonging to the organization
   *
   * It supports pagination, each page will contain `30` listing by default.
   */
  devto_getOrgArticles?: Maybe<Array<Maybe<Devto_GetOrgArticlesResponse>>>;
  /**
   * Organization's listings
   * This endpoint allows the client to retrieve a list of listings belonging to the organization
   *
   * It supports pagination, each page will contain `30` listing by default.
   */
  devto_getOrgListings?: Maybe<Array<Maybe<Devto_GetOrgListingsResponse>>>;
  /**
   * Organization's users
   * This endpoint allows the client to retrieve a list of users belonging to the organization
   *
   * It supports pagination, each page will contain `30` users by default.
   */
  devto_getOrgUsers?: Maybe<Array<Maybe<Devto_GetOrgUsersResponse>>>;
  /**
   * An organization
   * This endpoint allows the client to retrieve a single organization by their username
   */
  devto_getOrganization?: Maybe<Devto_DevToOrganization>;
  /**
   * Published podcast episodes
   * This endpoint allows the client to retrieve a list of podcast episodes.
   *
   * "Podcast episodes" are episodes belonging to podcasts.
   *
   * It will only return active podcast episodes that belong to published
   * podcasts available on the platform,
   * ordered by descending publication date.
   *
   * It supports pagination, each page will contain `30` articles by default.
   */
  devto_getPodcastEpisodes?: Maybe<Array<Maybe<Devto_GetPodcastEpisodesResponse>>>;
  /**
   * User or organization profile picture
   * This endpoint allows the client to retrieve a user or organization
   * profile image information by its corresponding username
   */
  devto_getProfileImage?: Maybe<Devto_ProfileImage>;
  /**
   * User's reading list
   * This endpoint allows the client to retrieve a list of readinglist reactions along with the related article for the authenticated user.
   *
   * Reading list will be in reverse chronological order base
   * on the creation of the reaction.
   *
   * It will return paginated reading list items along with the articles
   * they refer to. By default a page will contain `30` items
   */
  devto_getReadinglist?: Maybe<Array<Maybe<Devto_GetReadinglistResponse>>>;
  /**
   * Tags
   * This endpoint allows the client to retrieve a list of tags that can be used to tag articles.
   *
   * It will return tags ordered by popularity.
   *
   * It supports pagination, each page will contain `10` tags by default.
   */
  devto_getTags?: Maybe<Array<Maybe<Devto_GetTagsResponse>>>;
  /**
   * A user
   * This endpoint allows the client to retrieve a single user, either by id or by the user's username
   */
  devto_getUser?: Maybe<Devto_DevToUser>;
  /**
   * User's all articles
   * This endpoint allows the client to retrieve a list of all articles on behalf of an authenticated user.
   *
   * "Articles" are all the posts that users create on DEV that typically
   * show up in the feed. They can be a blog post, a discussion question,
   * a help thread etc. but is referred to as article within the code.
   *
   * It will return both published and unpublished articles with pagination.
   *
   * Unpublished articles will be at the top of the list in reverse chronological creation order.
   * Published articles will follow in reverse chronological publication order.
   *
   * By default a page will contain `30` articles.
   */
  devto_getUserAllArticles?: Maybe<Array<Maybe<Devto_GetUserAllArticlesResponse>>>;
  /**
   * User's articles
   * This endpoint allows the client to retrieve a list of published articles on behalf of an authenticated user.
   *
   * "Articles" are all the posts that users create on DEV that typically
   * show up in the feed. They can be a blog post, a discussion question,
   * a help thread etc. but is referred to as article within the code.
   *
   * Published articles will be in reverse chronological publication order.
   *
   * It will return published articles with pagination.
   * By default a page will contain `30` articles.
   */
  devto_getUserArticles?: Maybe<Array<Maybe<Devto_GetUserArticlesResponse>>>;
  /**
   * The authenticated user
   * This endpoint allows the client to retrieve information about the authenticated user
   */
  devto_getUserMe?: Maybe<Devto_DevToUser>;
  /**
   * User's published articles
   * This endpoint allows the client to retrieve a list of published articles
   * on behalf of an authenticated user.
   *
   * "Articles" are all the posts that users create on DEV that typically
   * show up in the feed. They can be a blog post, a discussion question,
   * a help thread etc. but is referred to as article within the code.
   *
   * Published articles will be in reverse chronological publication order.
   *
   * It will return published articles with pagination.
   * By default a page will contain `30` articles.
   */
  devto_getUserPublishedArticles?: Maybe<Array<Maybe<Devto_GetUserPublishedArticlesResponse>>>;
  /**
   * User's unpublished articles
   * This endpoint allows the client to retrieve a list of unpublished articles
   * on behalf of an authenticated user.
   *
   * "Articles" are all the posts that users create on DEV that typically
   * show up in the feed. They can be a blog post, a discussion question,
   * a help thread etc. but is referred to as article within the code.
   *
   * Unpublished articles will be in reverse chronological creation order.
   *
   * It will return unpublished articles with pagination.
   * By default a page will contain `30` articles.
   */
  devto_getUserUnpublishedArticles?: Maybe<Array<Maybe<Devto_GetUserUnpublishedArticlesResponse>>>;
  /**
   * A webhook endpoint
   * This endpoint allows the client to retrieve a single
   * webhook given its `id`.
   */
  devto_getWebhookById?: Maybe<Devto_WebhookShow>;
  /**
   * Webhooks
   * This endpoint allows the client to retrieve a list of webhooks they have
   * previously registered.
   *
   * "Webhooks" are used to register HTTP endpoints that will be called once a relevant event is
   * triggered inside the web application, events like `article_created`, `article_updated`.
   *
   * It will return all webhooks, without pagination.
   */
  devto_getWebhooks?: Maybe<Array<Maybe<Devto_GetWebhooksResponse>>>;
  /** Look up a code of conduct by its key */
  github_codeOfConduct?: Maybe<Github_CodeOfConduct>;
  /** Look up a code of conduct by its key */
  github_codesOfConduct?: Maybe<Array<Maybe<Github_CodeOfConduct>>>;
  /** Look up an enterprise by URL slug. */
  github_enterprise?: Maybe<Github_Enterprise>;
  /** Look up a pending enterprise administrator invitation by invitee, enterprise and role. */
  github_enterpriseAdministratorInvitation?: Maybe<Github_EnterpriseAdministratorInvitation>;
  /** Look up a pending enterprise administrator invitation by invitation token. */
  github_enterpriseAdministratorInvitationByToken?: Maybe<Github_EnterpriseAdministratorInvitation>;
  /** Look up an open source license by its key */
  github_license?: Maybe<Github_License>;
  /** Return a list of known open source licenses */
  github_licenses: Array<Maybe<Github_License>>;
  /** Get alphabetically sorted list of Marketplace categories */
  github_marketplaceCategories: Array<Github_MarketplaceCategory>;
  /** Look up a Marketplace category by its slug. */
  github_marketplaceCategory?: Maybe<Github_MarketplaceCategory>;
  /** Look up a single Marketplace listing */
  github_marketplaceListing?: Maybe<Github_MarketplaceListing>;
  /** Look up Marketplace listings */
  github_marketplaceListings: Github_MarketplaceListingConnection;
  /** Return information about the GitHub instance */
  github_meta: Github_GitHubMetadata;
  /** Fetches an object given its ID. */
  github_node?: Maybe<Github_Node>;
  /** Lookup nodes by a list of IDs. */
  github_nodes: Array<Maybe<Github_Node>>;
  /** Lookup a organization by login. */
  github_organization?: Maybe<Github_Organization>;
  /** The client's rate limit information. */
  github_rateLimit?: Maybe<Github_RateLimit>;
  /** Hack to workaround https://github.com/facebook/relay/issues/112 re-exposing the root query object */
  github_relay: Query;
  /** Lookup a given repository by the owner and repository name. */
  github_repository?: Maybe<Github_Repository>;
  /** Lookup a repository owner (ie. either a User or an Organization) by login. */
  github_repositoryOwner?: Maybe<Github_RepositoryOwner>;
  /** Lookup resource by a URL. */
  github_resource?: Maybe<Github_UniformResourceLocatable>;
  /** Perform a search across resources. */
  github_search: Github_SearchResultItemConnection;
  /** GitHub Security Advisories */
  github_securityAdvisories: Github_SecurityAdvisoryConnection;
  /** Fetch a Security Advisory by its GHSA ID */
  github_securityAdvisory?: Maybe<Github_SecurityAdvisory>;
  /** Software Vulnerabilities documented by GitHub Security Advisories */
  github_securityVulnerabilities: Github_SecurityVulnerabilityConnection;
  /** Users and organizations who can be sponsored via GitHub Sponsors. */
  github_sponsorables: Github_SponsorableItemConnection;
  /** Look up a topic by name. */
  github_topic?: Maybe<Github_Topic>;
  /** Lookup a user by login. */
  github_user?: Maybe<Github_User>;
  /** The currently authenticated user. */
  github_viewer: Github_User;
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryDevto_GetArticleByIdArgs = {
  id: Scalars['String'];
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryDevto_GetArticleByPathArgs = {
  slug: Scalars['String'];
  username: Scalars['String'];
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryDevto_GetArticlesArgs = {
  collection_id?: InputMaybe<Scalars['Int']>;
  page?: InputMaybe<Scalars['Int']>;
  per_page?: InputMaybe<Scalars['Int']>;
  state?: InputMaybe<Scalars['String']>;
  tag?: InputMaybe<Scalars['String']>;
  tags?: InputMaybe<Scalars['String']>;
  tags_exclude?: InputMaybe<Scalars['String']>;
  top?: InputMaybe<Scalars['Int']>;
  username?: InputMaybe<Scalars['String']>;
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryDevto_GetArticlesWithVideoArgs = {
  page?: InputMaybe<Scalars['Int']>;
  per_page?: InputMaybe<Scalars['Int']>;
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryDevto_GetCommentByIdArgs = {
  id: Scalars['String'];
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryDevto_GetCommentsByArticleIdArgs = {
  a_id?: InputMaybe<Scalars['Int']>;
  p_id?: InputMaybe<Scalars['Int']>;
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryDevto_GetFollowedTagsArgs = {
  devto_api_key: Scalars['Secret'];
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryDevto_GetFollowersArgs = {
  devto_api_key: Scalars['Secret'];
  page?: InputMaybe<Scalars['Int']>;
  per_page?: InputMaybe<Scalars['Int']>;
  sort?: InputMaybe<Scalars['String']>;
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryDevto_GetLatestArticlesArgs = {
  page?: InputMaybe<Scalars['Int']>;
  per_page?: InputMaybe<Scalars['Int']>;
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryDevto_GetListingByIdArgs = {
  id: Scalars['String'];
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryDevto_GetListingsArgs = {
  category?: InputMaybe<Scalars['String']>;
  page?: InputMaybe<Scalars['Int']>;
  per_page?: InputMaybe<Scalars['Int']>;
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryDevto_GetListingsByCategoryArgs = {
  category: Scalars['String'];
  page?: InputMaybe<Scalars['Int']>;
  per_page?: InputMaybe<Scalars['Int']>;
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryDevto_GetOrgArticlesArgs = {
  page?: InputMaybe<Scalars['Int']>;
  per_page?: InputMaybe<Scalars['Int']>;
  username: Scalars['String'];
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryDevto_GetOrgListingsArgs = {
  category?: InputMaybe<Scalars['String']>;
  page?: InputMaybe<Scalars['Int']>;
  per_page?: InputMaybe<Scalars['Int']>;
  username: Scalars['String'];
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryDevto_GetOrgUsersArgs = {
  page?: InputMaybe<Scalars['Int']>;
  per_page?: InputMaybe<Scalars['Int']>;
  username: Scalars['String'];
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryDevto_GetOrganizationArgs = {
  username: Scalars['String'];
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryDevto_GetPodcastEpisodesArgs = {
  page?: InputMaybe<Scalars['Int']>;
  per_page?: InputMaybe<Scalars['Int']>;
  username?: InputMaybe<Scalars['String']>;
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryDevto_GetProfileImageArgs = {
  username: Scalars['String'];
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryDevto_GetReadinglistArgs = {
  devto_api_key: Scalars['Secret'];
  page?: InputMaybe<Scalars['Int']>;
  per_page?: InputMaybe<Scalars['Int']>;
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryDevto_GetTagsArgs = {
  page?: InputMaybe<Scalars['Int']>;
  per_page?: InputMaybe<Scalars['Int']>;
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryDevto_GetUserArgs = {
  id: Scalars['String'];
  url?: InputMaybe<Scalars['String']>;
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryDevto_GetUserAllArticlesArgs = {
  devto_api_key: Scalars['Secret'];
  page?: InputMaybe<Scalars['Int']>;
  per_page?: InputMaybe<Scalars['Int']>;
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryDevto_GetUserArticlesArgs = {
  devto_api_key: Scalars['Secret'];
  page?: InputMaybe<Scalars['Int']>;
  per_page?: InputMaybe<Scalars['Int']>;
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryDevto_GetUserMeArgs = {
  devto_api_key: Scalars['Secret'];
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryDevto_GetUserPublishedArticlesArgs = {
  devto_api_key: Scalars['Secret'];
  page?: InputMaybe<Scalars['Int']>;
  per_page?: InputMaybe<Scalars['Int']>;
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryDevto_GetUserUnpublishedArticlesArgs = {
  devto_api_key: Scalars['Secret'];
  page?: InputMaybe<Scalars['Int']>;
  per_page?: InputMaybe<Scalars['Int']>;
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryDevto_GetWebhookByIdArgs = {
  devto_api_key: Scalars['Secret'];
  id: Scalars['String'];
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryDevto_GetWebhooksArgs = {
  devto_api_key: Scalars['Secret'];
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryGithub_CodeOfConductArgs = {
  github_token: Scalars['Secret'];
  key: Scalars['String'];
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryGithub_CodesOfConductArgs = {
  github_token: Scalars['Secret'];
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryGithub_EnterpriseArgs = {
  github_token: Scalars['Secret'];
  invitationToken?: InputMaybe<Scalars['String']>;
  slug: Scalars['String'];
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryGithub_EnterpriseAdministratorInvitationArgs = {
  enterpriseSlug: Scalars['String'];
  github_token: Scalars['Secret'];
  role: Github_EnterpriseAdministratorRole;
  userLogin: Scalars['String'];
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryGithub_EnterpriseAdministratorInvitationByTokenArgs = {
  github_token: Scalars['Secret'];
  invitationToken: Scalars['String'];
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryGithub_LicenseArgs = {
  github_token: Scalars['Secret'];
  key: Scalars['String'];
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryGithub_LicensesArgs = {
  github_token: Scalars['Secret'];
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryGithub_MarketplaceCategoriesArgs = {
  excludeEmpty?: InputMaybe<Scalars['Boolean']>;
  excludeSubcategories?: InputMaybe<Scalars['Boolean']>;
  github_token: Scalars['Secret'];
  includeCategories?: InputMaybe<Array<Scalars['String']>>;
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryGithub_MarketplaceCategoryArgs = {
  github_token: Scalars['Secret'];
  slug: Scalars['String'];
  useTopicAliases?: InputMaybe<Scalars['Boolean']>;
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryGithub_MarketplaceListingArgs = {
  github_token: Scalars['Secret'];
  slug: Scalars['String'];
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryGithub_MarketplaceListingsArgs = {
  adminId?: InputMaybe<Scalars['ID']>;
  after?: InputMaybe<Scalars['String']>;
  allStates?: InputMaybe<Scalars['Boolean']>;
  before?: InputMaybe<Scalars['String']>;
  categorySlug?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  github_token: Scalars['Secret'];
  last?: InputMaybe<Scalars['Int']>;
  organizationId?: InputMaybe<Scalars['ID']>;
  primaryCategoryOnly?: InputMaybe<Scalars['Boolean']>;
  slugs?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  useTopicAliases?: InputMaybe<Scalars['Boolean']>;
  viewerCanAdmin?: InputMaybe<Scalars['Boolean']>;
  withFreeTrialsOnly?: InputMaybe<Scalars['Boolean']>;
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryGithub_MetaArgs = {
  github_token: Scalars['Secret'];
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryGithub_NodeArgs = {
  github_token: Scalars['Secret'];
  id: Scalars['ID'];
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryGithub_NodesArgs = {
  github_token: Scalars['Secret'];
  ids: Array<Scalars['ID']>;
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryGithub_OrganizationArgs = {
  github_token: Scalars['Secret'];
  login: Scalars['String'];
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryGithub_RateLimitArgs = {
  dryRun?: InputMaybe<Scalars['Boolean']>;
  github_token: Scalars['Secret'];
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryGithub_RelayArgs = {
  github_token: Scalars['Secret'];
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryGithub_RepositoryArgs = {
  followRenames?: InputMaybe<Scalars['Boolean']>;
  github_token: Scalars['Secret'];
  name: Scalars['String'];
  owner: Scalars['String'];
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryGithub_RepositoryOwnerArgs = {
  github_token: Scalars['Secret'];
  login: Scalars['String'];
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryGithub_ResourceArgs = {
  github_token: Scalars['Secret'];
  url: Scalars['Github_URI'];
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryGithub_SearchArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  github_token: Scalars['Secret'];
  last?: InputMaybe<Scalars['Int']>;
  query: Scalars['String'];
  type: Github_SearchType;
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryGithub_SecurityAdvisoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  github_token: Scalars['Secret'];
  identifier?: InputMaybe<Github_SecurityAdvisoryIdentifierFilter>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SecurityAdvisoryOrder>;
  publishedSince?: InputMaybe<Scalars['DateTime']>;
  updatedSince?: InputMaybe<Scalars['DateTime']>;
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryGithub_SecurityAdvisoryArgs = {
  ghsaId: Scalars['String'];
  github_token: Scalars['Secret'];
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryGithub_SecurityVulnerabilitiesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  ecosystem?: InputMaybe<Github_SecurityAdvisoryEcosystem>;
  first?: InputMaybe<Scalars['Int']>;
  github_token: Scalars['Secret'];
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Github_SecurityVulnerabilityOrder>;
  package?: InputMaybe<Scalars['String']>;
  severities?: InputMaybe<Array<Github_SecurityAdvisorySeverity>>;
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryGithub_SponsorablesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  dependencyEcosystem?: InputMaybe<Github_SecurityAdvisoryEcosystem>;
  first?: InputMaybe<Scalars['Int']>;
  github_token: Scalars['Secret'];
  last?: InputMaybe<Scalars['Int']>;
  onlyDependencies?: InputMaybe<Scalars['Boolean']>;
  orderBy?: InputMaybe<Github_SponsorableOrder>;
  orgLoginForDependencies?: InputMaybe<Scalars['String']>;
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryGithub_TopicArgs = {
  github_token: Scalars['Secret'];
  name: Scalars['String'];
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryGithub_UserArgs = {
  github_token: Scalars['Secret'];
  login: Scalars['String'];
};


/**
 * Query root object type.
 *
 * Contains fields that are available at the top level of a GraphQL `query`.
 *
 * If an operation is a `query`, the result of the operation is the result of
 * executing the querys top level selection set with the `Query` root object type.
 */
export type QueryGithub_ViewerArgs = {
  github_token: Scalars['Secret'];
};


export const MyQueryDocument = gql`
    query MyQuery($login: String!, $username: String!, $github_token: Secret!, $first: Int = 5, $after: String = null) {
  github_user(login: $login, github_token: $github_token) {
    bio
    repositories(first: $first, after: $after) {
      pageInfo {
        endCursor
        hasNextPage
      }
      edges {
        node {
          id
          owner {
            login
          }
          name
          description
          stargazerCount
          updatedAt
        }
      }
    }
  }
  devto_getArticles(username: $username) {
    title
    url
  }
}
    `;
export const GetGithubRepositoryDocument = gql`
    query GetGithubRepository($name: String!, $owner: String!, $github_token: Secret!) {
  github_repository(name: $name, owner: $owner, github_token: $github_token) {
    id
    name
    description
    stargazerCount
    updatedAt
  }
}
    `;

export type SdkFunctionWrapper = <T>(action: (requestHeaders?:Record<string, string>) => Promise<T>, operationName: string, operationType?: string) => Promise<T>;


const defaultWrapper: SdkFunctionWrapper = (action, _operationName, _operationType) => action();

export function getSdk(client: GraphQLClient, withWrapper: SdkFunctionWrapper = defaultWrapper) {
  return {
    MyQuery(variables: MyQueryQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<MyQueryQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<MyQueryQuery>(MyQueryDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'MyQuery', 'query');
    },
    GetGithubRepository(variables: GetGithubRepositoryQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetGithubRepositoryQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetGithubRepositoryQuery>(GetGithubRepositoryDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'GetGithubRepository', 'query');
    }
  };
}
export type Sdk = ReturnType<typeof getSdk>;